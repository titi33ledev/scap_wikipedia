(self["webpackChunkipysigma"] = self["webpackChunkipysigma"] || []).push([["vendors-node_modules_yomguithereal_sigma-experiments-renderers_edge_edge_curve_js-node_module-008457"],{

/***/ "./node_modules/@yomguithereal/sigma-experiments-renderers/edge/edge.curve.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@yomguithereal/sigma-experiments-renderers/edge/edge.curve.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var utils_1 = __webpack_require__(/*! sigma/utils */ "./node_modules/sigma/utils/index.js");
var edge_1 = __webpack_require__(/*! sigma/rendering/webgl/programs/common/edge */ "./node_modules/sigma/rendering/webgl/programs/common/edge.js");
var VERTEX_SHADER_SOURCE = /*glsl*/ "\nattribute vec4 a_color;\nattribute float a_direction;\nattribute float a_thickness;\nattribute vec2 a_source;\nattribute vec2 a_target;\nattribute float a_current;\nattribute float a_curveness;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform vec2 u_dimensions;\n\nvarying vec4 v_color;\nvarying float v_thickness;\nvarying vec2 v_cpA;\nvarying vec2 v_cpB;\nvarying vec2 v_cpC;\n\nconst float bias = 255.0 / 254.0;\nconst float epsilon = 0.7;\nconst float minThickness = 0.3;\n\nvec2 clipspaceToViewport(vec2 pos, vec2 dimensions) {\n  return vec2(\n    (pos.x + 1.0) * dimensions.x / 2.0,\n    (pos.y + 1.0) * dimensions.y / 2.0\n  );\n}\n\nvec2 viewportToClipspace(vec2 pos, vec2 dimensions) {\n  return vec2(\n    pos.x / dimensions.x * 2.0 - 1.0,\n    pos.y / dimensions.y * 2.0 - 1.0\n  );\n}\n\nvoid main() {\n\n  // Selecting the correct position\n  // Branchless \"position = a_source if a_current == 1.0 else a_target\"\n  vec2 position = a_source * max(0.0, a_current) + a_target * max(0.0, 1.0 - a_current);\n  position = (u_matrix * vec3(position, 1)).xy;\n\n  vec2 source = (u_matrix * vec3(a_source, 1)).xy;\n  vec2 target = (u_matrix * vec3(a_target, 1)).xy;\n\n  vec2 viewportPosition = clipspaceToViewport(position, u_dimensions);\n  vec2 viewportSource = clipspaceToViewport(source, u_dimensions);\n  vec2 viewportTarget = clipspaceToViewport(target, u_dimensions);\n\n  vec2 delta = viewportTarget.xy - viewportSource.xy;\n  float len = length(delta);\n  vec2 normal = vec2(-delta.y, delta.x) * a_direction;\n  vec2 unitNormal = normal / len;\n  float boundingBoxThickness = len * a_curveness;\n  float curveThickness = max(minThickness, a_thickness / 2.0 / u_sizeRatio * u_pixelRatio);\n\n  v_thickness = curveThickness;\n\n  v_cpA = viewportSource;\n  v_cpB = 0.5 * (viewportSource + viewportTarget) + unitNormal * a_direction * boundingBoxThickness;\n  v_cpC = viewportTarget;\n\n  vec2 viewportOffsetPosition = (\n    viewportPosition +\n    unitNormal * (boundingBoxThickness / 2.0 + curveThickness + epsilon) *\n    max(0.0, a_direction) // NOTE: cutting the bounding box in half to avoid overdraw\n  );\n\n  position = viewportToClipspace(viewportOffsetPosition, u_dimensions);\n  gl_Position = vec4(position, 0, 1);\n\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";
var FRAGMENT_SHADER_SOURCE = /*glsl*/ "\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying float v_thickness;\nvarying vec2 v_cpA;\nvarying vec2 v_cpB;\nvarying vec2 v_cpC;\n\nfloat det(vec2 a, vec2 b) {\n  return a.x * b.y - b.x * a.y;\n}\n\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a = det(b0, b2), b = 2.0 * det(b1, b0), d = 2.0 * det(b2, b1);\n  float f = b * d - a * a;\n  vec2 d21 = b2 - b1, d10 = b1 - b0, d20 = b2 - b0;\n  vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\n  gf = vec2(gf.y, -gf.x);\n  vec2 pp = -f * gf / dot(gf, gf);\n  vec2 d0p = b0 - pp;\n  float ap = det(d0p, d20), bp = 2.0 * det(d10, d0p);\n  float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0, 1.0);\n  return mix(mix(b0, b1, t), mix(b1, b2, t), t);\n}\n\nfloat distToQuadraticBezierCurve(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0 - p, b1 - p, b2 - p));\n}\n\nconst float epsilon = 0.7;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float dist = distToQuadraticBezierCurve(gl_FragCoord.xy, v_cpA, v_cpB, v_cpC);\n\n  if (dist < v_thickness + epsilon) {\n    float inCurve = 1.0 - smoothstep(v_thickness - epsilon, v_thickness + epsilon, dist);\n    gl_FragColor = inCurve * vec4(v_color.rgb * v_color.a, v_color.a);\n  } else {\n    gl_FragColor = transparent;\n  }\n}\n";
var UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE, FLOAT = WebGLRenderingContext.FLOAT;
var UNIFORMS = ["u_matrix", "u_sizeRatio", "u_dimensions", "u_pixelRatio"];
var DEFAULT_EDGE_CURVENESS = 0.25;
var EdgeCurveProgram = /** @class */ (function (_super) {
    __extends(EdgeCurveProgram, _super);
    function EdgeCurveProgram() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EdgeCurveProgram.prototype.getDefinition = function () {
        return {
            VERTICES: 4,
            ARRAY_ITEMS_PER_VERTEX: 9,
            VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
            FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
            UNIFORMS: UNIFORMS,
            ATTRIBUTES: [
                { name: "a_source", size: 2, type: FLOAT },
                { name: "a_target", size: 2, type: FLOAT },
                { name: "a_current", size: 1, type: FLOAT },
                { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
                { name: "a_direction", size: 1, type: FLOAT },
                { name: "a_thickness", size: 1, type: FLOAT },
                { name: "a_curveness", size: 1, type: FLOAT },
            ]
        };
    };
    EdgeCurveProgram.prototype.reallocateIndices = function () {
        var l = this.verticesCount;
        var size = l + l / 2;
        var indices = new this.IndicesArray(size);
        for (var i = 0, c = 0; i < l; i += 4) {
            indices[c++] = i;
            indices[c++] = i + 1;
            indices[c++] = i + 2;
            indices[c++] = i + 2;
            indices[c++] = i + 1;
            indices[c++] = i + 3;
        }
        this.indicesArray = indices;
    };
    EdgeCurveProgram.prototype.processVisibleItem = function (i, sourceData, targetData, data) {
        var thickness = data.size || 1;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0, utils_1.floatColor)(data.color);
        var curveness = typeof data.curveness === "number" ? data.curveness : DEFAULT_EDGE_CURVENESS;
        var array = this.array;
        // First point
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = 0;
        array[i++] = color;
        array[i++] = 1;
        array[i++] = thickness;
        array[i++] = curveness;
        // First point flipped
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = 0;
        array[i++] = color;
        array[i++] = -1;
        array[i++] = thickness;
        array[i++] = curveness;
        // Second point
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = 1;
        array[i++] = color;
        array[i++] = 1;
        array[i++] = thickness;
        array[i++] = curveness;
        // Second point flipped
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = 1;
        array[i++] = color;
        array[i++] = -1;
        array[i++] = thickness;
        array[i++] = curveness;
    };
    EdgeCurveProgram.prototype.draw = function (params) {
        var gl = this.gl;
        var _a = this.uniformLocations, u_matrix = _a.u_matrix, u_sizeRatio = _a.u_sizeRatio, u_dimensions = _a.u_dimensions, u_pixelRatio = _a.u_pixelRatio;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.uniform1f(u_pixelRatio, params.pixelRatio);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform2f(u_dimensions, params.width * params.pixelRatio, params.height * params.pixelRatio);
        if (!this.indicesArray)
            throw new Error("EdgeCurveProgram: indicesArray should be allocated when drawing!");
        gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);
    };
    return EdgeCurveProgram;
}(edge_1.EdgeProgram));
exports["default"] = EdgeCurveProgram;


/***/ }),

/***/ "./node_modules/@yomguithereal/sigma-experiments-renderers/node/node.halo.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@yomguithereal/sigma-experiments-renderers/node/node.halo.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var node_1 = __webpack_require__(/*! sigma/rendering/webgl/programs/common/node */ "./node_modules/sigma/rendering/webgl/programs/common/node.js");
var node_circle_1 = __importDefault(__webpack_require__(/*! sigma/rendering/webgl/programs/node.circle */ "./node_modules/sigma/rendering/webgl/programs/node.circle.js"));
var utils_1 = __webpack_require__(/*! sigma/utils */ "./node_modules/sigma/utils/index.js");
var VERTEX_SHADER_SOURCE = /*glsl*/ "\nattribute vec2 a_position;\nattribute float a_size;\nattribute float a_angle;\nattribute vec4 a_color;\nattribute float a_intensity;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\nuniform float u_ignoreZoom;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\nvarying float v_intensity;\n\nconst float bias = 255.0 / 254.0;\nconst float marginRatio = 1.05;\n\nvoid main() {\n  float size = a_size * u_correctionRatio / u_sizeRatio * u_ignoreZoom * 4.0;\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\n  vec2 position = a_position + diffVector * marginRatio;\n  gl_Position = vec4(\n    (u_matrix * vec3(position, 1)).xy,\n    0,\n    1\n  );\n\n  v_border = u_correctionRatio;\n  v_diffVector = diffVector;\n  v_radius = size / 2.0 / marginRatio;\n\n  v_color = a_color;\n  v_color.a *= bias;\n\n  v_intensity = a_intensity;\n}\n";
var FRAGMENT_SHADER_SOURCE = /*glsl*/ "\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\nvarying float v_intensity;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float dist = length(v_diffVector);\n  float intensity = v_intensity * (1.0 - dist);\n\n  if (dist < v_radius) {\n    gl_FragColor = mix(v_color, transparent, pow(dist / v_radius, intensity));\n  }\n  else {\n    gl_FragColor = transparent;\n  }\n}\n";
var UNIFORMS = ["u_sizeRatio", "u_correctionRatio", "u_matrix", "u_ignoreZoom"];
var FLOAT = WebGLRenderingContext.FLOAT, UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE;
var NodeHaloProgram = /** @class */ (function (_super) {
    __extends(NodeHaloProgram, _super);
    function NodeHaloProgram() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeHaloProgram.prototype.getDefinition = function () {
        return {
            VERTICES: 3,
            ARRAY_ITEMS_PER_VERTEX: 6,
            VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
            FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
            UNIFORMS: UNIFORMS,
            ATTRIBUTES: [
                { name: "a_position", size: 2, type: FLOAT },
                { name: "a_size", size: 1, type: FLOAT },
                { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
                { name: "a_angle", size: 1, type: FLOAT },
                { name: "a_intensity", size: 1, type: FLOAT },
            ]
        };
    };
    NodeHaloProgram.prototype.processVisibleItem = function (i, data) {
        var array = this.array;
        var color = (0, utils_1.floatColor)(data.haloColor || data.color);
        var intensity = typeof data.haloIntensity === "number" ? data.haloIntensity : 1;
        var size = Math.max(typeof data.haloSize === "number" ? data.haloSize : 0, data.size);
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = size;
        array[i++] = color;
        array[i++] = node_circle_1["default"].ANGLE_1;
        array[i++] = intensity;
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = size;
        array[i++] = color;
        array[i++] = node_circle_1["default"].ANGLE_2;
        array[i++] = intensity;
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = size;
        array[i++] = color;
        array[i++] = node_circle_1["default"].ANGLE_3;
        array[i++] = intensity;
    };
    NodeHaloProgram.prototype.draw = function (params) {
        var gl = this.gl;
        var _a = this.uniformLocations, u_sizeRatio = _a.u_sizeRatio, u_correctionRatio = _a.u_correctionRatio, u_matrix = _a.u_matrix, u_ignoreZoom = _a.u_ignoreZoom;
        gl.uniform1f(u_ignoreZoom, 1);
        // NOTE: uncomment next line to disable zoom impact.
        // gl.uniform1f(u_ignoreZoom, 1 / params.sizeRatio);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.drawArrays(gl.TRIANGLES, 0, this.verticesCount);
    };
    return NodeHaloProgram;
}(node_1.NodeProgram));
exports["default"] = NodeHaloProgram;


/***/ }),

/***/ "./node_modules/@yomguithereal/sigma-experiments-renderers/node/node.pictogram.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@yomguithereal/sigma-experiments-renderers/node/node.pictogram.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var utils_1 = __webpack_require__(/*! sigma/utils */ "./node_modules/sigma/utils/index.js");
var node_1 = __webpack_require__(/*! sigma/rendering/webgl/programs/common/node */ "./node_modules/sigma/rendering/webgl/programs/common/node.js");
var DEFAULT_CREATE_NODE_PICTOGRAM_OPTIONS = {
    correctCentering: false,
    forcedSvgSize: undefined,
    keepWithinCircle: true
};
var VERTEX_SHADER_SOURCE = /*glsl*/ "\nattribute vec2 a_position;\nattribute float a_size;\nattribute vec4 a_color;\nattribute vec4 a_texture;\n\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\nvarying vec4 v_texture;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\n\n  v_border = (0.5 / a_size) * u_sizeRatio;\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n\n  // Pass the texture coordinates:\n  // NOTE: multiply a_texture by a constant and you get a pattern\n  v_texture = a_texture;\n}\n";
var FRAGMENT_SHADER_SOURCE = /*glsl*/ "\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\nvarying vec4 v_texture;\n\nuniform sampler2D u_atlas;\nuniform float u_keepWithinCircle;\n\nconst float radius = 0.5;\n\nvoid main(void) {\n  vec4 texel = texture2D(u_atlas, v_texture.xy + gl_PointCoord * v_texture.zw, -1.0);\n  vec4 color = mix(gl_FragColor, v_color, texel.a);\n\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = length(m) * u_keepWithinCircle;\n\n  if (dist < radius - v_border) {\n    gl_FragColor = color;\n  }\n}\n";
// maximum size of single texture in atlas
var MAX_TEXTURE_SIZE = Infinity;
// maximum width of atlas texture (limited by browser)
// low setting of 3072 works on phones & tablets
var MAX_CANVAS_WIDTH = 3072;
// Helper class able to "correct" the centering of a svg pictogram by
// finding the "true" visually correct center through the barycenter of the
// pictogram's alpha layer in x and y dimension.
var PictogramCenteringCorrector = /** @class */ (function () {
    function PictogramCenteringCorrector() {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
    }
    PictogramCenteringCorrector.prototype.getCorrectionOffset = function (image, size) {
        this.canvas.width = size;
        this.canvas.height = size;
        this.context.clearRect(0, 0, size, size);
        this.context.drawImage(image, 0, 0, size, size);
        var data = this.context.getImageData(0, 0, size, size).data;
        var alpha = new Uint8ClampedArray(data.length / 4);
        for (var i = 0; i < data.length; i++) {
            alpha[i] = data[i * 4 + 3];
        }
        var sumX = 0;
        var sumY = 0;
        var total = 0;
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                var a = alpha[y * size + x];
                total += a;
                sumX += a * x;
                sumY += a * y;
            }
        }
        var barycenterX = sumX / total;
        var barycenterY = sumY / total;
        return {
            x: barycenterX - size / 2,
            y: barycenterY - size / 2
        };
    };
    return PictogramCenteringCorrector;
}());
/**
 * To share the texture between the program instances of the graph and the
 * hovered nodes (to prevent some flickering, mostly), this program must be
 * "built" for each sigma instance:
 */
function createNodePictogramProgram(options) {
    options = Object.assign({}, DEFAULT_CREATE_NODE_PICTOGRAM_OPTIONS, options);
    var keepWithinCircle = options.keepWithinCircle !== false;
    var corrector = new PictogramCenteringCorrector();
    /**
     * These attributes are shared between all instances of this exact class,
     * returned by this call to getNodeProgramImage:
     */
    var rebindTextureFns = [];
    var images = {};
    var textureImage;
    var hasReceivedImages = false;
    var pendingImagesFrameID = undefined;
    // next write position in texture
    var writePositionX = 0;
    var writePositionY = 0;
    // height of current row
    var writeRowHeight = 0;
    /**
     * Helper to load an image:
     */
    function loadImage(imageSource) {
        if (images[imageSource])
            return;
        var forcedSvgSize = options === null || options === void 0 ? void 0 : options.forcedSvgSize;
        // If forcing a SVG size (typically to oversample the resulting rasterized
        // size so that the icon is crispier), we fetch the svg string and we
        // mangle it to force a certain size and view box.
        // Of course this cannot work if said SVG cannot be access through CORS.
        if (forcedSvgSize) {
            images[imageSource] = { status: "loading" };
            fetch(imageSource)
                .then(function (r) { return r.text(); })
                .then(function (svgString) {
                var svg = new DOMParser().parseFromString(svgString, "image/svg+xml");
                var root = svg.documentElement;
                var originalWidth = root.getAttribute("width");
                var originalHeight = root.getAttribute("height");
                if (!originalWidth || !originalHeight)
                    throw new Error("createNodePictogramProgram.loadImage: cannot use `forcedSvgSize` if target svg has no definite dimensions.");
                root.setAttribute("width", "" + forcedSvgSize);
                root.setAttribute("height", "" + forcedSvgSize);
                // NOTE: since Google Material last changes to their icon viewBox, this
                // code is no longer necessary (hopefully it does not break something else...)
                // root.setAttribute("viewBox", `0 0 ${originalWidth} ${originalHeight}`);
                var correctedSvgString = new XMLSerializer().serializeToString(svg);
                var blob = new Blob([correctedSvgString], { type: "image/svg+xml" });
                var url = URL.createObjectURL(blob);
                var svgImage = new Image();
                svgImage.src = url;
                svgImage.addEventListener("load", function () {
                    images[imageSource] = {
                        status: "pending",
                        image: svgImage
                    };
                    if (typeof pendingImagesFrameID !== "number") {
                        pendingImagesFrameID = requestAnimationFrame(function () { return finalizePendingImages(); });
                    }
                    URL.revokeObjectURL(url);
                }, { once: true });
            })["catch"](function () {
                images[imageSource] = { status: "error" };
            });
            return;
        }
        var image = new Image();
        image.addEventListener("load", function () {
            images[imageSource] = {
                status: "pending",
                image: image
            };
            if (typeof pendingImagesFrameID !== "number") {
                pendingImagesFrameID = requestAnimationFrame(function () { return finalizePendingImages(); });
            }
        });
        image.addEventListener("error", function () {
            images[imageSource] = { status: "error" };
        });
        images[imageSource] = { status: "loading" };
        // Load image:
        image.setAttribute("crossOrigin", "");
        image.src = imageSource;
    }
    /**
     * Helper that takes all pending images and adds them into the texture:
     */
    function finalizePendingImages() {
        pendingImagesFrameID = undefined;
        var pendingImages = [];
        // List all pending images:
        for (var id in images) {
            var state = images[id];
            if (state.status === "pending") {
                pendingImages.push({
                    id: id,
                    image: state.image,
                    size: Math.min(state.image.width, state.image.height) || 1
                });
            }
        }
        // Add images to texture:
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d", { willReadFrequently: true });
        // limit canvas size to avoid browser and platform limits
        var totalWidth = hasReceivedImages ? textureImage.width : 0;
        var totalHeight = hasReceivedImages ? textureImage.height : 0;
        // initialize image drawing offsets with current write position
        var xOffset = writePositionX;
        var yOffset = writePositionY;
        /**
         * Draws a (full or partial) row of images into the atlas texture
         * @param pendingImages
         */
        var drawRow = function (pendingImages) {
            // update canvas size before drawing
            if (canvas.width !== totalWidth || canvas.height !== totalHeight) {
                canvas.width = Math.min(MAX_CANVAS_WIDTH, totalWidth);
                canvas.height = totalHeight;
                // draw previous texture into resized canvas
                if (hasReceivedImages) {
                    ctx.putImageData(textureImage, 0, 0);
                }
            }
            pendingImages.forEach(function (_a) {
                var id = _a.id, image = _a.image, size = _a.size;
                var imageSizeInTexture = Math.min(MAX_TEXTURE_SIZE, size);
                // Crop image, to only keep the biggest square, centered:
                var dx = 0, dy = 0;
                if ((image.width || 0) > (image.height || 0)) {
                    dx = (image.width - image.height) / 2;
                }
                else {
                    dy = (image.height - image.width) / 2;
                }
                var dxOffset = 0;
                var dyOffset = 0;
                if (options === null || options === void 0 ? void 0 : options.correctCentering) {
                    var correction = corrector.getCorrectionOffset(image, size);
                    dxOffset = correction.x;
                    dyOffset = correction.y;
                }
                // NOTE: it's possible to offset the image here, this is potentially useful for some pictograms
                ctx.drawImage(image, dx + dxOffset, dy + dyOffset, size, size, xOffset, yOffset, imageSizeInTexture, imageSizeInTexture);
                // Update image state:
                images[id] = {
                    status: "ready",
                    x: xOffset,
                    y: yOffset,
                    width: imageSizeInTexture,
                    height: imageSizeInTexture
                };
                xOffset += imageSizeInTexture;
            });
            hasReceivedImages = true;
            textureImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
        };
        var rowImages = [];
        pendingImages.forEach(function (image) {
            var size = image.size;
            var imageSizeInTexture = Math.min(size, MAX_TEXTURE_SIZE);
            if (writePositionX + imageSizeInTexture > MAX_CANVAS_WIDTH) {
                // existing row is full: flush row and continue on next line
                if (rowImages.length > 0) {
                    totalWidth = Math.max(writePositionX, totalWidth);
                    totalHeight = Math.max(writePositionY + writeRowHeight, totalHeight);
                    drawRow(rowImages);
                    rowImages = [];
                    writeRowHeight = 0;
                }
                writePositionX = 0;
                writePositionY = totalHeight;
                xOffset = 0;
                yOffset = totalHeight;
            }
            // add image to row
            rowImages.push(image);
            // advance write position and update maximum row height
            writePositionX += imageSizeInTexture;
            writeRowHeight = Math.max(writeRowHeight, imageSizeInTexture);
        });
        // flush pending images in row - keep write position (and drawing cursor)
        totalWidth = Math.max(writePositionX, totalWidth);
        totalHeight = Math.max(writePositionY + writeRowHeight, totalHeight);
        drawRow(rowImages);
        rowImages = [];
        rebindTextureFns.forEach(function (fn) { return fn(); });
    }
    var UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE, FLOAT = WebGLRenderingContext.FLOAT;
    var UNIFORMS = ["u_sizeRatio", "u_pixelRatio", "u_matrix", "u_atlas", "u_keepWithinCircle"];
    return /** @class */ (function (_super) {
        __extends(NodePictogramProgram, _super);
        function NodePictogramProgram(gl, renderer) {
            var _this = _super.call(this, gl, renderer) || this;
            rebindTextureFns.push(function () {
                if (_this && _this.rebindTexture)
                    _this.rebindTexture();
                if (renderer && renderer.scheduleRefresh)
                    renderer.scheduleRefresh();
            });
            _this.texture = gl.createTexture();
            if (!textureImage) {
                textureImage = new ImageData(1, 1);
                gl.bindTexture(gl.TEXTURE_2D, _this.texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));
            }
            else {
                _this.rebindTexture();
            }
            return _this;
        }
        NodePictogramProgram.prototype.getDefinition = function () {
            return {
                VERTICES: 1,
                ARRAY_ITEMS_PER_VERTEX: 8,
                VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
                FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
                UNIFORMS: UNIFORMS,
                ATTRIBUTES: [
                    { name: "a_position", size: 2, type: FLOAT },
                    { name: "a_size", size: 1, type: FLOAT },
                    { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
                    { name: "a_texture", size: 4, type: FLOAT },
                ]
            };
        };
        NodePictogramProgram.prototype.rebindTexture = function () {
            var gl = this.gl;
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);
            gl.generateMipmap(gl.TEXTURE_2D);
            if (this.latestRenderParams)
                this.render(this.latestRenderParams);
        };
        NodePictogramProgram.prototype.processVisibleItem = function (i, data) {
            var array = this.array;
            var imageSource = data.pictogram;
            var imageState = imageSource && images[imageSource];
            if (typeof imageSource === "string" && !imageState)
                loadImage(imageSource);
            array[i++] = data.x;
            array[i++] = data.y;
            array[i++] = data.size;
            array[i++] = (0, utils_1.floatColor)(data.pictogramColor || "black");
            // Reference texture:
            if (imageState && imageState.status === "ready") {
                var width = textureImage.width, height = textureImage.height;
                array[i++] = imageState.x / width;
                array[i++] = imageState.y / height;
                array[i++] = imageState.width / width;
                array[i++] = imageState.height / height;
            }
            else {
                array[i++] = 0;
                array[i++] = 0;
                array[i++] = 0;
                array[i++] = 0;
            }
        };
        NodePictogramProgram.prototype.draw = function (params) {
            this.latestRenderParams = params;
            var gl = this.gl;
            var _a = this.uniformLocations, u_sizeRatio = _a.u_sizeRatio, u_pixelRatio = _a.u_pixelRatio, u_matrix = _a.u_matrix, u_atlas = _a.u_atlas, u_keepWithinCircle = _a.u_keepWithinCircle;
            gl.uniform1f(u_keepWithinCircle, keepWithinCircle ? 1 : 0);
            gl.uniform1f(u_sizeRatio, params.sizeRatio);
            gl.uniform1f(u_pixelRatio, params.pixelRatio);
            gl.uniformMatrix3fv(u_matrix, false, params.matrix);
            gl.uniform1i(u_atlas, 0);
            gl.drawArrays(gl.POINTS, 0, this.verticesCount);
        };
        return NodePictogramProgram;
    }(node_1.NodeProgram));
}
exports["default"] = createNodePictogramProgram;


/***/ }),

/***/ "./node_modules/@yomguithereal/sigma-experiments-renderers/node/node.point.border.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@yomguithereal/sigma-experiments-renderers/node/node.point.border.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var node_point_1 = __importDefault(__webpack_require__(/*! sigma/rendering/webgl/programs/node.point */ "./node_modules/sigma/rendering/webgl/programs/node.point.js"));
var utils_1 = __webpack_require__(/*! sigma/utils */ "./node_modules/sigma/utils/index.js");
var VERTEX_SHADER_SOURCE = /*glsl*/ "\nattribute vec2 a_position;\nattribute float a_size;\nattribute vec4 a_color;\nattribute vec4 a_borderColor;\nattribute float a_borderRatio;\n\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying vec4 v_borderColor;\nvarying float v_border;\nvarying float v_borderRatio;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\n\n  v_border = (0.5 / a_size) * u_sizeRatio;\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n\n  v_borderColor = a_borderColor;\n  v_borderColor.a *= bias;\n\n  v_borderRatio = 0.5 - a_borderRatio / 2.0;\n}\n";
var FRAGMENT_SHADER_SOURCE = /*glsl*/ "\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying vec4 v_borderColor;\nvarying float v_border;\nvarying float v_borderRatio;\n\nconst float radius = 0.5;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float distToCenter = length(gl_PointCoord - vec2(0.5, 0.5));\n\n  if (distToCenter < v_borderRatio - v_border)\n    gl_FragColor = v_color;\n  else if (distToCenter < v_borderRatio)\n    gl_FragColor = mix(v_borderColor, v_color, (v_borderRatio - distToCenter) / v_border);\n  else if (distToCenter < radius - v_border)\n    gl_FragColor = v_borderColor;\n  else if (distToCenter < radius)\n    gl_FragColor = mix(transparent, v_borderColor, (radius - distToCenter) / v_border);\n  else\n    gl_FragColor = transparent;\n}\n";
var FLOAT = WebGLRenderingContext.FLOAT, UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE;
var DEFAULT_NODE_BORDER_COLOR = "#7a7a7a";
var DEFAULT_NODE_BORDER_RATIO = 0.1;
var NodePointWithBorderProgram = /** @class */ (function (_super) {
    __extends(NodePointWithBorderProgram, _super);
    function NodePointWithBorderProgram() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodePointWithBorderProgram.prototype.getDefinition = function () {
        return __assign(__assign({}, _super.prototype.getDefinition.call(this)), { ARRAY_ITEMS_PER_VERTEX: 6, VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE, ATTRIBUTES: [
                { name: "a_position", size: 2, type: FLOAT },
                { name: "a_size", size: 1, type: FLOAT },
                { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
                { name: "a_borderColor", size: 4, type: UNSIGNED_BYTE, normalized: true },
                { name: "a_borderRatio", size: 1, type: FLOAT },
            ] });
    };
    NodePointWithBorderProgram.prototype.processVisibleItem = function (i, data) {
        var array = this.array;
        var borderRatio = typeof data.borderRatio !== "number" ? DEFAULT_NODE_BORDER_RATIO : data.borderRatio;
        // borderSize takes precedence
        if (typeof data.borderSize === "number") {
            borderRatio = data.borderSize / data.size;
        }
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = data.size;
        array[i++] = (0, utils_1.floatColor)(data.color);
        array[i++] = (0, utils_1.floatColor)(data.borderColor || DEFAULT_NODE_BORDER_COLOR);
        array[i] = borderRatio;
    };
    return NodePointWithBorderProgram;
}(node_point_1["default"]));
exports["default"] = NodePointWithBorderProgram;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/choices.js/public/assets/styles/choices.min.css":
/*!************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/choices.js/public/assets/styles/choices.min.css ***!
  \************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, ".choices{position:relative;overflow:hidden;margin-bottom:24px;font-size:16px}.choices:focus{outline:0}.choices:last-child{margin-bottom:0}.choices.is-open{overflow:visible}.choices.is-disabled .choices__inner,.choices.is-disabled .choices__input{background-color:#eaeaea;cursor:not-allowed;-webkit-user-select:none;user-select:none}.choices.is-disabled .choices__item{cursor:not-allowed}.choices [hidden]{display:none!important}.choices[data-type*=select-one]{cursor:pointer}.choices[data-type*=select-one] .choices__inner{padding-bottom:7.5px}.choices[data-type*=select-one] .choices__input{display:block;width:100%;padding:10px;border-bottom:1px solid #ddd;background-color:#fff;margin:0}.choices[data-type*=select-one] .choices__button{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjEiIGhlaWdodD0iMjEiIHZpZXdCb3g9IjAgMCAyMSAyMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Ik0yLjU5Mi4wNDRsMTguMzY0IDE4LjM2NC0yLjU0OCAyLjU0OEwuMDQ0IDIuNTkyeiIvPjxwYXRoIGQ9Ik0wIDE4LjM2NEwxOC4zNjQgMGwyLjU0OCAyLjU0OEwyLjU0OCAyMC45MTJ6Ii8+PC9nPjwvc3ZnPg==);padding:0;background-size:8px;position:absolute;top:50%;right:0;margin-top:-10px;margin-right:25px;height:20px;width:20px;border-radius:10em;opacity:.25}.choices[data-type*=select-one] .choices__button:focus,.choices[data-type*=select-one] .choices__button:hover{opacity:1}.choices[data-type*=select-one] .choices__button:focus{box-shadow:0 0 0 2px #00bcd4}.choices[data-type*=select-one] .choices__item[data-value=\"\"] .choices__button{display:none}.choices[data-type*=select-one]::after{content:\"\";height:0;width:0;border-style:solid;border-color:#333 transparent transparent;border-width:5px;position:absolute;right:11.5px;top:50%;margin-top:-2.5px;pointer-events:none}.choices[data-type*=select-one].is-open::after{border-color:transparent transparent #333;margin-top:-7.5px}.choices[data-type*=select-one][dir=rtl]::after{left:11.5px;right:auto}.choices[data-type*=select-one][dir=rtl] .choices__button{right:auto;left:0;margin-left:25px;margin-right:0}.choices[data-type*=select-multiple] .choices__inner,.choices[data-type*=text] .choices__inner{cursor:text}.choices[data-type*=select-multiple] .choices__button,.choices[data-type*=text] .choices__button{position:relative;display:inline-block;margin:0 -4px 0 8px;padding-left:16px;border-left:1px solid #008fa1;background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjEiIGhlaWdodD0iMjEiIHZpZXdCb3g9IjAgMCAyMSAyMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWxsPSIjRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGQ9Ik0yLjU5Mi4wNDRsMTguMzY0IDE4LjM2NC0yLjU0OCAyLjU0OEwuMDQ0IDIuNTkyeiIvPjxwYXRoIGQ9Ik0wIDE4LjM2NEwxOC4zNjQgMGwyLjU0OCAyLjU0OEwyLjU0OCAyMC45MTJ6Ii8+PC9nPjwvc3ZnPg==);background-size:8px;width:8px;line-height:1;opacity:.75;border-radius:0}.choices[data-type*=select-multiple] .choices__button:focus,.choices[data-type*=select-multiple] .choices__button:hover,.choices[data-type*=text] .choices__button:focus,.choices[data-type*=text] .choices__button:hover{opacity:1}.choices__inner{display:inline-block;vertical-align:top;width:100%;background-color:#f9f9f9;padding:7.5px 7.5px 3.75px;border:1px solid #ddd;border-radius:2.5px;font-size:14px;min-height:44px;overflow:hidden}.is-focused .choices__inner,.is-open .choices__inner{border-color:#b7b7b7}.is-open .choices__inner{border-radius:2.5px 2.5px 0 0}.is-flipped.is-open .choices__inner{border-radius:0 0 2.5px 2.5px}.choices__list{margin:0;padding-left:0;list-style:none}.choices__list--single{display:inline-block;padding:4px 16px 4px 4px;width:100%}[dir=rtl] .choices__list--single{padding-right:4px;padding-left:16px}.choices__list--single .choices__item{width:100%}.choices__list--multiple{display:inline}.choices__list--multiple .choices__item{display:inline-block;vertical-align:middle;border-radius:20px;padding:4px 10px;font-size:12px;font-weight:500;margin-right:3.75px;margin-bottom:3.75px;background-color:#00bcd4;border:1px solid #00a5bb;color:#fff;word-break:break-all;box-sizing:border-box}.choices__list--multiple .choices__item[data-deletable]{padding-right:5px}[dir=rtl] .choices__list--multiple .choices__item{margin-right:0;margin-left:3.75px}.choices__list--multiple .choices__item.is-highlighted{background-color:#00a5bb;border:1px solid #008fa1}.is-disabled .choices__list--multiple .choices__item{background-color:#aaa;border:1px solid #919191}.choices__list--dropdown,.choices__list[aria-expanded]{visibility:hidden;z-index:1;position:absolute;width:100%;background-color:#fff;border:1px solid #ddd;top:100%;margin-top:-1px;border-bottom-left-radius:2.5px;border-bottom-right-radius:2.5px;overflow:hidden;word-break:break-all;will-change:visibility}.is-active.choices__list--dropdown,.is-active.choices__list[aria-expanded]{visibility:visible}.is-open .choices__list--dropdown,.is-open .choices__list[aria-expanded]{border-color:#b7b7b7}.is-flipped .choices__list--dropdown,.is-flipped .choices__list[aria-expanded]{top:auto;bottom:100%;margin-top:0;margin-bottom:-1px;border-radius:.25rem .25rem 0 0}.choices__list--dropdown .choices__list,.choices__list[aria-expanded] .choices__list{position:relative;max-height:300px;overflow:auto;-webkit-overflow-scrolling:touch;will-change:scroll-position}.choices__list--dropdown .choices__item,.choices__list[aria-expanded] .choices__item{position:relative;padding:10px;font-size:14px}[dir=rtl] .choices__list--dropdown .choices__item,[dir=rtl] .choices__list[aria-expanded] .choices__item{text-align:right}@media (min-width:640px){.choices__list--dropdown .choices__item--selectable,.choices__list[aria-expanded] .choices__item--selectable{padding-right:100px}.choices__list--dropdown .choices__item--selectable::after,.choices__list[aria-expanded] .choices__item--selectable::after{content:attr(data-select-text);font-size:12px;opacity:0;position:absolute;right:10px;top:50%;transform:translateY(-50%)}[dir=rtl] .choices__list--dropdown .choices__item--selectable,[dir=rtl] .choices__list[aria-expanded] .choices__item--selectable{text-align:right;padding-left:100px;padding-right:10px}[dir=rtl] .choices__list--dropdown .choices__item--selectable::after,[dir=rtl] .choices__list[aria-expanded] .choices__item--selectable::after{right:auto;left:10px}}.choices__list--dropdown .choices__item--selectable.is-highlighted,.choices__list[aria-expanded] .choices__item--selectable.is-highlighted{background-color:#f2f2f2}.choices__list--dropdown .choices__item--selectable.is-highlighted::after,.choices__list[aria-expanded] .choices__item--selectable.is-highlighted::after{opacity:.5}.choices__item{cursor:default}.choices__item--selectable{cursor:pointer}.choices__item--disabled{cursor:not-allowed;-webkit-user-select:none;user-select:none;opacity:.5}.choices__heading{font-weight:600;font-size:12px;padding:10px;border-bottom:1px solid #f7f7f7;color:gray}.choices__button{text-indent:-9999px;-webkit-appearance:none;appearance:none;border:0;background-color:transparent;background-repeat:no-repeat;background-position:center;cursor:pointer}.choices__button:focus,.choices__input:focus{outline:0}.choices__input{display:inline-block;vertical-align:baseline;background-color:#f9f9f9;font-size:14px;margin-bottom:5px;border:0;border-radius:0;max-width:100%;padding:4px 0 4px 2px}.choices__input::-webkit-search-cancel-button,.choices__input::-webkit-search-decoration,.choices__input::-webkit-search-results-button,.choices__input::-webkit-search-results-decoration{display:none}.choices__input::-ms-clear,.choices__input::-ms-reveal{display:none;width:0;height:0}[dir=rtl] .choices__input{padding-right:2px;padding-left:0}.choices__placeholder{opacity:.5}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/graphology-gexf/browser/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphology-gexf/browser/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Graphology Browser GEXF Endpoint
 * =================================
 *
 * Endpoint gathering both parser & writer for the browser.
 */
exports.parse = __webpack_require__(/*! ./parser.js */ "./node_modules/graphology-gexf/browser/parser.js");
exports.write = __webpack_require__(/*! ../common/writer.js */ "./node_modules/graphology-gexf/common/writer.js");


/***/ }),

/***/ "./node_modules/graphology-gexf/browser/parser.js":
/*!********************************************************!*\
  !*** ./node_modules/graphology-gexf/browser/parser.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology Browser GEXF Parser
 * ===============================
 *
 * Browser version of the graphology GEXF parser.
 */
var createParserFunction = __webpack_require__(/*! ../common/parser.js */ "./node_modules/graphology-gexf/common/parser.js");

module.exports = createParserFunction(DOMParser, Document);


/***/ }),

/***/ "./node_modules/graphology-gexf/common/helpers.js":
/*!********************************************************!*\
  !*** ./node_modules/graphology-gexf/common/helpers.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Graphology Common GEXF Helpers
 * ===============================
 *
 * Miscellaneous helpers used by both instance of the code.
 */

/**
 * Function used to cast a string value to the desired type.
 *
 * @param  {string} type - Value type.
 * @param  {string} type - String value.
 * @return {any}         - Parsed type.
 */
exports.cast = function (type, value) {
  switch (type) {
    case 'boolean':
      value = value === 'true';
      break;

    case 'integer':
    case 'long':
    case 'float':
    case 'double':
      value = +value;
      break;

    case 'liststring':
      value = value ? value.split('|') : [];
      break;

    default:
  }

  return value;
};

/**
 * Function deleting illegal characters from a potential tag name to avoid
 * generating invalid XML.
 *
 * @param  {string} type - Tag name.
 * @return {string}
 */
var SANITIZE_PATTERN = /["'<>&\s]/g;

exports.sanitizeTagName = function sanitizeTagName(tagName) {
  return tagName.replace(SANITIZE_PATTERN, '').trim();
};


/***/ }),

/***/ "./node_modules/graphology-gexf/common/parser.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphology-gexf/common/parser.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint no-self-compare: 0 */
/**
 * Graphology Browser GEXF Parser
 * ===============================
 *
 * Browser version of the graphology GEXF parser using DOMParser to function.
 */
var isGraphConstructor = __webpack_require__(/*! graphology-utils/is-graph-constructor */ "./node_modules/graphology-utils/is-graph-constructor.js");
var mergeEdge = (__webpack_require__(/*! graphology-utils/add-edge */ "./node_modules/graphology-utils/add-edge.js").mergeEdge);
var toMixed = __webpack_require__(/*! graphology-operators/to-mixed */ "./node_modules/graphology-operators/to-mixed.js");
var toMulti = __webpack_require__(/*! graphology-operators/to-multi */ "./node_modules/graphology-operators/to-multi.js");
var helpers = __webpack_require__(/*! ../common/helpers.js */ "./node_modules/graphology-gexf/common/helpers.js");

var cast = helpers.cast;

/**
 * Function checking whether the given value is a NaN.
 *
 * @param  {any} value - Value to test.
 * @return {boolean}
 */
function isReallyNaN(value) {
  return value !== value;
}

/**
 * Function used to convert a viz:color attribute into a CSS rgba? string.
 *
 * @param  {Node}   element - DOM element.
 * @return {string}
 */
function toRGBString(element) {
  var a = element.getAttribute('a'),
    r = element.getAttribute('r'),
    g = element.getAttribute('g'),
    b = element.getAttribute('b');

  return a
    ? 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'
    : 'rgb(' + r + ',' + g + ',' + b + ')';
}

/**
 * Function returning the first matching tag of the `viz` namespace matching
 * the desired tag name.
 *
 * @param  {Node}   element - Target DOM element.
 * @param  {string} name    - Tag name.
 * @return {Node}
 */
function getFirstMatchingVizTag(element, name) {
  var vizElement = element.getElementsByTagName('viz:' + name)[0];

  if (!vizElement) vizElement = element.getElementsByTagNameNS('viz', name)[0];

  if (!vizElement) vizElement = element.getElementsByTagName(name)[0];

  return vizElement;
}

/**
 * Function used to collect meta information.
 *
 * @param  {Array<Node>} elements - Target DOM element.
 * @return {object}
 */
function collectMeta(elements) {
  var meta = {},
    element,
    value;

  for (var i = 0, l = elements.length; i < l; i++) {
    element = elements[i];

    if (element.nodeName === '#text') continue;

    value = element.textContent.trim();

    if (value) meta[element.tagName.toLowerCase()] = element.textContent;
  }

  return meta;
}

/**
 * Function used to extract the model from the right elements.
 *
 * @param  {Array<Node>} elements - Target DOM elements.
 * @return {array}                - The model & default attributes.
 */
function extractModel(elements) {
  var model = {},
    defaults = {},
    element,
    defaultElement,
    id;

  for (var i = 0, l = elements.length; i < l; i++) {
    element = elements[i];
    id = element.getAttribute('id') || element.getAttribute('for');

    model[id] = {
      id: id,
      type: element.getAttribute('type') || 'string',
      title: !isReallyNaN(+id) ? element.getAttribute('title') || id : id
    };

    // Default?
    defaultElement = element.getElementsByTagName('default')[0];

    if (defaultElement)
      defaults[model[id].title] = cast(
        model[id].type,
        defaultElement.textContent
      );
  }

  return [model, defaults];
}

/**
 * Function used to collect an element's attributes.
 *
 * @param  {object} model    - Data model to use.
 * @param  {object} defaults - Default values.
 * @param  {Node}   element  - Target DOM element.
 * @return {object}          - The collected attributes.
 */
function collectAttributes(model, defaults, element) {
  var data = {},
    label = element.getAttribute('label'),
    weight = element.getAttribute('weight');

  if (label) data.label = label;

  if (weight) data.weight = +weight;

  var valueElements = element.getElementsByTagName('attvalue'),
    valueElement,
    id;

  for (var i = 0, l = valueElements.length; i < l; i++) {
    valueElement = valueElements[i];
    id = valueElement.getAttribute('id') || valueElement.getAttribute('for');

    data[model[id].title] = cast(
      model[id].type,
      valueElement.getAttribute('value')
    );
  }

  // Applying default values
  var k;

  for (k in defaults) {
    if (!(k in data)) data[k] = defaults[k];
  }

  // TODO: shortcut here to avoid viz when namespace is not set

  // Attempting to find viz namespace tags

  //-- 1) Color
  var vizElement = getFirstMatchingVizTag(element, 'color');

  if (vizElement) data.color = toRGBString(vizElement);

  //-- 2) Size
  vizElement = getFirstMatchingVizTag(element, 'size');

  if (vizElement) data.size = +vizElement.getAttribute('value');

  //-- 3) Position
  var x, y, z;

  vizElement = getFirstMatchingVizTag(element, 'position');

  if (vizElement) {
    x = vizElement.getAttribute('x');
    y = vizElement.getAttribute('y');
    z = vizElement.getAttribute('z');

    if (x) data.x = +x;
    if (y) data.y = +y;
    if (z) data.z = +z;
  }

  //-- 4) Shape
  vizElement = getFirstMatchingVizTag(element, 'shape');

  if (vizElement) data.shape = vizElement.getAttribute('value');

  //-- 5) Thickness
  vizElement = getFirstMatchingVizTag(element, 'thickness');

  if (vizElement) data.thickness = +vizElement.getAttribute('value');

  return data;
}

/**
 * Factory taking implementations of `DOMParser` & `Document` returning
 * the parser function.
 */
module.exports = function createParserFunction(DOMParser, Document) {
  /**
   * Function taking either a string or a document and returning a
   * graphology instance.
   *
   * @param {function}        Graph  - A graphology constructor.
   * @param {string|Document} source - The source to parse.
   * @param {object}          options - Parsing options.
   */

  // TODO: option to map the data to the attributes for customization, nodeModel, edgeModel, nodeReducer, edgeReducer
  // TODO: option to disable the model mapping heuristic
  return function parse(Graph, source, options) {
    options = options || {};

    var addMissingNodes = options.addMissingNodes === true;
    var mergeResult;

    var xmlDoc = source;

    var element, result, type, attributes, id, s, t, i, l;

    if (!isGraphConstructor(Graph))
      throw new Error('graphology-gexf/parser: invalid Graph constructor.');

    // If source is a string, we are going to parse it
    if (typeof source === 'string')
      xmlDoc = new DOMParser().parseFromString(source, 'application/xml');

    if (!(xmlDoc instanceof Document))
      throw new Error(
        'graphology-gexf/parser: source should either be a XML document or a string.'
      );

    // Finding useful elements
    var GRAPH_ELEMENT = xmlDoc.getElementsByTagName('graph')[0],
      META_ELEMENT = xmlDoc.getElementsByTagName('meta')[0],
      META_ELEMENTS = (META_ELEMENT && META_ELEMENT.childNodes) || [],
      NODE_ELEMENTS = xmlDoc.getElementsByTagName('node'),
      EDGE_ELEMENTS = xmlDoc.getElementsByTagName('edge'),
      MODEL_ELEMENTS = xmlDoc.getElementsByTagName('attributes'),
      NODE_MODEL_ELEMENTS = [],
      EDGE_MODEL_ELEMENTS = [];

    for (i = 0, l = MODEL_ELEMENTS.length; i < l; i++) {
      element = MODEL_ELEMENTS[i];

      if (element.getAttribute('class') === 'node')
        NODE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');
      else if (element.getAttribute('class') === 'edge')
        EDGE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');
    }

    // Information
    var DEFAULT_EDGE_TYPE =
      GRAPH_ELEMENT.getAttribute('defaultedgetype') || 'undirected';

    if (DEFAULT_EDGE_TYPE === 'mutual') DEFAULT_EDGE_TYPE = 'undirected';

    // Computing models
    result = extractModel(NODE_MODEL_ELEMENTS);

    var NODE_MODEL = result[0],
      NODE_DEFAULT_ATTRIBUTES = result[1];

    result = extractModel(EDGE_MODEL_ELEMENTS);

    var EDGE_MODEL = result[0],
      EDGE_DEFAULT_ATTRIBUTES = result[1];

    // Polling the first edge to guess the type of the edges
    var graphType = EDGE_ELEMENTS[0]
      ? EDGE_ELEMENTS[0].getAttribute('type') || DEFAULT_EDGE_TYPE
      : 'mixed';

    // Instantiating our graph
    var graph = new Graph({
      type: graphType
    });

    // Collecting meta
    var meta = collectMeta(META_ELEMENTS),
      lastModifiedDate =
        META_ELEMENT && META_ELEMENT.getAttribute('lastmodifieddate');

    graph.replaceAttributes(meta);

    if (lastModifiedDate)
      graph.setAttribute('lastModifiedDate', lastModifiedDate);

    // Adding nodes
    for (i = 0, l = NODE_ELEMENTS.length; i < l; i++) {
      element = NODE_ELEMENTS[i];

      graph.addNode(
        element.getAttribute('id'),
        collectAttributes(NODE_MODEL, NODE_DEFAULT_ATTRIBUTES, element)
      );
    }

    // Adding edges
    for (i = 0, l = EDGE_ELEMENTS.length; i < l; i++) {
      element = EDGE_ELEMENTS[i];

      id = element.getAttribute('id');
      type = element.getAttribute('type') || DEFAULT_EDGE_TYPE;
      s = element.getAttribute('source');
      t = element.getAttribute('target');
      attributes = collectAttributes(
        EDGE_MODEL,
        EDGE_DEFAULT_ATTRIBUTES,
        element
      );

      // If we encountered an edge with a different type, we upgrade the graph
      if (type !== graph.type && graph.type !== 'mixed') {
        graph = toMixed(graph);
      }

      // If we encountered twice the same edge, we upgrade the graph
      if (
        !graph.multi &&
        ((type === 'directed' && graph.hasDirectedEdge(s, t)) ||
          graph.hasUndirectedEdge(s, t))
      ) {
        graph = toMulti(graph);
      }

      mergeResult = mergeEdge(
        graph,
        type !== 'directed',
        id || null,
        s,
        t,
        attributes
      );

      if (!addMissingNodes && (mergeResult[2] || mergeResult[3])) {
        throw new Error(
          'graphology-gexf/parser: one of your gexf file edges points to an inexisting node. Set the parser `addMissingNodes` option to `true` if you do not care.'
        );
      }
    }

    return graph;
  };
};


/***/ }),

/***/ "./node_modules/graphology-gexf/common/writer.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphology-gexf/common/writer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint no-self-compare: 0 */
/**
 * Graphology Common GEXF Writer
 * ==============================
 *
 * GEXF writer working for both node.js & the browser.
 */
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js"),
  inferType = __webpack_require__(/*! graphology-utils/infer-type */ "./node_modules/graphology-utils/infer-type.js"),
  XMLWriter = __webpack_require__(/*! xml-writer */ "./node_modules/xml-writer/index.js"),
  sanitizeTagName = (__webpack_require__(/*! ./helpers.js */ "./node_modules/graphology-gexf/common/helpers.js").sanitizeTagName);

// TODO: handle object in color, position with object for viz

/**
 * Constants.
 */
var GEXF_NAMESPACE = 'http://www.gexf.net/1.2draft',
  GEXF_VIZ_NAMESPACE = 'http:///www.gexf.net/1.1draft/viz';

var VIZ_RESERVED_NAMES = new Set([
  'color',
  'size',
  'x',
  'y',
  'z',
  'shape',
  'thickness'
]);

var RGBA_TEST = /^\s*rgba?\s*\(/i,
  RGBA_MATCH =
    /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)\s*(?:,\s*([.0-9]*))?\)\s*$/;

/**
 * Function used to transform a CSS color into a RGBA object.
 *
 * @param  {string} value - Target value.
 * @return {object}
 */
function CSSColorToRGBA(value) {
  if (!value || typeof value !== 'string') return {};

  if (value[0] === '#') {
    value = value.slice(1);

    return value.length === 3
      ? {
          r: parseInt(value[0] + value[0], 16),
          g: parseInt(value[1] + value[1], 16),
          b: parseInt(value[2] + value[2], 16)
        }
      : {
          r: parseInt(value[0] + value[1], 16),
          g: parseInt(value[2] + value[3], 16),
          b: parseInt(value[4] + value[5], 16)
        };
  } else if (RGBA_TEST.test(value)) {
    var result = {};

    value = value.match(RGBA_MATCH);
    result.r = +value[1];
    result.g = +value[2];
    result.b = +value[3];

    if (value[4]) result.a = +value[4];

    return result;
  }

  return {};
}

/**
 * Function used to map an element's attributes to a standardized map of
 * GEXF expected properties (label, viz, attributes).
 *
 * @param  {string} type       - The element's type.
 * @param  {string} key        - The element's key.
 * @param  {object} attributes - The element's attributes.
 * @return {object}
 */
function DEFAULT_ELEMENT_FORMATTER(type, key, attributes) {
  var output = {},
    name;

  for (name in attributes) {
    if (name === 'label') {
      output.label = attributes.label;
    } else if (type === 'edge' && name === 'weight') {
      output.weight = attributes.weight;
    } else if (VIZ_RESERVED_NAMES.has(name)) {
      output.viz = output.viz || {};
      output.viz[name] = attributes[name];
    } else {
      output.attributes = output.attributes || {};
      output.attributes[name] = attributes[name];
    }
  }

  return output;
}

var DEFAULT_NODE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, 'node'),
  DEFAULT_EDGE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, 'edge');

/**
 * Function used to check whether the given integer is 32 bits or not.
 *
 * @param  {number} number - Target number.
 * @return {boolean}
 */
function is32BitInteger(number) {
  return number <= 0x7fffffff && number >= -0x7fffffff;
}

/**
 * Function used to check whether the given value is "empty".
 *
 * @param  {any} value - Target value.
 * @return {boolean}
 */
function isEmptyValue(value) {
  return (
    typeof value === 'undefined' ||
    value === null ||
    value === '' ||
    value !== value
  );
}

/**
 * Function used to detect a JavaScript's value type in the GEXF model.
 *
 * @param  {any}    value - Target value.
 * @return {string}
 */
function detectValueType(value) {
  if (isEmptyValue(value)) return 'empty';

  if (Array.isArray(value)) return 'liststring';

  if (typeof value === 'boolean') return 'boolean';

  if (typeof value === 'object') return 'string';

  // Numbers
  if (typeof value === 'number') {
    // Integer
    if (value === (value | 0)) {
      // Long (JavaScript integer can go up to 53 bit)?
      return is32BitInteger(value) ? 'integer' : 'long';
    }

    // JavaScript numbers are 64 bit float, hence the double
    return 'double';
  }

  return 'string';
}

/**
 * Function used to cast the given value into the given type.
 *
 * @param  {string} type  - Target type.
 * @param  {any}    value - Value to cast.
 * @return {string}
 */
function cast(type, value) {
  if (type === 'liststring' && Array.isArray(value)) return value.join('|');
  return '' + value;
}

/**
 * Function used to collect data from a graph's nodes.
 *
 * @param  {Graph}    graph   - Target graph.
 * @param  {function} format  - Function formatting the nodes attributes.
 * @return {array}
 */
function collectNodeData(graph, format) {
  var nodes = new Array(graph.order);
  var i = 0;

  graph.forEachNode(function (node, attr) {
    var data = format(node, attr);
    data.key = node;
    nodes[i++] = data;
  });

  return nodes;
}

/**
 * Function used to collect data from a graph's edges.
 *
 * @param  {Graph}    graph   - Target graph.
 * @param  {function} reducer - Function reducing the edges attributes.
 * @return {array}
 */
function collectEdgeData(graph, reducer) {
  var edges = new Array(graph.size);
  var i = 0;

  graph.forEachEdge(function (
    edge,
    attr,
    source,
    target,
    _sa,
    _ta,
    undirected
  ) {
    var data = reducer(edge, attr);
    data.key = edge;
    data.source = source;
    data.target = target;
    data.undirected = undirected;
    edges[i++] = data;
  });

  return edges;
}

/**
 * Function used to infer the model of the graph's nodes or edges.
 *
 * @param  {array} elements - The graph's relevant elements.
 * @return {array}
 */

// TODO: on large graph, we could also sample or let the user indicate the types
function inferModel(elements) {
  var model = {},
    attributes,
    type,
    k;

  // Testing every attributes
  for (var i = 0, l = elements.length; i < l; i++) {
    attributes = elements[i].attributes;

    if (!attributes) continue;

    for (k in attributes) {
      type = detectValueType(attributes[k]);

      if (type === 'empty') continue;

      if (!model[k]) model[k] = type;
      else {
        if (model[k] === 'integer' && type === 'long') model[k] = type;
        else if (model[k] !== type) model[k] = 'string';
      }
    }
  }

  // TODO: check default values
  return model;
}

/**
 * Function used to write a model.
 *
 * @param {XMLWriter} writer     - The writer to use.
 * @param {object}    model      - Model to write.
 * @param {string}    modelClass - Class of the model.
 */
function writeModel(writer, model, modelClass) {
  var name;

  if (!Object.keys(model).length) return;

  writer.startElement('attributes');
  writer.writeAttribute('class', modelClass);

  for (name in model) {
    writer.startElement('attribute');
    writer.writeAttribute('id', name);
    writer.writeAttribute('title', name);
    writer.writeAttribute('type', model[name]);
    writer.endElement();
  }

  writer.endElement();
}

function writeElements(writer, type, model, elements) {
  var emptyModel = !Object.keys(model).length,
    element,
    name,
    color,
    value,
    edgeType,
    attributes,
    weight,
    viz,
    k,
    i,
    l;

  writer.startElement(type + 's');

  for (i = 0, l = elements.length; i < l; i++) {
    element = elements[i];
    attributes = element.attributes;
    viz = element.viz;

    writer.startElement(type);
    writer.writeAttribute('id', element.key);

    if (type === 'edge') {
      edgeType = element.undirected ? 'undirected' : 'directed';

      if (edgeType !== writer.defaultEdgeType)
        writer.writeAttribute('type', edgeType);

      writer.writeAttribute('source', element.source);
      writer.writeAttribute('target', element.target);

      weight = element.weight;

      if (
        (typeof weight === 'number' && !isNaN(weight)) ||
        typeof weight === 'string'
      )
        writer.writeAttribute('weight', element.weight);
    }

    if (element.label) writer.writeAttribute('label', element.label);

    if (!emptyModel && attributes) {
      writer.startElement('attvalues');

      for (name in model) {
        if (name in attributes) {
          value = attributes[name];

          if (isEmptyValue(value)) continue;

          writer.startElement('attvalue');
          writer.writeAttribute('for', name);
          writer.writeAttribute('value', cast(model[name], value));
          writer.endElement();
        }
      }

      writer.endElement();
    }

    if (viz) {
      //-- 1) Color
      if (viz.color) {
        color = CSSColorToRGBA(viz.color);

        writer.startElementNS('viz', 'color');

        for (k in color) writer.writeAttribute(k, color[k]);

        writer.endElement();
      }

      //-- 2) Size
      if ('size' in viz) {
        writer.startElementNS('viz', 'size');
        writer.writeAttribute('value', viz.size);
        writer.endElement();
      }

      //-- 3) Position
      if ('x' in viz || 'y' in viz || 'z' in viz) {
        writer.startElementNS('viz', 'position');

        if ('x' in viz) writer.writeAttribute('x', viz.x);

        if ('y' in viz) writer.writeAttribute('y', viz.y);

        if ('z' in viz) writer.writeAttribute('z', viz.z);

        writer.endElement();
      }

      //-- 4) Shape
      if (viz.shape) {
        writer.startElementNS('viz', 'shape');
        writer.writeAttribute('value', viz.shape);
        writer.endElement();
      }

      //-- 5) Thickness
      if ('thickness' in viz) {
        writer.startElementNS('viz', 'thickness');
        writer.writeAttribute('value', viz.thickness);
        writer.endElement();
      }
    }

    writer.endElement();
  }

  writer.endElement();
}

/**
 * Defaults.
 */
var DEFAULTS = {
  encoding: 'UTF-8',
  pretty: true,
  formatNode: DEFAULT_NODE_FORMATTER,
  formatEdge: DEFAULT_EDGE_FORMATTER
};

/**
 * Function taking a graphology instance & outputting a gexf string.
 *
 * @param  {Graph}  graph        - Target graphology instance.
 * @param  {object} options      - Options:
 * @param  {string}   [encoding]   - Character encoding.
 * @param  {boolean}  [pretty]     - Whether to pretty print output.
 * @param  {function} [formatNode] - Function formatting nodes' output.
 * @param  {function} [formatEdge] - Function formatting edges' output.
 * @return {string}              - GEXF string.
 */
module.exports = function write(graph, options) {
  if (!isGraph(graph))
    throw new Error('graphology-gexf/writer: invalid graphology instance.');

  options = options || {};

  var indent = options.pretty === false ? false : '  ';

  var formatNode = options.formatNode || DEFAULTS.formatNode,
    formatEdge = options.formatEdge || DEFAULTS.formatEdge;

  var writer = new XMLWriter(indent);

  writer.startDocument('1.0', options.encoding || DEFAULTS.encoding);

  // Starting gexf
  writer.startElement('gexf');
  writer.writeAttribute('version', '1.2');
  writer.writeAttribute('xmlns', GEXF_NAMESPACE);
  writer.writeAttribute('xmlns:viz', GEXF_VIZ_NAMESPACE);

  // Processing meta
  writer.startElement('meta');
  var graphAttributes = graph.getAttributes();

  if (graphAttributes.lastModifiedDate)
    writer.writeAttribute('lastmodifieddate', graphAttributes.lastModifiedDate);

  var metaTagName;
  var graphAttribute;

  for (var k in graphAttributes) {
    if (k === 'lastModifiedDate') continue;

    metaTagName = sanitizeTagName(k);

    if (!metaTagName) continue;

    graphAttribute = graphAttributes[k];

    // NOTE: if the graph attribute is not a scalar, we do not bother writing
    // it as metadata in the gexf output. This means the writer/parser is not
    // idempotent, but we cannot do better because the gexf format does not
    // allow it, since it was not meant to handle complex values as graph
    // metadata anyway.
    if (
      typeof graphAttribute === 'string' ||
      typeof graphAttribute === 'number' ||
      typeof graphAttribute === 'boolean'
    ) {
      writer.writeElement(metaTagName, '' + graphAttribute);
    }
  }

  writer.endElement();
  writer.startElement('graph');

  var type = inferType(graph);

  writer.defaultEdgeType = type === 'mixed' ? 'directed' : type;

  writer.writeAttribute('defaultedgetype', writer.defaultEdgeType);

  // Processing model
  var nodes = collectNodeData(graph, formatNode),
    edges = collectEdgeData(graph, formatEdge);

  var nodeModel = inferModel(nodes);

  writeModel(writer, nodeModel, 'node');

  var edgeModel = inferModel(edges);

  writeModel(writer, edgeModel, 'edge');

  // Processing nodes
  writeElements(writer, 'node', nodeModel, nodes);

  // Processing edges
  writeElements(writer, 'edge', edgeModel, edges);

  return writer.toString();
};


/***/ }),

/***/ "./node_modules/graphology-layout-forceatlas2/webworker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/webworker.js ***!
  \*****************************************************************/
/***/ ((module) => {

/**
 * Graphology ForceAtlas2 Layout Webworker
 * ========================================
 *
 * Web worker able to run the layout in a separate thread.
 */
module.exports = function worker() {
  var NODES, EDGES;

  var moduleShim = {};

  (function () {
    /* eslint no-constant-condition: 0 */
/**
 * Graphology ForceAtlas2 Iteration
 * =================================
 *
 * Function used to perform a single iteration of the algorithm.
 */

/**
 * Matrices properties accessors.
 */
var NODE_X = 0;
var NODE_Y = 1;
var NODE_DX = 2;
var NODE_DY = 3;
var NODE_OLD_DX = 4;
var NODE_OLD_DY = 5;
var NODE_MASS = 6;
var NODE_CONVERGENCE = 7;
var NODE_SIZE = 8;
var NODE_FIXED = 9;

var EDGE_SOURCE = 0;
var EDGE_TARGET = 1;
var EDGE_WEIGHT = 2;

var REGION_NODE = 0;
var REGION_CENTER_X = 1;
var REGION_CENTER_Y = 2;
var REGION_SIZE = 3;
var REGION_NEXT_SIBLING = 4;
var REGION_FIRST_CHILD = 5;
var REGION_MASS = 6;
var REGION_MASS_CENTER_X = 7;
var REGION_MASS_CENTER_Y = 8;

var SUBDIVISION_ATTEMPTS = 3;

/**
 * Constants.
 */
var PPN = 10;
var PPE = 3;
var PPR = 9;

var MAX_FORCE = 10;

/**
 * Function used to perform a single interation of the algorithm.
 *
 * @param  {object}       options    - Layout options.
 * @param  {Float32Array} NodeMatrix - Node data.
 * @param  {Float32Array} EdgeMatrix - Edge data.
 * @return {object}                  - Some metadata.
 */
moduleShim.exports = function iterate(options, NodeMatrix, EdgeMatrix) {
  // Initializing variables
  var l, r, n, n1, n2, rn, e, w, g, s;

  var order = NodeMatrix.length,
    size = EdgeMatrix.length;

  var adjustSizes = options.adjustSizes;

  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;

  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;

  var RegionMatrix = [];

  // 1) Initializing layout data
  //-----------------------------

  // Resetting positions & computing max values
  for (n = 0; n < order; n += PPN) {
    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];
    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];
    NodeMatrix[n + NODE_DX] = 0;
    NodeMatrix[n + NODE_DY] = 0;
  }

  // If outbound attraction distribution, compensate
  if (options.outboundAttractionDistribution) {
    outboundAttCompensation = 0;
    for (n = 0; n < order; n += PPN) {
      outboundAttCompensation += NodeMatrix[n + NODE_MASS];
    }

    outboundAttCompensation /= order / PPN;
  }

  // 1.bis) Barnes-Hut computation
  //------------------------------

  if (options.barnesHutOptimize) {
    // Setting up
    var minX = Infinity,
      maxX = -Infinity,
      minY = Infinity,
      maxY = -Infinity,
      q,
      q2,
      subdivisionAttempts;

    // Computing min and max values
    for (n = 0; n < order; n += PPN) {
      minX = Math.min(minX, NodeMatrix[n + NODE_X]);
      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);
      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);
      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);
    }

    // squarify bounds, it's a quadtree
    var dx = maxX - minX,
      dy = maxY - minY;
    if (dx > dy) {
      minY -= (dx - dy) / 2;
      maxY = minY + dx;
    } else {
      minX -= (dy - dx) / 2;
      maxX = minX + dy;
    }

    // Build the Barnes Hut root region
    RegionMatrix[0 + REGION_NODE] = -1;
    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;
    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;
    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);
    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;
    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;
    RegionMatrix[0 + REGION_MASS] = 0;
    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;
    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;

    // Add each node in the tree
    l = 1;
    for (n = 0; n < order; n += PPN) {
      // Current region, starting with root
      r = 0;
      subdivisionAttempts = SUBDIVISION_ATTEMPTS;

      while (true) {
        // Are there sub-regions?

        // We look at first child index
        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {
          // There are sub-regions

          // We just iterate to find a "leaf" of the tree
          // that is an empty region or a region with a single node
          // (see next case)

          // Find the quadrant of n
          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {
            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
              // Top Left quarter
              q = RegionMatrix[r + REGION_FIRST_CHILD];
            } else {
              // Bottom Left quarter
              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
            }
          } else {
            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
              // Top Right quarter
              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
            } else {
              // Bottom Right quarter
              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
            }
          }

          // Update center of mass and mass (we only do it for non-leave regions)
          RegionMatrix[r + REGION_MASS_CENTER_X] =
            (RegionMatrix[r + REGION_MASS_CENTER_X] *
              RegionMatrix[r + REGION_MASS] +
              NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /
            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);

          RegionMatrix[r + REGION_MASS_CENTER_Y] =
            (RegionMatrix[r + REGION_MASS_CENTER_Y] *
              RegionMatrix[r + REGION_MASS] +
              NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /
            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);

          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];

          // Iterate on the right quadrant
          r = q;
          continue;
        } else {
          // There are no sub-regions: we are in a "leaf"

          // Is there a node in this leave?
          if (RegionMatrix[r + REGION_NODE] < 0) {
            // There is no node in region:
            // we record node n and go on
            RegionMatrix[r + REGION_NODE] = n;
            break;
          } else {
            // There is a node in this region

            // We will need to create sub-regions, stick the two
            // nodes (the old one r[0] and the new one n) in two
            // subregions. If they fall in the same quadrant,
            // we will iterate.

            // Create sub-regions
            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;
            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)

            // NOTE: we use screen coordinates
            // from Top Left to Bottom Right

            // Top Left sub-region
            g = RegionMatrix[r + REGION_FIRST_CHILD];

            RegionMatrix[g + REGION_NODE] = -1;
            RegionMatrix[g + REGION_CENTER_X] =
              RegionMatrix[r + REGION_CENTER_X] - w;
            RegionMatrix[g + REGION_CENTER_Y] =
              RegionMatrix[r + REGION_CENTER_Y] - w;
            RegionMatrix[g + REGION_SIZE] = w;
            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
            RegionMatrix[g + REGION_FIRST_CHILD] = -1;
            RegionMatrix[g + REGION_MASS] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

            // Bottom Left sub-region
            g += PPR;
            RegionMatrix[g + REGION_NODE] = -1;
            RegionMatrix[g + REGION_CENTER_X] =
              RegionMatrix[r + REGION_CENTER_X] - w;
            RegionMatrix[g + REGION_CENTER_Y] =
              RegionMatrix[r + REGION_CENTER_Y] + w;
            RegionMatrix[g + REGION_SIZE] = w;
            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
            RegionMatrix[g + REGION_FIRST_CHILD] = -1;
            RegionMatrix[g + REGION_MASS] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

            // Top Right sub-region
            g += PPR;
            RegionMatrix[g + REGION_NODE] = -1;
            RegionMatrix[g + REGION_CENTER_X] =
              RegionMatrix[r + REGION_CENTER_X] + w;
            RegionMatrix[g + REGION_CENTER_Y] =
              RegionMatrix[r + REGION_CENTER_Y] - w;
            RegionMatrix[g + REGION_SIZE] = w;
            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
            RegionMatrix[g + REGION_FIRST_CHILD] = -1;
            RegionMatrix[g + REGION_MASS] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

            // Bottom Right sub-region
            g += PPR;
            RegionMatrix[g + REGION_NODE] = -1;
            RegionMatrix[g + REGION_CENTER_X] =
              RegionMatrix[r + REGION_CENTER_X] + w;
            RegionMatrix[g + REGION_CENTER_Y] =
              RegionMatrix[r + REGION_CENTER_Y] + w;
            RegionMatrix[g + REGION_SIZE] = w;
            RegionMatrix[g + REGION_NEXT_SIBLING] =
              RegionMatrix[r + REGION_NEXT_SIBLING];
            RegionMatrix[g + REGION_FIRST_CHILD] = -1;
            RegionMatrix[g + REGION_MASS] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

            l += 4;

            // Now the goal is to find two different sub-regions
            // for the two nodes: the one previously recorded (r[0])
            // and the one we want to add (n)

            // Find the quadrant of the old node
            if (
              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] <
              RegionMatrix[r + REGION_CENTER_X]
            ) {
              if (
                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <
                RegionMatrix[r + REGION_CENTER_Y]
              ) {
                // Top Left quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD];
              } else {
                // Bottom Left quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
              }
            } else {
              if (
                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <
                RegionMatrix[r + REGION_CENTER_Y]
              ) {
                // Top Right quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
              } else {
                // Bottom Right quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
              }
            }

            // We remove r[0] from the region r, add its mass to r and record it in q
            RegionMatrix[r + REGION_MASS] =
              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];
            RegionMatrix[r + REGION_MASS_CENTER_X] =
              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];
            RegionMatrix[r + REGION_MASS_CENTER_Y] =
              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];

            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];
            RegionMatrix[r + REGION_NODE] = -1;

            // Find the quadrant of n
            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {
              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                // Top Left quarter
                q2 = RegionMatrix[r + REGION_FIRST_CHILD];
              } else {
                // Bottom Left quarter
                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
              }
            } else {
              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                // Top Right quarter
                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
              } else {
                // Bottom Right quarter
                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
              }
            }

            if (q === q2) {
              // If both nodes are in the same quadrant,
              // we have to try it again on this quadrant
              if (subdivisionAttempts--) {
                r = q;
                continue; // while
              } else {
                // we are out of precision here, and we cannot subdivide anymore
                // but we have to break the loop anyway
                subdivisionAttempts = SUBDIVISION_ATTEMPTS;
                break; // while
              }
            }

            // If both quadrants are different, we record n
            // in its quadrant
            RegionMatrix[q2 + REGION_NODE] = n;
            break;
          }
        }
      }
    }
  }

  // 2) Repulsion
  //--------------
  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient

  if (options.barnesHutOptimize) {
    coefficient = options.scalingRatio;

    // Applying repulsion through regions
    for (n = 0; n < order; n += PPN) {
      // Computing leaf quad nodes iteration

      r = 0; // Starting with root region
      while (true) {
        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {
          // The region has sub-regions

          // We run the Barnes Hut test to see if we are at the right distance
          distance =
            Math.pow(
              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],
              2
            ) +
            Math.pow(
              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],
              2
            );

          s = RegionMatrix[r + REGION_SIZE];

          if ((4 * s * s) / distance < thetaSquared) {
            // We treat the region as a single body, and we repulse

            xDist =
              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];
            yDist =
              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];

            if (adjustSizes === true) {
              //-- Linear Anti-collision Repulsion
              if (distance > 0) {
                factor =
                  (coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    RegionMatrix[r + REGION_MASS]) /
                  distance;

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              } else if (distance < 0) {
                factor =
                  (-coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    RegionMatrix[r + REGION_MASS]) /
                  Math.sqrt(distance);

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              }
            } else {
              //-- Linear Repulsion
              if (distance > 0) {
                factor =
                  (coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    RegionMatrix[r + REGION_MASS]) /
                  distance;

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              }
            }

            // When this is done, we iterate. We have to look at the next sibling.
            r = RegionMatrix[r + REGION_NEXT_SIBLING];
            if (r < 0) break; // No next sibling: we have finished the tree

            continue;
          } else {
            // The region is too close and we have to look at sub-regions
            r = RegionMatrix[r + REGION_FIRST_CHILD];
            continue;
          }
        } else {
          // The region has no sub-region
          // If there is a node r[0] and it is not n, then repulse
          rn = RegionMatrix[r + REGION_NODE];

          if (rn >= 0 && rn !== n) {
            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];
            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];

            distance = xDist * xDist + yDist * yDist;

            if (adjustSizes === true) {
              //-- Linear Anti-collision Repulsion
              if (distance > 0) {
                factor =
                  (coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    NodeMatrix[rn + NODE_MASS]) /
                  distance;

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              } else if (distance < 0) {
                factor =
                  (-coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    NodeMatrix[rn + NODE_MASS]) /
                  Math.sqrt(distance);

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              }
            } else {
              //-- Linear Repulsion
              if (distance > 0) {
                factor =
                  (coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    NodeMatrix[rn + NODE_MASS]) /
                  distance;

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              }
            }
          }

          // When this is done, we iterate. We have to look at the next sibling.
          r = RegionMatrix[r + REGION_NEXT_SIBLING];

          if (r < 0) break; // No next sibling: we have finished the tree

          continue;
        }
      }
    }
  } else {
    coefficient = options.scalingRatio;

    // Square iteration
    for (n1 = 0; n1 < order; n1 += PPN) {
      for (n2 = 0; n2 < n1; n2 += PPN) {
        // Common to both methods
        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];
        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];

        if (adjustSizes === true) {
          //-- Anticollision Linear Repulsion
          distance =
            Math.sqrt(xDist * xDist + yDist * yDist) -
            NodeMatrix[n1 + NODE_SIZE] -
            NodeMatrix[n2 + NODE_SIZE];

          if (distance > 0) {
            factor =
              (coefficient *
                NodeMatrix[n1 + NODE_MASS] *
                NodeMatrix[n2 + NODE_MASS]) /
              distance /
              distance;

            // Updating nodes' dx and dy
            NodeMatrix[n1 + NODE_DX] += xDist * factor;
            NodeMatrix[n1 + NODE_DY] += yDist * factor;

            NodeMatrix[n2 + NODE_DX] -= xDist * factor;
            NodeMatrix[n2 + NODE_DY] -= yDist * factor;
          } else if (distance < 0) {
            factor =
              100 *
              coefficient *
              NodeMatrix[n1 + NODE_MASS] *
              NodeMatrix[n2 + NODE_MASS];

            // Updating nodes' dx and dy
            NodeMatrix[n1 + NODE_DX] += xDist * factor;
            NodeMatrix[n1 + NODE_DY] += yDist * factor;

            NodeMatrix[n2 + NODE_DX] -= xDist * factor;
            NodeMatrix[n2 + NODE_DY] -= yDist * factor;
          }
        } else {
          //-- Linear Repulsion
          distance = Math.sqrt(xDist * xDist + yDist * yDist);

          if (distance > 0) {
            factor =
              (coefficient *
                NodeMatrix[n1 + NODE_MASS] *
                NodeMatrix[n2 + NODE_MASS]) /
              distance /
              distance;

            // Updating nodes' dx and dy
            NodeMatrix[n1 + NODE_DX] += xDist * factor;
            NodeMatrix[n1 + NODE_DY] += yDist * factor;

            NodeMatrix[n2 + NODE_DX] -= xDist * factor;
            NodeMatrix[n2 + NODE_DY] -= yDist * factor;
          }
        }
      }
    }
  }

  // 3) Gravity
  //------------
  g = options.gravity / options.scalingRatio;
  coefficient = options.scalingRatio;
  for (n = 0; n < order; n += PPN) {
    factor = 0;

    // Common to both methods
    xDist = NodeMatrix[n + NODE_X];
    yDist = NodeMatrix[n + NODE_Y];
    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));

    if (options.strongGravityMode) {
      //-- Strong gravity
      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;
    } else {
      //-- Linear Anti-collision Repulsion n
      if (distance > 0)
        factor = (coefficient * NodeMatrix[n + NODE_MASS] * g) / distance;
    }

    // Updating node's dx and dy
    NodeMatrix[n + NODE_DX] -= xDist * factor;
    NodeMatrix[n + NODE_DY] -= yDist * factor;
  }

  // 4) Attraction
  //---------------
  coefficient =
    1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);

  // TODO: simplify distance
  // TODO: coefficient is always used as -c --> optimize?
  for (e = 0; e < size; e += PPE) {
    n1 = EdgeMatrix[e + EDGE_SOURCE];
    n2 = EdgeMatrix[e + EDGE_TARGET];
    w = EdgeMatrix[e + EDGE_WEIGHT];

    // Edge weight influence
    ewc = Math.pow(w, options.edgeWeightInfluence);

    // Common measures
    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];
    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];

    // Applying attraction to nodes
    if (adjustSizes === true) {
      distance =
        Math.sqrt(xDist * xDist + yDist * yDist) -
        NodeMatrix[n1 + NODE_SIZE] -
        NodeMatrix[n2 + NODE_SIZE];

      if (options.linLogMode) {
        if (options.outboundAttractionDistribution) {
          //-- LinLog Degree Distributed Anti-collision Attraction
          if (distance > 0) {
            factor =
              (-coefficient * ewc * Math.log(1 + distance)) /
              distance /
              NodeMatrix[n1 + NODE_MASS];
          }
        } else {
          //-- LinLog Anti-collision Attraction
          if (distance > 0) {
            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;
          }
        }
      } else {
        if (options.outboundAttractionDistribution) {
          //-- Linear Degree Distributed Anti-collision Attraction
          if (distance > 0) {
            factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];
          }
        } else {
          //-- Linear Anti-collision Attraction
          if (distance > 0) {
            factor = -coefficient * ewc;
          }
        }
      }
    } else {
      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));

      if (options.linLogMode) {
        if (options.outboundAttractionDistribution) {
          //-- LinLog Degree Distributed Attraction
          if (distance > 0) {
            factor =
              (-coefficient * ewc * Math.log(1 + distance)) /
              distance /
              NodeMatrix[n1 + NODE_MASS];
          }
        } else {
          //-- LinLog Attraction
          if (distance > 0)
            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;
        }
      } else {
        if (options.outboundAttractionDistribution) {
          //-- Linear Attraction Mass Distributed
          // NOTE: Distance is set to 1 to override next condition
          distance = 1;
          factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];
        } else {
          //-- Linear Attraction
          // NOTE: Distance is set to 1 to override next condition
          distance = 1;
          factor = -coefficient * ewc;
        }
      }
    }

    // Updating nodes' dx and dy
    // TODO: if condition or factor = 1?
    if (distance > 0) {
      // Updating nodes' dx and dy
      NodeMatrix[n1 + NODE_DX] += xDist * factor;
      NodeMatrix[n1 + NODE_DY] += yDist * factor;

      NodeMatrix[n2 + NODE_DX] -= xDist * factor;
      NodeMatrix[n2 + NODE_DY] -= yDist * factor;
    }
  }

  // 5) Apply Forces
  //-----------------
  var force, swinging, traction, nodespeed, newX, newY;

  // MATH: sqrt and square distances
  if (adjustSizes === true) {
    for (n = 0; n < order; n += PPN) {
      if (NodeMatrix[n + NODE_FIXED] !== 1) {
        force = Math.sqrt(
          Math.pow(NodeMatrix[n + NODE_DX], 2) +
            Math.pow(NodeMatrix[n + NODE_DY], 2)
        );

        if (force > MAX_FORCE) {
          NodeMatrix[n + NODE_DX] =
            (NodeMatrix[n + NODE_DX] * MAX_FORCE) / force;
          NodeMatrix[n + NODE_DY] =
            (NodeMatrix[n + NODE_DY] * MAX_FORCE) / force;
        }

        swinging =
          NodeMatrix[n + NODE_MASS] *
          Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *
                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])
          );

        traction =
          Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *
                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])
          ) / 2;

        nodespeed = (0.1 * Math.log(1 + traction)) / (1 + Math.sqrt(swinging));

        // Updating node's positon
        newX =
          NodeMatrix[n + NODE_X] +
          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);
        NodeMatrix[n + NODE_X] = newX;

        newY =
          NodeMatrix[n + NODE_Y] +
          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);
        NodeMatrix[n + NODE_Y] = newY;
      }
    }
  } else {
    for (n = 0; n < order; n += PPN) {
      if (NodeMatrix[n + NODE_FIXED] !== 1) {
        swinging =
          NodeMatrix[n + NODE_MASS] *
          Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *
                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])
          );

        traction =
          Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *
                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])
          ) / 2;

        nodespeed =
          (NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction)) /
          (1 + Math.sqrt(swinging));

        // Updating node convergence
        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(
          1,
          Math.sqrt(
            (nodespeed *
              (Math.pow(NodeMatrix[n + NODE_DX], 2) +
                Math.pow(NodeMatrix[n + NODE_DY], 2))) /
              (1 + Math.sqrt(swinging))
          )
        );

        // Updating node's positon
        newX =
          NodeMatrix[n + NODE_X] +
          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);
        NodeMatrix[n + NODE_X] = newX;

        newY =
          NodeMatrix[n + NODE_Y] +
          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);
        NodeMatrix[n + NODE_Y] = newY;
      }
    }
  }

  // We return the information about the layout (no need to return the matrices)
  return {};
};

  })();

  var iterate = moduleShim.exports;

  self.addEventListener('message', function (event) {
    var data = event.data;

    NODES = new Float32Array(data.nodes);

    if (data.edges) EDGES = new Float32Array(data.edges);

    // Running the iteration
    iterate(data.settings, NODES, EDGES);

    // Sending result to supervisor
    self.postMessage(
      {
        nodes: NODES.buffer
      },
      [NODES.buffer]
    );
  });
};



/***/ }),

/***/ "./node_modules/graphology-layout-forceatlas2/worker.js":
/*!**************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/worker.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology ForceAtlas2 Layout Supervisor
 * =========================================
 *
 * Supervisor class able to spawn a web worker to run the FA2 layout in a
 * separate thread not to block UI with heavy synchronous computations.
 */
var workerFunction = __webpack_require__(/*! ./webworker.js */ "./node_modules/graphology-layout-forceatlas2/webworker.js");
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
var createEdgeWeightGetter =
  (__webpack_require__(/*! graphology-utils/getters */ "./node_modules/graphology-utils/getters.js").createEdgeWeightGetter);
var helpers = __webpack_require__(/*! ./helpers.js */ "./node_modules/graphology-layout-forceatlas2/helpers.js");

var DEFAULT_SETTINGS = __webpack_require__(/*! ./defaults.js */ "./node_modules/graphology-layout-forceatlas2/defaults.js");

/**
 * Class representing a FA2 layout run by a webworker.
 *
 * @constructor
 * @param  {Graph}         graph        - Target graph.
 * @param  {object|number} params       - Parameters:
 * @param  {object}          [settings] - Settings.
 */
function FA2LayoutSupervisor(graph, params) {
  params = params || {};

  // Validation
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout-forceatlas2/worker: the given graph is not a valid graphology instance.'
    );

  var getEdgeWeight = createEdgeWeightGetter(
    'getEdgeWeight' in params ? params.getEdgeWeight : 'weight'
  ).fromEntry;

  // Validating settings
  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings);
  var validationError = helpers.validateSettings(settings);

  if (validationError)
    throw new Error(
      'graphology-layout-forceatlas2/worker: ' + validationError.message
    );

  // Properties
  this.worker = null;
  this.graph = graph;
  this.settings = settings;
  this.getEdgeWeight = getEdgeWeight;
  this.matrices = null;
  this.running = false;
  this.killed = false;
  this.outputReducer =
    typeof params.outputReducer === 'function' ? params.outputReducer : null;

  // Binding listeners
  this.handleMessage = this.handleMessage.bind(this);

  var respawnFrame = undefined;
  var self = this;

  this.handleGraphUpdate = function () {
    if (self.worker) self.worker.terminate();

    if (respawnFrame) clearTimeout(respawnFrame);

    respawnFrame = setTimeout(function () {
      respawnFrame = undefined;
      self.spawnWorker();
    }, 0);
  };

  graph.on('nodeAdded', this.handleGraphUpdate);
  graph.on('edgeAdded', this.handleGraphUpdate);
  graph.on('nodeDropped', this.handleGraphUpdate);
  graph.on('edgeDropped', this.handleGraphUpdate);

  // Spawning worker
  this.spawnWorker();
}

FA2LayoutSupervisor.prototype.isRunning = function () {
  return this.running;
};

/**
 * Internal method used to spawn the web worker.
 */
FA2LayoutSupervisor.prototype.spawnWorker = function () {
  if (this.worker) this.worker.terminate();

  this.worker = helpers.createWorker(workerFunction);
  this.worker.addEventListener('message', this.handleMessage);

  if (this.running) {
    this.running = false;
    this.start();
  }
};

/**
 * Internal method used to handle the worker's messages.
 *
 * @param {object} event - Event to handle.
 */
FA2LayoutSupervisor.prototype.handleMessage = function (event) {
  if (!this.running) return;

  var matrix = new Float32Array(event.data.nodes);

  helpers.assignLayoutChanges(this.graph, matrix, this.outputReducer);
  if (this.outputReducer) helpers.readGraphPositions(this.graph, matrix);
  this.matrices.nodes = matrix;

  // Looping
  this.askForIterations();
};

/**
 * Internal method used to ask for iterations from the worker.
 *
 * @param  {boolean} withEdges - Should we send edges along?
 * @return {FA2LayoutSupervisor}
 */
FA2LayoutSupervisor.prototype.askForIterations = function (withEdges) {
  var matrices = this.matrices;

  var payload = {
    settings: this.settings,
    nodes: matrices.nodes.buffer
  };

  var buffers = [matrices.nodes.buffer];

  if (withEdges) {
    payload.edges = matrices.edges.buffer;
    buffers.push(matrices.edges.buffer);
  }

  this.worker.postMessage(payload, buffers);

  return this;
};

/**
 * Method used to start the layout.
 *
 * @return {FA2LayoutSupervisor}
 */
FA2LayoutSupervisor.prototype.start = function () {
  if (this.killed)
    throw new Error(
      'graphology-layout-forceatlas2/worker.start: layout was killed.'
    );

  if (this.running) return this;

  // Building matrices
  this.matrices = helpers.graphToByteArrays(this.graph, this.getEdgeWeight);

  this.running = true;
  this.askForIterations(true);

  return this;
};

/**
 * Method used to stop the layout.
 *
 * @return {FA2LayoutSupervisor}
 */
FA2LayoutSupervisor.prototype.stop = function () {
  this.running = false;

  return this;
};

/**
 * Method used to kill the layout.
 *
 * @return {FA2LayoutSupervisor}
 */
FA2LayoutSupervisor.prototype.kill = function () {
  if (this.killed) return this;

  this.running = false;
  this.killed = true;

  // Clearing memory
  this.matrices = null;

  // Terminating worker
  this.worker.terminate();

  // Unbinding listeners
  this.graph.removeListener('nodeAdded', this.handleGraphUpdate);
  this.graph.removeListener('edgeAdded', this.handleGraphUpdate);
  this.graph.removeListener('nodeDropped', this.handleGraphUpdate);
  this.graph.removeListener('edgeDropped', this.handleGraphUpdate);
};

/**
 * Exporting.
 */
module.exports = FA2LayoutSupervisor;


/***/ }),

/***/ "./node_modules/graphology-layout-noverlap/defaults.js":
/*!*************************************************************!*\
  !*** ./node_modules/graphology-layout-noverlap/defaults.js ***!
  \*************************************************************/
/***/ ((module) => {

/**
 * Graphology Noverlap Layout Default Settings
 * ============================================
 */
module.exports = {
  gridSize: 20,
  margin: 5,
  expansion: 1.1,
  ratio: 1.0,
  speed: 3
};


/***/ }),

/***/ "./node_modules/graphology-layout-noverlap/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/graphology-layout-noverlap/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Graphology Noverlap Helpers
 * ============================
 *
 * Miscellaneous helper functions.
 */

/**
 * Constants.
 */
var PPN = 3;

/**
 * Function used to validate the given settings.
 *
 * @param  {object}      settings - Settings to validate.
 * @return {object|null}
 */
exports.validateSettings = function (settings) {
  if (
    ('gridSize' in settings && typeof settings.gridSize !== 'number') ||
    settings.gridSize <= 0
  )
    return {message: 'the `gridSize` setting should be a positive number.'};

  if (
    ('margin' in settings && typeof settings.margin !== 'number') ||
    settings.margin < 0
  )
    return {
      message: 'the `margin` setting should be 0 or a positive number.'
    };

  if (
    ('expansion' in settings && typeof settings.expansion !== 'number') ||
    settings.expansion <= 0
  )
    return {message: 'the `expansion` setting should be a positive number.'};

  if (
    ('ratio' in settings && typeof settings.ratio !== 'number') ||
    settings.ratio <= 0
  )
    return {message: 'the `ratio` setting should be a positive number.'};

  if (
    ('speed' in settings && typeof settings.speed !== 'number') ||
    settings.speed <= 0
  )
    return {message: 'the `speed` setting should be a positive number.'};

  return null;
};

/**
 * Function generating a flat matrix for the given graph's nodes.
 *
 * @param  {Graph}        graph   - Target graph.
 * @param  {function}     reducer - Node reducer function.
 * @return {Float32Array}         - The node matrix.
 */
exports.graphToByteArray = function (graph, reducer) {
  var order = graph.order;

  var matrix = new Float32Array(order * PPN);

  var j = 0;

  graph.forEachNode(function (node, attr) {
    if (typeof reducer === 'function') attr = reducer(node, attr);

    matrix[j] = attr.x;
    matrix[j + 1] = attr.y;
    matrix[j + 2] = attr.size || 1;
    j += PPN;
  });

  return matrix;
};

/**
 * Function applying the layout back to the graph.
 *
 * @param {Graph}        graph      - Target graph.
 * @param {Float32Array} NodeMatrix - Node matrix.
 * @param {function}     reducer    - Reducing function.
 */
exports.assignLayoutChanges = function (graph, NodeMatrix, reducer) {
  var i = 0;

  graph.forEachNode(function (node) {
    var pos = {
      x: NodeMatrix[i],
      y: NodeMatrix[i + 1]
    };

    if (typeof reducer === 'function') pos = reducer(node, pos);

    graph.mergeNodeAttributes(node, pos);

    i += PPN;
  });
};

/**
 * Function collecting the layout positions.
 *
 * @param  {Graph}        graph      - Target graph.
 * @param  {Float32Array} NodeMatrix - Node matrix.
 * @param  {function}     reducer    - Reducing function.
 * @return {object}                  - Map to node positions.
 */
exports.collectLayoutChanges = function (graph, NodeMatrix, reducer) {
  var positions = {};

  var i = 0;

  graph.forEachNode(function (node) {
    var pos = {
      x: NodeMatrix[i],
      y: NodeMatrix[i + 1]
    };

    if (typeof reducer === 'function') pos = reducer(node, pos);

    positions[node] = pos;

    i += PPN;
  });

  return positions;
};

/**
 * Function returning a web worker from the given function.
 *
 * @param  {function}  fn - Function for the worker.
 * @return {DOMString}
 */
exports.createWorker = function createWorker(fn) {
  var xURL = window.URL || window.webkitURL;
  var code = fn.toString();
  var objectUrl = xURL.createObjectURL(
    new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'})
  );
  var worker = new Worker(objectUrl);
  xURL.revokeObjectURL(objectUrl);

  return worker;
};


/***/ }),

/***/ "./node_modules/graphology-layout-noverlap/webworker.js":
/*!**************************************************************!*\
  !*** ./node_modules/graphology-layout-noverlap/webworker.js ***!
  \**************************************************************/
/***/ ((module) => {

/**
 * Graphology Noverlap Layout Webworker
 * =====================================
 *
 * Web worker able to run the layout in a separate thread.
 */
module.exports = function worker() {
  var NODES;

  var moduleShim = {};

  (function () {
    /**
 * Graphology Noverlap Iteration
 * ==============================
 *
 * Function used to perform a single iteration of the algorithm.
 */

/**
 * Matrices properties accessors.
 */
var NODE_X = 0,
  NODE_Y = 1,
  NODE_SIZE = 2;

/**
 * Constants.
 */
var PPN = 3;

/**
 * Helpers.
 */
function hashPair(a, b) {
  return a + '§' + b;
}

function jitter() {
  return 0.01 * (0.5 - Math.random());
}

/**
 * Function used to perform a single interation of the algorithm.
 *
 * @param  {object}       options    - Layout options.
 * @param  {Float32Array} NodeMatrix - Node data.
 * @return {object}                  - Some metadata.
 */
moduleShim.exports = function iterate(options, NodeMatrix) {
  // Caching options
  var margin = options.margin;
  var ratio = options.ratio;
  var expansion = options.expansion;
  var gridSize = options.gridSize; // TODO: decrease grid size when few nodes?
  var speed = options.speed;

  // Generic iteration variables
  var i, j, x, y, l, size;
  var converged = true;

  var length = NodeMatrix.length;
  var order = (length / PPN) | 0;

  var deltaX = new Float32Array(order);
  var deltaY = new Float32Array(order);

  // Finding the extents of our space
  var xMin = Infinity;
  var yMin = Infinity;
  var xMax = -Infinity;
  var yMax = -Infinity;

  for (i = 0; i < length; i += PPN) {
    x = NodeMatrix[i + NODE_X];
    y = NodeMatrix[i + NODE_Y];
    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;

    xMin = Math.min(xMin, x - size);
    xMax = Math.max(xMax, x + size);
    yMin = Math.min(yMin, y - size);
    yMax = Math.max(yMax, y + size);
  }

  var width = xMax - xMin;
  var height = yMax - yMin;
  var xCenter = (xMin + xMax) / 2;
  var yCenter = (yMin + yMax) / 2;

  xMin = xCenter - (expansion * width) / 2;
  xMax = xCenter + (expansion * width) / 2;
  yMin = yCenter - (expansion * height) / 2;
  yMax = yCenter + (expansion * height) / 2;

  // Building grid
  var grid = new Array(gridSize * gridSize),
    gridLength = grid.length,
    c;

  for (c = 0; c < gridLength; c++) grid[c] = [];

  var nxMin, nxMax, nyMin, nyMax;
  var xMinBox, xMaxBox, yMinBox, yMaxBox;

  var col, row;

  for (i = 0; i < length; i += PPN) {
    x = NodeMatrix[i + NODE_X];
    y = NodeMatrix[i + NODE_Y];
    size = NodeMatrix[i + NODE_SIZE] * ratio + margin;

    nxMin = x - size;
    nxMax = x + size;
    nyMin = y - size;
    nyMax = y + size;

    xMinBox = Math.floor((gridSize * (nxMin - xMin)) / (xMax - xMin));
    xMaxBox = Math.floor((gridSize * (nxMax - xMin)) / (xMax - xMin));
    yMinBox = Math.floor((gridSize * (nyMin - yMin)) / (yMax - yMin));
    yMaxBox = Math.floor((gridSize * (nyMax - yMin)) / (yMax - yMin));

    for (col = xMinBox; col <= xMaxBox; col++) {
      for (row = yMinBox; row <= yMaxBox; row++) {
        grid[col * gridSize + row].push(i);
      }
    }
  }

  // Computing collisions
  var cell;

  var collisions = new Set();

  var n1, n2, x1, x2, y1, y2, s1, s2, h;

  var xDist, yDist, dist, collision;

  for (c = 0; c < gridLength; c++) {
    cell = grid[c];

    for (i = 0, l = cell.length; i < l; i++) {
      n1 = cell[i];

      x1 = NodeMatrix[n1 + NODE_X];
      y1 = NodeMatrix[n1 + NODE_Y];
      s1 = NodeMatrix[n1 + NODE_SIZE];

      for (j = i + 1; j < l; j++) {
        n2 = cell[j];
        h = hashPair(n1, n2);

        if (gridLength > 1 && collisions.has(h)) continue;

        if (gridLength > 1) collisions.add(h);

        x2 = NodeMatrix[n2 + NODE_X];
        y2 = NodeMatrix[n2 + NODE_Y];
        s2 = NodeMatrix[n2 + NODE_SIZE];

        xDist = x2 - x1;
        yDist = y2 - y1;
        dist = Math.sqrt(xDist * xDist + yDist * yDist);
        collision = dist < s1 * ratio + margin + (s2 * ratio + margin);

        if (collision) {
          converged = false;

          n2 = (n2 / PPN) | 0;

          if (dist > 0) {
            deltaX[n2] += (xDist / dist) * (1 + s1);
            deltaY[n2] += (yDist / dist) * (1 + s1);
          } else {
            // Nodes are on the exact same spot, we need to jitter a bit
            deltaX[n2] += width * jitter();
            deltaY[n2] += height * jitter();
          }
        }
      }
    }
  }

  for (i = 0, j = 0; i < length; i += PPN, j++) {
    NodeMatrix[i + NODE_X] += deltaX[j] * 0.1 * speed;
    NodeMatrix[i + NODE_Y] += deltaY[j] * 0.1 * speed;
  }

  return {converged: converged};
};

  })();

  var iterate = moduleShim.exports;

  self.addEventListener('message', function (event) {
    var data = event.data;

    NODES = new Float32Array(data.nodes);

    // Running the iteration
    var result = iterate(data.settings, NODES);

    // Sending result to supervisor
    self.postMessage(
      {
        result: result,
        nodes: NODES.buffer
      },
      [NODES.buffer]
    );
  });
};



/***/ }),

/***/ "./node_modules/graphology-layout-noverlap/worker.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphology-layout-noverlap/worker.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology Noverlap Layout Supervisor
 * ======================================
 *
 * Supervisor class able to spawn a web worker to run the Noverlap layout in a
 * separate thread not to block UI with heavy synchronous computations.
 */
var workerFunction = __webpack_require__(/*! ./webworker.js */ "./node_modules/graphology-layout-noverlap/webworker.js"),
  isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js"),
  helpers = __webpack_require__(/*! ./helpers.js */ "./node_modules/graphology-layout-noverlap/helpers.js");

var DEFAULT_SETTINGS = __webpack_require__(/*! ./defaults.js */ "./node_modules/graphology-layout-noverlap/defaults.js");

/**
 * Class representing a Noverlap layout run by a webworker.
 *
 * @constructor
 * @param  {Graph}         graph        - Target graph.
 * @param  {object|number} params       - Parameters:
 * @param  {object}          [settings] - Settings.
 */
function NoverlapLayoutSupervisor(graph, params) {
  params = params || {};

  // Validation
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout-noverlap/worker: the given graph is not a valid graphology instance.'
    );

  // Validating settings
  var settings = Object.assign({}, DEFAULT_SETTINGS, params.settings),
    validationError = helpers.validateSettings(settings);

  if (validationError)
    throw new Error(
      'graphology-layout-noverlap/worker: ' + validationError.message
    );

  // Properties
  this.worker = null;
  this.graph = graph;
  this.settings = settings;
  this.matrices = null;
  this.running = false;
  this.killed = false;

  this.inputReducer = params.inputReducer;
  this.outputReducer = params.outputReducer;

  this.callbacks = {
    onConverged:
      typeof params.onConverged === 'function' ? params.onConverged : null
  };

  // Binding listeners
  this.handleMessage = this.handleMessage.bind(this);

  var alreadyRespawning = false;
  var self = this;

  this.handleAddition = function () {
    if (alreadyRespawning) return;

    alreadyRespawning = true;

    self.spawnWorker();
    setTimeout(function () {
      alreadyRespawning = false;
    }, 0);
  };

  graph.on('nodeAdded', this.handleAddition);
  graph.on('edgeAdded', this.handleAddition);

  // Spawning worker
  this.spawnWorker();
}

NoverlapLayoutSupervisor.prototype.isRunning = function () {
  return this.running;
};

/**
 * Internal method used to spawn the web worker.
 */
NoverlapLayoutSupervisor.prototype.spawnWorker = function () {
  if (this.worker) this.worker.terminate();

  this.worker = helpers.createWorker(workerFunction);
  this.worker.addEventListener('message', this.handleMessage);

  if (this.running) {
    this.running = false;
    this.start();
  }
};

/**
 * Internal method used to handle the worker's messages.
 *
 * @param {object} event - Event to handle.
 */
NoverlapLayoutSupervisor.prototype.handleMessage = function (event) {
  if (!this.running) return;

  var matrix = new Float32Array(event.data.nodes);

  helpers.assignLayoutChanges(this.graph, matrix, this.outputReducer);
  this.matrices.nodes = matrix;

  if (event.data.result.converged) {
    if (this.callbacks.onConverged) this.callbacks.onConverged();

    this.stop();
    return;
  }

  // Looping
  this.askForIterations();
};

/**
 * Internal method used to ask for iterations from the worker.
 *
 * @return {NoverlapLayoutSupervisor}
 */
NoverlapLayoutSupervisor.prototype.askForIterations = function () {
  var matrices = this.matrices;

  var payload = {
    settings: this.settings,
    nodes: matrices.nodes.buffer
  };

  var buffers = [matrices.nodes.buffer];

  this.worker.postMessage(payload, buffers);

  return this;
};

/**
 * Method used to start the layout.
 *
 * @return {NoverlapLayoutSupervisor}
 */
NoverlapLayoutSupervisor.prototype.start = function () {
  if (this.killed)
    throw new Error(
      'graphology-layout-noverlap/worker.start: layout was killed.'
    );

  if (this.running) return this;

  // Building matrices
  this.matrices = {
    nodes: helpers.graphToByteArray(this.graph, this.inputReducer)
  };

  this.running = true;
  this.askForIterations();

  return this;
};

/**
 * Method used to stop the layout.
 *
 * @return {NoverlapLayoutSupervisor}
 */
NoverlapLayoutSupervisor.prototype.stop = function () {
  this.running = false;

  return this;
};

/**
 * Method used to kill the layout.
 *
 * @return {NoverlapLayoutSupervisor}
 */
NoverlapLayoutSupervisor.prototype.kill = function () {
  if (this.killed) return this;

  this.running = false;
  this.killed = true;

  // Clearing memory
  this.matrices = null;

  // Terminating worker
  this.worker.terminate();

  // Unbinding listeners
  this.graph.removeListener('nodeAdded', this.handleAddition);
  this.graph.removeListener('edgeAdded', this.handleAddition);
};

/**
 * Exporting.
 */
module.exports = NoverlapLayoutSupervisor;


/***/ }),

/***/ "./node_modules/graphology-layout/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/graphology-layout/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Graphology Layout Utilities
 * ============================
 *
 * Miscellaneous utility functions used by the library.
 */
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");

function isValidNumber(value) {
  return typeof value === 'number' && !isNaN(value);
}

var DEFAULT_DIMENSIONS = ['x', 'y'];

function collectLayout(graph, options) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout/utils.collectLayout: the given graph is not a valid graphology instance.'
    );

  options = options || {};

  var dimensions = options.dimensions;
  var exhaustive = options.exhaustive !== false;

  if (!dimensions) dimensions = DEFAULT_DIMENSIONS;

  var layout = {};
  var l = dimensions.length;

  graph.forEachNode(function (node, attr) {
    var validCoordinates = 0;
    var position = {};

    var i;

    for (i = 0; i < l; i++) {
      var d = dimensions[i];
      var v = attr[d];

      if (isValidNumber(v)) {
        position[d] = v;
        validCoordinates++;
      }
    }

    if (exhaustive) {
      if (validCoordinates === l) layout[node] = position;
    } else if (validCoordinates) {
      layout[node] = position;
    }
  });

  return layout;
}

function assignLayout(graph, layout, options) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout/utils.assignLayout: the given graph is not a valid graphology instance.'
    );

  options = options || {};
  var dimensions = options.dimensions || DEFAULT_DIMENSIONS;

  var l = dimensions.length;
  var d;

  graph.updateEachNodeAttributes(
    function (node, attr) {
      var position = layout[node];

      if (!position) return attr;

      for (var i = 0; i < l; i++) {
        d = dimensions[i];
        attr[d] = position[d];
      }

      return attr;
    },
    {
      attributes: dimensions
    }
  );
}

function collectLayoutAsFlatArray(graph, options) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout/utils.collectLayout: the given graph is not a valid graphology instance.'
    );

  options = options || {};

  var dimensions = options.dimensions;
  var ArrayClass = options.type || Float64Array;

  if (!dimensions) dimensions = DEFAULT_DIMENSIONS;

  var l = dimensions.length;

  var layout = new ArrayClass(graph.order * l);
  var offset = 0;

  graph.forEachNode(function (node, attr) {
    var i;

    for (i = 0; i < l; i++) {
      var d = dimensions[i];
      var v = attr[d];

      if (!isValidNumber(v)) v = 0;

      layout[offset++] = v;
    }
  });

  return layout;
}

function assignLayoutAsFlatArray(graph, layout, options) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout/utils.assignLayoutAsFlatArray: the given graph is not a valid graphology instance.'
    );

  options = options || {};

  var dimensions = options.dimensions;

  if (!dimensions) dimensions = DEFAULT_DIMENSIONS;

  var l = dimensions.length;

  if (layout.length !== graph.order * l)
    throw new Error(
      'graphology-layout/utils.assignLayoutAsFlatArray: given layout has an incorrect length wrt number of nodes & dimenions.'
    );

  var offset = 0;

  graph.updateEachNodeAttributes(
    function (node, attr) {
      for (var i = 0; i < l; i++) attr[dimensions[i]] = layout[offset++];

      return attr;
    },
    {attributes: dimensions}
  );
}

/**
 * Exports.
 */
exports.collectLayout = collectLayout;
exports.assignLayout = assignLayout;
exports.collectLayoutAsFlatArray = collectLayoutAsFlatArray;
exports.assignLayoutAsFlatArray = assignLayoutAsFlatArray;


/***/ }),

/***/ "./node_modules/graphology-operators/to-mixed.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphology-operators/to-mixed.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology Operators To Mixed Caster
 * =====================================
 *
 * Function used to cast any graph to a mixed one.
 */
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");

module.exports = function toMixed(graph) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-operators/to-mixed: expecting a valid graphology instance.'
    );

  return graph.copy({type: 'mixed'});
};


/***/ }),

/***/ "./node_modules/graphology-operators/to-multi.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphology-operators/to-multi.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology Operators To Multi Caster
 * =====================================
 *
 * Function used to cast any graph to a multi one.
 */
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");

module.exports = function toMulti(graph) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-operators/to-multi: expecting a valid graphology instance.'
    );

  return graph.copy({multi: true});
};


/***/ }),

/***/ "./node_modules/graphology-svg/components/edges/line.js":
/*!**************************************************************!*\
  !*** ./node_modules/graphology-svg/components/edges/line.js ***!
  \**************************************************************/
/***/ ((module) => {

/**
 * Graphology SVG Edge Line Component
 * ==================================
 *
 * Rendering nodes as plain lines.
 */
module.exports = function drawEdge(settings, data, sourceData, targetData) {
  return (
    '<line x1="' +
    sourceData.x +
    '" y1="' +
    sourceData.y +
    '" ' +
    'x2="' +
    targetData.x +
    '" y2="' +
    targetData.y +
    '" ' +
    'stroke="' +
    data.color +
    '" ' +
    'stroke-width="' +
    data.size +
    '" />'
  );
};


/***/ }),

/***/ "./node_modules/graphology-svg/components/nodeLabels/default.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graphology-svg/components/nodeLabels/default.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology SVG Node Label Component
 * ==================================
 *
 * Rendering node labels as simple text elements.
 */
var escape = (__webpack_require__(/*! ../../helpers.js */ "./node_modules/graphology-svg/helpers.js").escape);

module.exports = function drawLabel(settings, data) {
  return (
    '<text x="' +
    (data.x + data.size * 1.1) +
    '" ' +
    'y="' +
    (data.y + data.size / 4) +
    '" ' +
    'font-family="' +
    escape(settings.font || 'sans-serif') +
    '" ' +
    'font-size="' +
    data.size +
    '">' +
    escape(data.label) +
    '</text>'
  );
};


/***/ }),

/***/ "./node_modules/graphology-svg/components/nodes/circle.js":
/*!****************************************************************!*\
  !*** ./node_modules/graphology-svg/components/nodes/circle.js ***!
  \****************************************************************/
/***/ ((module) => {

/**
 * Graphology SVG Node Circle Component
 * ====================================
 *
 * Rendering nodes as plain SVG circles.
 */
module.exports = function drawNode(settings, data) {
  return (
    '<circle cx="' +
    data.x +
    '" ' +
    'cy="' +
    data.y +
    '" ' +
    'r="' +
    data.size +
    '" ' +
    'fill="' +
    data.color +
    '" />'
  );
};


/***/ }),

/***/ "./node_modules/graphology-svg/defaults.js":
/*!*************************************************!*\
  !*** ./node_modules/graphology-svg/defaults.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

var DEFAULTS = {
  margin: 20,
  width: 2048,
  height: 2048,
  nodes: {
    reducer: null,
    defaultColor: '#999'
  },
  edges: {
    reducer: null,
    defaultColor: '#ccc'
  }
};

exports.DEFAULTS = DEFAULTS;

exports.DEFAULT_NODE_REDUCER = function (settings, node, attr) {
  var reduced = {
    type: attr.type || 'circle',
    labelType: attr.labelType || 'default',
    label: attr.label || node,
    x: attr.x,
    y: attr.y,
    size: attr.size || 1,
    color: attr.color || settings.nodes.defaultColor
  };

  if (typeof reduced.x !== 'number' || typeof reduced.y !== 'number')
    throw new Error(
      'graphology-svg: the "' +
        node +
        '" node has no valid x or y position. Expecting a number.'
    );

  return reduced;
};

exports.DEFAULT_EDGE_REDUCER = function (settings, edge, attr) {
  var reduced = {
    type: attr.type || 'line',
    size: attr.size || 1,
    color: attr.color || settings.edges.defaultColor
  };

  return reduced;
};


/***/ }),

/***/ "./node_modules/graphology-svg/helpers.js":
/*!************************************************!*\
  !*** ./node_modules/graphology-svg/helpers.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Graphology SVG Helpers
 * ======================
 *
 * Micellaneous helper functions used throughout the library.
 */
var defaults = __webpack_require__(/*! ./defaults.js */ "./node_modules/graphology-svg/defaults.js");

// Taken from @jacomyma (graph-recipes)
function reduceNodes(graph, settings) {
  var width = settings.width,
    height = settings.height;

  var xBarycenter = 0,
    yBarycenter = 0,
    totalWeight = 0;

  var data = {};

  graph.forEachNode(function (node, attr) {
    // Applying user's reducing logic
    if (typeof settings.nodes.reducer === 'function')
      attr = settings.nodes.reducer(settings, node, attr);

    attr = defaults.DEFAULT_NODE_REDUCER(settings, node, attr);
    data[node] = attr;

    // Computing rescaling items
    xBarycenter += attr.size * attr.x;
    yBarycenter += attr.size * attr.y;
    totalWeight += attr.size;
  });

  xBarycenter /= totalWeight;
  yBarycenter /= totalWeight;

  var d, ratio, n;
  var dMax = -Infinity;

  var k;

  for (k in data) {
    n = data[k];
    d = Math.pow(n.x - xBarycenter, 2) + Math.pow(n.y - yBarycenter, 2);

    if (d > dMax) dMax = d;
  }

  ratio =
    (Math.min(width, height) - 2 * settings.margin) / (2 * Math.sqrt(dMax));

  for (k in data) {
    n = data[k];

    n.x = width / 2 + (n.x - xBarycenter) * ratio;
    n.y = height / 2 + (n.y - yBarycenter) * ratio;

    n.size *= ratio; // TODO: keep?
  }

  return data;
}

// Minimalist XML escaping function
var ESCAPE_PATTERN = /["'<>&]/g;

var ESCAPE_MAP = {
  '"': '&quot;',
  "'": '&apos;',
  '<': '&lt;',
  '>': '&gt;',
  '&': '&amp;'
};

function escapeReplacer(char) {
  return ESCAPE_MAP[char];
}

function escape(string) {
  return string.replace(ESCAPE_PATTERN, escapeReplacer);
}

exports.reduceNodes = reduceNodes;
exports.escape = escape;


/***/ }),

/***/ "./node_modules/graphology-svg/renderer.js":
/*!*************************************************!*\
  !*** ./node_modules/graphology-svg/renderer.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology SVG Renderer
 * =======================
 *
 * Function rendering the given graph.
 */
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
var helpers = __webpack_require__(/*! ./helpers.js */ "./node_modules/graphology-svg/helpers.js");
var defaults = __webpack_require__(/*! ./defaults.js */ "./node_modules/graphology-svg/defaults.js");

var components = {
  nodes: {
    circle: __webpack_require__(/*! ./components/nodes/circle.js */ "./node_modules/graphology-svg/components/nodes/circle.js")
  },
  edges: {
    line: __webpack_require__(/*! ./components/edges/line.js */ "./node_modules/graphology-svg/components/edges/line.js")
  },
  nodeLabels: {
    default: __webpack_require__(/*! ./components/nodeLabels/default.js */ "./node_modules/graphology-svg/components/nodeLabels/default.js")
  }
};

function renderer(graph, settings) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-svg/renderer: expecting a valid graphology instance.'
    );

  // Reducing nodes
  var nodeData = helpers.reduceNodes(graph, settings);

  // Drawing edges
  var edgesStrings = [];
  graph.forEachEdge(function (edge, attr, source, target) {
    // Reducing edge
    if (typeof settings.edges.reducer === 'function')
      attr = settings.edges.reducer(settings, edge, attr);

    attr = defaults.DEFAULT_EDGE_REDUCER(settings, edge, attr);

    edgesStrings.push(
      components.edges[attr.type](
        settings,
        attr,
        nodeData[source],
        nodeData[target]
      )
    );
  });

  // Drawing nodes and labels
  // TODO: should we draw in size order to avoid weird overlaps? Should we run noverlap?
  var nodesStrings = [];
  var nodeLabelsStrings = [];
  var k;
  for (k in nodeData) {
    nodesStrings.push(
      components.nodes[nodeData[k].type](settings, nodeData[k])
    );
    nodeLabelsStrings.push(
      components.nodeLabels[nodeData[k].labelType](settings, nodeData[k])
    );
  }

  return (
    '<?xml version="1.0" encoding="utf-8"?>' +
    '<svg width="' +
    settings.width +
    '" height=" ' +
    settings.height +
    '" ' +
    'viewBox="0 0 ' +
    settings.width +
    ' ' +
    settings.height +
    '" ' +
    'version="1.1" ' +
    'xmlns="http://www.w3.org/2000/svg">' +
    '<g>' +
    edgesStrings.join('') +
    '</g>' +
    '<g>' +
    nodesStrings.join('') +
    '</g>' +
    '<g>' +
    nodeLabelsStrings.join('') +
    '</g>' +
    '</svg>'
  );
}

module.exports = renderer;


/***/ }),

/***/ "./node_modules/graphology-utils/add-edge.js":
/*!***************************************************!*\
  !*** ./node_modules/graphology-utils/add-edge.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Graphology Edge Adders
 * =======================
 *
 * Generic edge addition functions that can be used to avoid nasty repetitive
 * conditions.
 */
exports.addEdge = function addEdge(
  graph,
  undirected,
  key,
  source,
  target,
  attributes
) {
  if (undirected) {
    if (key === null || key === undefined)
      return graph.addUndirectedEdge(source, target, attributes);
    else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);
  } else {
    if (key === null || key === undefined)
      return graph.addDirectedEdge(source, target, attributes);
    else return graph.addDirectedEdgeWithKey(key, source, target, attributes);
  }
};

exports.copyEdge = function copyEdge(
  graph,
  undirected,
  key,
  source,
  target,
  attributes
) {
  attributes = Object.assign({}, attributes);

  if (undirected) {
    if (key === null || key === undefined)
      return graph.addUndirectedEdge(source, target, attributes);
    else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);
  } else {
    if (key === null || key === undefined)
      return graph.addDirectedEdge(source, target, attributes);
    else return graph.addDirectedEdgeWithKey(key, source, target, attributes);
  }
};

exports.mergeEdge = function mergeEdge(
  graph,
  undirected,
  key,
  source,
  target,
  attributes
) {
  if (undirected) {
    if (key === null || key === undefined)
      return graph.mergeUndirectedEdge(source, target, attributes);
    else
      return graph.mergeUndirectedEdgeWithKey(key, source, target, attributes);
  } else {
    if (key === null || key === undefined)
      return graph.mergeDirectedEdge(source, target, attributes);
    else return graph.mergeDirectedEdgeWithKey(key, source, target, attributes);
  }
};

exports.updateEdge = function updateEdge(
  graph,
  undirected,
  key,
  source,
  target,
  updater
) {
  if (undirected) {
    if (key === null || key === undefined)
      return graph.updateUndirectedEdge(source, target, updater);
    else return graph.updateUndirectedEdgeWithKey(key, source, target, updater);
  } else {
    if (key === null || key === undefined)
      return graph.updateDirectedEdge(source, target, updater);
    else return graph.updateDirectedEdgeWithKey(key, source, target, updater);
  }
};


/***/ }),

/***/ "./node_modules/graphology-utils/infer-type.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphology-utils/infer-type.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology inferType
 * =====================
 *
 * Useful function used to "guess" the real type of the given Graph using
 * introspection.
 */
var isGraph = __webpack_require__(/*! ./is-graph.js */ "./node_modules/graphology-utils/is-graph.js");

/**
 * Returning the inferred type of the given graph.
 *
 * @param  {Graph}   graph - Target graph.
 * @return {boolean}
 */
module.exports = function inferType(graph) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-utils/infer-type: expecting a valid graphology instance.'
    );

  var declaredType = graph.type;

  if (declaredType !== 'mixed') return declaredType;

  if (
    (graph.directedSize === 0 && graph.undirectedSize === 0) ||
    (graph.directedSize > 0 && graph.undirectedSize > 0)
  )
    return 'mixed';

  if (graph.directedSize > 0) return 'directed';

  return 'undirected';
};


/***/ }),

/***/ "./node_modules/graphology-utils/is-graph-constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphology-utils/is-graph-constructor.js ***!
  \***************************************************************/
/***/ ((module) => {

/**
 * Graphology isGraphConstructor
 * ==============================
 *
 * Very simple function aiming at ensuring the given variable is a
 * graphology constructor.
 */

/**
 * Checking the value is a graphology constructor.
 *
 * @param  {any}     value - Target value.
 * @return {boolean}
 */
module.exports = function isGraphConstructor(value) {
  return (
    value !== null &&
    typeof value === 'function' &&
    typeof value.prototype === 'object' &&
    typeof value.prototype.addUndirectedEdgeWithKey === 'function' &&
    typeof value.prototype.dropNode === 'function'
  );
};


/***/ }),

/***/ "./node_modules/mnemonist/fixed-reverse-heap.js":
/*!******************************************************!*\
  !*** ./node_modules/mnemonist/fixed-reverse-heap.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Mnemonist Fixed Reverse Heap
 * =============================
 *
 * Static heap implementation with fixed capacity. It's a "reverse" heap
 * because it stores the elements in reverse so we can replace the worst
 * item in logarithmic time. As such, one cannot pop this heap but can only
 * consume it at the end. This structure is very efficient when trying to
 * find the n smallest/largest items from a larger query (k nearest neigbors
 * for instance).
 */
var comparators = __webpack_require__(/*! ./utils/comparators.js */ "./node_modules/mnemonist/utils/comparators.js"),
    Heap = __webpack_require__(/*! ./heap.js */ "./node_modules/mnemonist/heap.js");

var DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,
    reverseComparator = comparators.reverseComparator;

/**
 * Helper functions.
 */

/**
 * Function used to sift up.
 *
 * @param {function} compare - Comparison function.
 * @param {array}    heap    - Array storing the heap's data.
 * @param {number}   size    - Heap's true size.
 * @param {number}   i       - Index.
 */
function siftUp(compare, heap, size, i) {
  var endIndex = size,
      startIndex = i,
      item = heap[i],
      childIndex = 2 * i + 1,
      rightIndex;

  while (childIndex < endIndex) {
    rightIndex = childIndex + 1;

    if (
      rightIndex < endIndex &&
      compare(heap[childIndex], heap[rightIndex]) >= 0
    ) {
      childIndex = rightIndex;
    }

    heap[i] = heap[childIndex];
    i = childIndex;
    childIndex = 2 * i + 1;
  }

  heap[i] = item;
  Heap.siftDown(compare, heap, startIndex, i);
}

/**
 * Fully consumes the given heap.
 *
 * @param  {function} ArrayClass - Array class to use.
 * @param  {function} compare    - Comparison function.
 * @param  {array}    heap       - Array storing the heap's data.
 * @param  {number}   size       - True size of the heap.
 * @return {array}
 */
function consume(ArrayClass, compare, heap, size) {
  var l = size,
      i = l;

  var array = new ArrayClass(size),
      lastItem,
      item;

  while (i > 0) {
    lastItem = heap[--i];

    if (i !== 0) {
      item = heap[0];
      heap[0] = lastItem;
      siftUp(compare, heap, --size, 0);
      lastItem = item;
    }

    array[i] = lastItem;
  }

  return array;
}

/**
 * Binary Minimum FixedReverseHeap.
 *
 * @constructor
 * @param {function} ArrayClass - The class of array to use.
 * @param {function} comparator - Comparator function.
 * @param {number}   capacity   - Maximum number of items to keep.
 */
function FixedReverseHeap(ArrayClass, comparator, capacity) {

  // Comparator can be omitted
  if (arguments.length === 2) {
    capacity = comparator;
    comparator = null;
  }

  this.ArrayClass = ArrayClass;
  this.capacity = capacity;

  this.items = new ArrayClass(capacity);
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof capacity !== 'number' && capacity <= 0)
    throw new Error('mnemonist/FixedReverseHeap.constructor: capacity should be a number > 0.');

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/FixedReverseHeap.constructor: given comparator should be a function.');

  this.comparator = reverseComparator(this.comparator);
}

/**
 * Method used to clear the heap.
 *
 * @return {undefined}
 */
FixedReverseHeap.prototype.clear = function() {

  // Properties
  this.size = 0;
};

/**
 * Method used to push an item into the heap.
 *
 * @param  {any}    item - Item to push.
 * @return {number}
 */
FixedReverseHeap.prototype.push = function(item) {

  // Still some place
  if (this.size < this.capacity) {
    this.items[this.size] = item;
    Heap.siftDown(this.comparator, this.items, 0, this.size);
    this.size++;
  }

  // Heap is full, we need to replace worst item
  else {

    if (this.comparator(item, this.items[0]) > 0)
      Heap.replace(this.comparator, this.items, item);
  }

  return this.size;
};

/**
 * Method used to peek the worst item in the heap.
 *
 * @return {any}
 */
FixedReverseHeap.prototype.peek = function() {
  return this.items[0];
};

/**
 * Method used to consume the heap fully and return its items as a sorted array.
 *
 * @return {array}
 */
FixedReverseHeap.prototype.consume = function() {
  var items = consume(this.ArrayClass, this.comparator, this.items, this.size);
  this.size = 0;

  return items;
};

/**
 * Method used to convert the heap to an array. Note that it basically clone
 * the heap and consumes it completely. This is hardly performant.
 *
 * @return {array}
 */
FixedReverseHeap.prototype.toArray = function() {
  return consume(this.ArrayClass, this.comparator, this.items.slice(0, this.size), this.size);
};

/**
 * Convenience known methods.
 */
FixedReverseHeap.prototype.inspect = function() {
  var proxy = this.toArray();

  // Trick so that node displays the name of the constructor
  Object.defineProperty(proxy, 'constructor', {
    value: FixedReverseHeap,
    enumerable: false
  });

  return proxy;
};

if (typeof Symbol !== 'undefined')
  FixedReverseHeap.prototype[Symbol.for('nodejs.util.inspect.custom')] = FixedReverseHeap.prototype.inspect;

/**
 * Exporting.
 */
module.exports = FixedReverseHeap;


/***/ }),

/***/ "./node_modules/mnemonist/heap.js":
/*!****************************************!*\
  !*** ./node_modules/mnemonist/heap.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Mnemonist Binary Heap
 * ======================
 *
 * Binary heap implementation.
 */
var forEach = __webpack_require__(/*! obliterator/foreach */ "./node_modules/obliterator/foreach.js"),
    comparators = __webpack_require__(/*! ./utils/comparators.js */ "./node_modules/mnemonist/utils/comparators.js"),
    iterables = __webpack_require__(/*! ./utils/iterables.js */ "./node_modules/mnemonist/utils/iterables.js");

var DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,
    reverseComparator = comparators.reverseComparator;

/**
 * Heap helper functions.
 */

/**
 * Function used to sift down.
 *
 * @param {function} compare    - Comparison function.
 * @param {array}    heap       - Array storing the heap's data.
 * @param {number}   startIndex - Starting index.
 * @param {number}   i          - Index.
 */
function siftDown(compare, heap, startIndex, i) {
  var item = heap[i],
      parentIndex,
      parent;

  while (i > startIndex) {
    parentIndex = (i - 1) >> 1;
    parent = heap[parentIndex];

    if (compare(item, parent) < 0) {
      heap[i] = parent;
      i = parentIndex;
      continue;
    }

    break;
  }

  heap[i] = item;
}

/**
 * Function used to sift up.
 *
 * @param {function} compare - Comparison function.
 * @param {array}    heap    - Array storing the heap's data.
 * @param {number}   i       - Index.
 */
function siftUp(compare, heap, i) {
  var endIndex = heap.length,
      startIndex = i,
      item = heap[i],
      childIndex = 2 * i + 1,
      rightIndex;

  while (childIndex < endIndex) {
    rightIndex = childIndex + 1;

    if (
      rightIndex < endIndex &&
      compare(heap[childIndex], heap[rightIndex]) >= 0
    ) {
      childIndex = rightIndex;
    }

    heap[i] = heap[childIndex];
    i = childIndex;
    childIndex = 2 * i + 1;
  }

  heap[i] = item;
  siftDown(compare, heap, startIndex, i);
}

/**
 * Function used to push an item into a heap represented by a raw array.
 *
 * @param {function} compare - Comparison function.
 * @param {array}    heap    - Array storing the heap's data.
 * @param {any}      item    - Item to push.
 */
function push(compare, heap, item) {
  heap.push(item);
  siftDown(compare, heap, 0, heap.length - 1);
}

/**
 * Function used to pop an item from a heap represented by a raw array.
 *
 * @param  {function} compare - Comparison function.
 * @param  {array}    heap    - Array storing the heap's data.
 * @return {any}
 */
function pop(compare, heap) {
  var lastItem = heap.pop();

  if (heap.length !== 0) {
    var item = heap[0];
    heap[0] = lastItem;
    siftUp(compare, heap, 0);

    return item;
  }

  return lastItem;
}

/**
 * Function used to pop the heap then push a new value into it, thus "replacing"
 * it.
 *
 * @param  {function} compare - Comparison function.
 * @param  {array}    heap    - Array storing the heap's data.
 * @param  {any}      item    - The item to push.
 * @return {any}
 */
function replace(compare, heap, item) {
  if (heap.length === 0)
    throw new Error('mnemonist/heap.replace: cannot pop an empty heap.');

  var popped = heap[0];
  heap[0] = item;
  siftUp(compare, heap, 0);

  return popped;
}

/**
 * Function used to push an item in the heap then pop the heap and return the
 * popped value.
 *
 * @param  {function} compare - Comparison function.
 * @param  {array}    heap    - Array storing the heap's data.
 * @param  {any}      item    - The item to push.
 * @return {any}
 */
function pushpop(compare, heap, item) {
  var tmp;

  if (heap.length !== 0 && compare(heap[0], item) < 0) {
    tmp = heap[0];
    heap[0] = item;
    item = tmp;
    siftUp(compare, heap, 0);
  }

  return item;
}

/**
 * Converts and array into an abstract heap in linear time.
 *
 * @param {function} compare - Comparison function.
 * @param {array}    array   - Target array.
 */
function heapify(compare, array) {
  var n = array.length,
      l = n >> 1,
      i = l;

  while (--i >= 0)
    siftUp(compare, array, i);
}

/**
 * Fully consumes the given heap.
 *
 * @param  {function} compare - Comparison function.
 * @param  {array}    heap    - Array storing the heap's data.
 * @return {array}
 */
function consume(compare, heap) {
  var l = heap.length,
      i = 0;

  var array = new Array(l);

  while (i < l)
    array[i++] = pop(compare, heap);

  return array;
}

/**
 * Function used to retrieve the n smallest items from the given iterable.
 *
 * @param {function} compare  - Comparison function.
 * @param {number}   n        - Number of top items to retrieve.
 * @param {any}      iterable - Arbitrary iterable.
 * @param {array}
 */
function nsmallest(compare, n, iterable) {
  if (arguments.length === 2) {
    iterable = n;
    n = compare;
    compare = DEFAULT_COMPARATOR;
  }

  var reverseCompare = reverseComparator(compare);

  var i, l, v;

  var min = Infinity;

  var result;

  // If n is equal to 1, it's just a matter of finding the minimum
  if (n === 1) {
    if (iterables.isArrayLike(iterable)) {
      for (i = 0, l = iterable.length; i < l; i++) {
        v = iterable[i];

        if (min === Infinity || compare(v, min) < 0)
          min = v;
      }

      result = new iterable.constructor(1);
      result[0] = min;

      return result;
    }

    forEach(iterable, function(value) {
      if (min === Infinity || compare(value, min) < 0)
        min = value;
    });

    return [min];
  }

  if (iterables.isArrayLike(iterable)) {

    // If n > iterable length, we just clone and sort
    if (n >= iterable.length)
      return iterable.slice().sort(compare);

    result = iterable.slice(0, n);
    heapify(reverseCompare, result);

    for (i = n, l = iterable.length; i < l; i++)
      if (reverseCompare(iterable[i], result[0]) > 0)
        replace(reverseCompare, result, iterable[i]);

    // NOTE: if n is over some number, it becomes faster to consume the heap
    return result.sort(compare);
  }

  // Correct for size
  var size = iterables.guessLength(iterable);

  if (size !== null && size < n)
    n = size;

  result = new Array(n);
  i = 0;

  forEach(iterable, function(value) {
    if (i < n) {
      result[i] = value;
    }
    else {
      if (i === n)
        heapify(reverseCompare, result);

      if (reverseCompare(value, result[0]) > 0)
        replace(reverseCompare, result, value);
    }

    i++;
  });

  if (result.length > i)
    result.length = i;

  // NOTE: if n is over some number, it becomes faster to consume the heap
  return result.sort(compare);
}

/**
 * Function used to retrieve the n largest items from the given iterable.
 *
 * @param {function} compare  - Comparison function.
 * @param {number}   n        - Number of top items to retrieve.
 * @param {any}      iterable - Arbitrary iterable.
 * @param {array}
 */
function nlargest(compare, n, iterable) {
  if (arguments.length === 2) {
    iterable = n;
    n = compare;
    compare = DEFAULT_COMPARATOR;
  }

  var reverseCompare = reverseComparator(compare);

  var i, l, v;

  var max = -Infinity;

  var result;

  // If n is equal to 1, it's just a matter of finding the maximum
  if (n === 1) {
    if (iterables.isArrayLike(iterable)) {
      for (i = 0, l = iterable.length; i < l; i++) {
        v = iterable[i];

        if (max === -Infinity || compare(v, max) > 0)
          max = v;
      }

      result = new iterable.constructor(1);
      result[0] = max;

      return result;
    }

    forEach(iterable, function(value) {
      if (max === -Infinity || compare(value, max) > 0)
        max = value;
    });

    return [max];
  }

  if (iterables.isArrayLike(iterable)) {

    // If n > iterable length, we just clone and sort
    if (n >= iterable.length)
      return iterable.slice().sort(reverseCompare);

    result = iterable.slice(0, n);
    heapify(compare, result);

    for (i = n, l = iterable.length; i < l; i++)
      if (compare(iterable[i], result[0]) > 0)
        replace(compare, result, iterable[i]);

    // NOTE: if n is over some number, it becomes faster to consume the heap
    return result.sort(reverseCompare);
  }

  // Correct for size
  var size = iterables.guessLength(iterable);

  if (size !== null && size < n)
    n = size;

  result = new Array(n);
  i = 0;

  forEach(iterable, function(value) {
    if (i < n) {
      result[i] = value;
    }
    else {
      if (i === n)
        heapify(compare, result);

      if (compare(value, result[0]) > 0)
        replace(compare, result, value);
    }

    i++;
  });

  if (result.length > i)
    result.length = i;

  // NOTE: if n is over some number, it becomes faster to consume the heap
  return result.sort(reverseCompare);
}

/**
 * Binary Minimum Heap.
 *
 * @constructor
 * @param {function} comparator - Comparator function to use.
 */
function Heap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');
}

/**
 * Method used to clear the heap.
 *
 * @return {undefined}
 */
Heap.prototype.clear = function() {

  // Properties
  this.items = [];
  this.size = 0;
};

/**
 * Method used to push an item into the heap.
 *
 * @param  {any}    item - Item to push.
 * @return {number}
 */
Heap.prototype.push = function(item) {
  push(this.comparator, this.items, item);
  return ++this.size;
};

/**
 * Method used to retrieve the "first" item of the heap.
 *
 * @return {any}
 */
Heap.prototype.peek = function() {
  return this.items[0];
};

/**
 * Method used to retrieve & remove the "first" item of the heap.
 *
 * @return {any}
 */
Heap.prototype.pop = function() {
  if (this.size !== 0)
    this.size--;

  return pop(this.comparator, this.items);
};

/**
 * Method used to pop the heap, then push an item and return the popped
 * item.
 *
 * @param  {any} item - Item to push into the heap.
 * @return {any}
 */
Heap.prototype.replace = function(item) {
  return replace(this.comparator, this.items, item);
};

/**
 * Method used to push the heap, the pop it and return the pooped item.
 *
 * @param  {any} item - Item to push into the heap.
 * @return {any}
 */
Heap.prototype.pushpop = function(item) {
  return pushpop(this.comparator, this.items, item);
};

/**
 * Method used to consume the heap fully and return its items as a sorted array.
 *
 * @return {array}
 */
Heap.prototype.consume = function() {
  this.size = 0;
  return consume(this.comparator, this.items);
};

/**
 * Method used to convert the heap to an array. Note that it basically clone
 * the heap and consumes it completely. This is hardly performant.
 *
 * @return {array}
 */
Heap.prototype.toArray = function() {
  return consume(this.comparator, this.items.slice());
};

/**
 * Convenience known methods.
 */
Heap.prototype.inspect = function() {
  var proxy = this.toArray();

  // Trick so that node displays the name of the constructor
  Object.defineProperty(proxy, 'constructor', {
    value: Heap,
    enumerable: false
  });

  return proxy;
};

if (typeof Symbol !== 'undefined')
  Heap.prototype[Symbol.for('nodejs.util.inspect.custom')] = Heap.prototype.inspect;

/**
 * Binary Maximum Heap.
 *
 * @constructor
 * @param {function} comparator - Comparator function to use.
 */
function MaxHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/MaxHeap.constructor: given comparator should be a function.');

  this.comparator = reverseComparator(this.comparator);
}

MaxHeap.prototype = Heap.prototype;

/**
 * Static @.from function taking an arbitrary iterable & converting it into
 * a heap.
 *
 * @param  {Iterable} iterable   - Target iterable.
 * @param  {function} comparator - Custom comparator function.
 * @return {Heap}
 */
Heap.from = function(iterable, comparator) {
  var heap = new Heap(comparator);

  var items;

  // If iterable is an array, we can be clever about it
  if (iterables.isArrayLike(iterable))
    items = iterable.slice();
  else
    items = iterables.toArray(iterable);

  heapify(heap.comparator, items);
  heap.items = items;
  heap.size = items.length;

  return heap;
};

MaxHeap.from = function(iterable, comparator) {
  var heap = new MaxHeap(comparator);

  var items;

  // If iterable is an array, we can be clever about it
  if (iterables.isArrayLike(iterable))
    items = iterable.slice();
  else
    items = iterables.toArray(iterable);

  heapify(heap.comparator, items);
  heap.items = items;
  heap.size = items.length;

  return heap;
};

/**
 * Exporting.
 */
Heap.siftUp = siftUp;
Heap.siftDown = siftDown;
Heap.push = push;
Heap.pop = pop;
Heap.replace = replace;
Heap.pushpop = pushpop;
Heap.heapify = heapify;
Heap.consume = consume;

Heap.nsmallest = nsmallest;
Heap.nlargest = nlargest;

Heap.MinHeap = Heap;
Heap.MaxHeap = MaxHeap;

module.exports = Heap;


/***/ }),

/***/ "./node_modules/mnemonist/multi-set.js":
/*!*********************************************!*\
  !*** ./node_modules/mnemonist/multi-set.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Mnemonist MultiSet
 * ====================
 *
 * JavaScript implementation of a MultiSet.
 */
var Iterator = __webpack_require__(/*! obliterator/iterator */ "./node_modules/obliterator/iterator.js"),
    forEach = __webpack_require__(/*! obliterator/foreach */ "./node_modules/obliterator/foreach.js"),
    FixedReverseHeap = __webpack_require__(/*! ./fixed-reverse-heap.js */ "./node_modules/mnemonist/fixed-reverse-heap.js");

/**
 * Helpers.
 */
var MULTISET_ITEM_COMPARATOR = function(a, b) {
  if (a[1] > b[1])
    return -1;
  if (a[1] < b[1])
    return 1;

  return 0;
};

// TODO: helper functions: union, intersection, sum, difference, subtract

/**
 * MultiSet.
 *
 * @constructor
 */
function MultiSet() {
  this.items = new Map();

  Object.defineProperty(this.items, 'constructor', {
    value: MultiSet,
    enumerable: false
  });

  this.clear();
}

/**
 * Method used to clear the structure.
 *
 * @return {undefined}
 */
MultiSet.prototype.clear = function() {

  // Properties
  this.size = 0;
  this.dimension = 0;
  this.items.clear();
};

/**
 * Method used to add an item to the set.
 *
 * @param  {any}    item  - Item to add.
 * @param  {number} count - Optional count.
 * @return {MultiSet}
 */
MultiSet.prototype.add = function(item, count) {
  if (count === 0)
    return this;

  if (count < 0)
    return this.remove(item, -count);

  count = count || 1;

  if (typeof count !== 'number')
    throw new Error('mnemonist/multi-set.add: given count should be a number.');

  this.size += count;

  const currentCount = this.items.get(item);

  if (currentCount === undefined)
    this.dimension++;
  else
    count += currentCount;

  this.items.set(item, count);

  return this;
};

/**
 * Method used to set the multiplicity of an item in the set.
 *
 * @param  {any}    item  - Target item.
 * @param  {number} count - Desired multiplicity.
 * @return {MultiSet}
 */
MultiSet.prototype.set = function(item, count) {
  var currentCount;

  if (typeof count !== 'number')
    throw new Error('mnemonist/multi-set.set: given count should be a number.');

  // Setting an item to 0 or to a negative number means deleting it from the set
  if (count <= 0) {
    currentCount = this.items.get(item);

    if (typeof currentCount !== 'undefined') {
      this.size -= currentCount;
      this.dimension--;
    }

    this.items.delete(item);
    return this;
  }

  count = count || 1;

  currentCount = this.items.get(item);

  if (typeof currentCount === 'number') {
    this.items.set(item, currentCount + count);
  }
  else {
    this.dimension++;
    this.items.set(item, count);
  }

  this.size += count;

  return this;
};

/**
 * Method used to return whether the item exists in the set.
 *
 * @param  {any} item  - Item to check.
 * @return {boolan}
 */
MultiSet.prototype.has = function(item) {
  return this.items.has(item);
};

/**
 * Method used to delete an item from the set.
 *
 * @param  {any} item  - Item to delete.
 * @return {boolan}
 */
MultiSet.prototype.delete = function(item) {
  var count = this.items.get(item);

  if (count === 0)
    return false;

  this.size -= count;
  this.dimension--;
  this.items.delete(item);

  return true;
};

/**
 * Method used to remove an item from the set.
 *
 * @param  {any} item  - Item to delete.
 * @param  {number} count - Optional count.
 * @return {undefined}
 */
MultiSet.prototype.remove = function(item, count) {
  if (count === 0)
    return;

  if (count < 0)
    return this.add(item, -count);

  count = count || 1;

  if (typeof count !== 'number')
    throw new Error('mnemonist/multi-set.remove: given count should be a number.');

  var currentCount = this.items.get(item);

  if (typeof currentCount === 'undefined') return;

  var newCount = Math.max(0, currentCount - count);

  if (newCount === 0) {
    this.items.delete(item);
    this.size -= currentCount;
    this.dimension--;
  }
  else {
    this.items.set(item, newCount);
    this.size -= count;
  }

  return;
};

/**
 * Method used to change a key into another one, merging counts if the target
 * key already exists.
 *
 * @param  {any} a - From key.
 * @param  {any} b - To key.
 * @return {MultiSet}
 */
MultiSet.prototype.edit = function(a, b) {
  var am = this.multiplicity(a);

  // If a does not exist in the set, we can stop right there
  if (am === 0)
    return;

  var bm = this.multiplicity(b);

  this.items.set(b, am + bm);
  this.items.delete(a);

  return this;
};

/**
 * Method used to return the multiplicity of the given item.
 *
 * @param  {any} item  - Item to get.
 * @return {number}
 */
MultiSet.prototype.multiplicity = function(item) {
  var count = this.items.get(item);

  if (typeof count === 'undefined')
    return 0;

  return count;
};
MultiSet.prototype.get = MultiSet.prototype.multiplicity;
MultiSet.prototype.count = MultiSet.prototype.multiplicity;

/**
 * Method used to return the frequency of the given item in the set.
 *
 * @param  {any} item - Item to get.
 * @return {number}
 */
MultiSet.prototype.frequency = function(item) {
  if (this.size === 0)
    return 0;

  var count = this.multiplicity(item);

  return count / this.size;
};

/**
 * Method used to return the n most common items from the set.
 *
 * @param  {number} n - Number of items to retrieve.
 * @return {array}
 */
MultiSet.prototype.top = function(n) {
  if (typeof n !== 'number' || n <= 0)
    throw new Error('mnemonist/multi-set.top: n must be a number > 0.');

  var heap = new FixedReverseHeap(Array, MULTISET_ITEM_COMPARATOR, n);

  var iterator = this.items.entries(),
      step;

  while ((step = iterator.next(), !step.done))
    heap.push(step.value);

  return heap.consume();
};

/**
 * Method used to iterate over the set's values.
 *
 * @param  {function}  callback - Function to call for each item.
 * @param  {object}    scope    - Optional scope.
 * @return {undefined}
 */
MultiSet.prototype.forEach = function(callback, scope) {
  scope = arguments.length > 1 ? scope : this;

  var i;

  this.items.forEach(function(multiplicity, value) {

    for (i = 0; i < multiplicity; i++)
      callback.call(scope, value, value);
  });
};

/**
 * Method used to iterate over the set's multiplicities.
 *
 * @param  {function}  callback - Function to call for each multiplicity.
 * @param  {object}    scope    - Optional scope.
 * @return {undefined}
 */
MultiSet.prototype.forEachMultiplicity = function(callback, scope) {
  scope = arguments.length > 1 ? scope : this;

  this.items.forEach(callback, scope);
};

/**
 * Method returning an iterator over the set's keys. I.e. its unique values,
 * in a sense.
 *
 * @return {Iterator}
 */
MultiSet.prototype.keys = function() {
  return this.items.keys();
};

/**
 * Method returning an iterator over the set's values.
 *
 * @return {Iterator}
 */
MultiSet.prototype.values = function() {
  var iterator = this.items.entries(),
      inContainer = false,
      step,
      value,
      multiplicity,
      i;

  return new Iterator(function next() {
    if (!inContainer) {
      step = iterator.next();

      if (step.done)
        return {done: true};

      inContainer = true;
      value = step.value[0];
      multiplicity = step.value[1];
      i = 0;
    }

    if (i >= multiplicity) {
      inContainer = false;
      return next();
    }

    i++;

    return {
      done: false,
      value: value
    };
  });
};

/**
 * Method returning an iterator over the set's multiplicities.
 *
 * @return {Iterator}
 */
MultiSet.prototype.multiplicities = function() {
  return this.items.entries();
};

/**
 * Attaching the #.entries method to Symbol.iterator if possible.
 */
if (typeof Symbol !== 'undefined')
  MultiSet.prototype[Symbol.iterator] = MultiSet.prototype.values;

/**
 * Convenience known methods.
 */
MultiSet.prototype.inspect = function() {
  return this.items;
};

if (typeof Symbol !== 'undefined')
  MultiSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = MultiSet.prototype.inspect;
MultiSet.prototype.toJSON = function() {
  return this.items;
};

/**
 * Static @.from function taking an arbitrary iterable & converting it into
 * a structure.
 *
 * @param  {Iterable} iterable - Target iterable.
 * @return {MultiSet}
 */
MultiSet.from = function(iterable) {
  var set = new MultiSet();

  forEach(iterable, function(value) {
    set.add(value);
  });

  return set;
};

/**
 * Function returning whether the multiset A is a subset of the multiset B.
 *
 * @param  {MultiSet} A - First set.
 * @param  {MultiSet} B - Second set.
 * @return {boolean}
 */
MultiSet.isSubset = function(A, B) {
  var iterator = A.multiplicities(),
      step,
      key,
      mA;

  // Shortcuts
  if (A === B)
    return true;

  if (A.dimension > B.dimension)
    return false;

  while ((step = iterator.next(), !step.done)) {
    key = step.value[0];
    mA = step.value[1];

    if (B.multiplicity(key) < mA)
      return false;
  }

  return true;
};

/**
 * Function returning whether the multiset A is a superset of the multiset B.
 *
 * @param  {MultiSet} A - First set.
 * @param  {MultiSet} B - Second set.
 * @return {boolean}
 */
MultiSet.isSuperset = function(A, B) {
  return MultiSet.isSubset(B, A);
};

/**
 * Exporting.
 */
module.exports = MultiSet;


/***/ }),

/***/ "./node_modules/mnemonist/utils/comparators.js":
/*!*****************************************************!*\
  !*** ./node_modules/mnemonist/utils/comparators.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Mnemonist Heap Comparators
 * ===========================
 *
 * Default comparators & functions dealing with comparators reversing etc.
 */
var DEFAULT_COMPARATOR = function(a, b) {
  if (a < b)
    return -1;
  if (a > b)
    return 1;

  return 0;
};

var DEFAULT_REVERSE_COMPARATOR = function(a, b) {
  if (a < b)
    return 1;
  if (a > b)
    return -1;

  return 0;
};

/**
 * Function used to reverse a comparator.
 */
function reverseComparator(comparator) {
  return function(a, b) {
    return comparator(b, a);
  };
}

/**
 * Function returning a tuple comparator.
 */
function createTupleComparator(size) {
  if (size === 2) {
    return function(a, b) {
      if (a[0] < b[0])
        return -1;

      if (a[0] > b[0])
        return 1;

      if (a[1] < b[1])
        return -1;

      if (a[1] > b[1])
        return 1;

      return 0;
    };
  }

  return function(a, b) {
    var i = 0;

    while (i < size) {
      if (a[i] < b[i])
        return -1;

      if (a[i] > b[i])
        return 1;

      i++;
    }

    return 0;
  };
}

/**
 * Exporting.
 */
exports.DEFAULT_COMPARATOR = DEFAULT_COMPARATOR;
exports.DEFAULT_REVERSE_COMPARATOR = DEFAULT_REVERSE_COMPARATOR;
exports.reverseComparator = reverseComparator;
exports.createTupleComparator = createTupleComparator;


/***/ }),

/***/ "./node_modules/mnemonist/utils/iterables.js":
/*!***************************************************!*\
  !*** ./node_modules/mnemonist/utils/iterables.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Mnemonist Iterable Function
 * ============================
 *
 * Harmonized iteration helpers over mixed iterable targets.
 */
var forEach = __webpack_require__(/*! obliterator/foreach */ "./node_modules/obliterator/foreach.js");

var typed = __webpack_require__(/*! ./typed-arrays.js */ "./node_modules/mnemonist/utils/typed-arrays.js");

/**
 * Function used to determine whether the given object supports array-like
 * random access.
 *
 * @param  {any} target - Target object.
 * @return {boolean}
 */
function isArrayLike(target) {
  return Array.isArray(target) || typed.isTypedArray(target);
}

/**
 * Function used to guess the length of the structure over which we are going
 * to iterate.
 *
 * @param  {any} target - Target object.
 * @return {number|undefined}
 */
function guessLength(target) {
  if (typeof target.length === 'number')
    return target.length;

  if (typeof target.size === 'number')
    return target.size;

  return;
}

/**
 * Function used to convert an iterable to an array.
 *
 * @param  {any}   target - Iteration target.
 * @return {array}
 */
function toArray(target) {
  var l = guessLength(target);

  var array = typeof l === 'number' ? new Array(l) : [];

  var i = 0;

  // TODO: we could optimize when given target is array like
  forEach(target, function(value) {
    array[i++] = value;
  });

  return array;
}

/**
 * Same as above but returns a supplementary indices array.
 *
 * @param  {any}   target - Iteration target.
 * @return {array}
 */
function toArrayWithIndices(target) {
  var l = guessLength(target);

  var IndexArray = typeof l === 'number' ?
    typed.getPointerArray(l) :
    Array;

  var array = typeof l === 'number' ? new Array(l) : [];
  var indices = typeof l === 'number' ? new IndexArray(l) : [];

  var i = 0;

  // TODO: we could optimize when given target is array like
  forEach(target, function(value) {
    array[i] = value;
    indices[i] = i++;
  });

  return [array, indices];
}

/**
 * Exporting.
 */
exports.isArrayLike = isArrayLike;
exports.guessLength = guessLength;
exports.toArray = toArray;
exports.toArrayWithIndices = toArrayWithIndices;


/***/ }),

/***/ "./node_modules/mnemonist/utils/typed-arrays.js":
/*!******************************************************!*\
  !*** ./node_modules/mnemonist/utils/typed-arrays.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Mnemonist Typed Array Helpers
 * ==============================
 *
 * Miscellaneous helpers related to typed arrays.
 */

/**
 * When using an unsigned integer array to store pointers, one might want to
 * choose the optimal word size in regards to the actual numbers of pointers
 * to store.
 *
 * This helpers does just that.
 *
 * @param  {number} size - Expected size of the array to map.
 * @return {TypedArray}
 */
var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,
    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,
    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;

var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,
    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,
    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;

exports.getPointerArray = function(size) {
  var maxIndex = size - 1;

  if (maxIndex <= MAX_8BIT_INTEGER)
    return Uint8Array;

  if (maxIndex <= MAX_16BIT_INTEGER)
    return Uint16Array;

  if (maxIndex <= MAX_32BIT_INTEGER)
    return Uint32Array;

  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');
};

exports.getSignedPointerArray = function(size) {
  var maxIndex = size - 1;

  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
    return Int8Array;

  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
    return Int16Array;

  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
    return Int32Array;

  return Float64Array;
};

/**
 * Function returning the minimal type able to represent the given number.
 *
 * @param  {number} value - Value to test.
 * @return {TypedArrayClass}
 */
exports.getNumberType = function(value) {

  // <= 32 bits itnteger?
  if (value === (value | 0)) {

    // Negative
    if (Math.sign(value) === -1) {
      if (value <= 127 && value >= -128)
        return Int8Array;

      if (value <= 32767 && value >= -32768)
        return Int16Array;

      return Int32Array;
    }
    else {

      if (value <= 255)
        return Uint8Array;

      if (value <= 65535)
        return Uint16Array;

      return Uint32Array;
    }
  }

  // 53 bits integer & floats
  // NOTE: it's kinda hard to tell whether we could use 32bits or not...
  return Float64Array;
};

/**
 * Function returning the minimal type able to represent the given array
 * of JavaScript numbers.
 *
 * @param  {array}    array  - Array to represent.
 * @param  {function} getter - Optional getter.
 * @return {TypedArrayClass}
 */
var TYPE_PRIORITY = {
  Uint8Array: 1,
  Int8Array: 2,
  Uint16Array: 3,
  Int16Array: 4,
  Uint32Array: 5,
  Int32Array: 6,
  Float32Array: 7,
  Float64Array: 8
};

// TODO: make this a one-shot for one value
exports.getMinimalRepresentation = function(array, getter) {
  var maxType = null,
      maxPriority = 0,
      p,
      t,
      v,
      i,
      l;

  for (i = 0, l = array.length; i < l; i++) {
    v = getter ? getter(array[i]) : array[i];
    t = exports.getNumberType(v);
    p = TYPE_PRIORITY[t.name];

    if (p > maxPriority) {
      maxPriority = p;
      maxType = t;
    }
  }

  return maxType;
};

/**
 * Function returning whether the given value is a typed array.
 *
 * @param  {any} value - Value to test.
 * @return {boolean}
 */
exports.isTypedArray = function(value) {
  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);
};

/**
 * Function used to concat byte arrays.
 *
 * @param  {...ByteArray}
 * @return {ByteArray}
 */
exports.concat = function() {
  var length = 0,
      i,
      o,
      l;

  for (i = 0, l = arguments.length; i < l; i++)
    length += arguments[i].length;

  var array = new (arguments[0].constructor)(length);

  for (i = 0, o = 0; i < l; i++) {
    array.set(arguments[i], o);
    o += arguments[i].length;
  }

  return array;
};

/**
 * Function used to initialize a byte array of indices.
 *
 * @param  {number}    length - Length of target.
 * @return {ByteArray}
 */
exports.indices = function(length) {
  var PointerArray = exports.getPointerArray(length);

  var array = new PointerArray(length);

  for (var i = 0; i < length; i++)
    array[i] = i;

  return array;
};


/***/ }),

/***/ "./node_modules/obliterator/foreach.js":
/*!*********************************************!*\
  !*** ./node_modules/obliterator/foreach.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Obliterator ForEach Function
 * =============================
 *
 * Helper function used to easily iterate over mixed values.
 */
var support = __webpack_require__(/*! ./support.js */ "./node_modules/obliterator/support.js");

var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;
var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;

/**
 * Function able to iterate over almost any iterable JS value.
 *
 * @param  {any}      iterable - Iterable value.
 * @param  {function} callback - Callback function.
 */
module.exports = function forEach(iterable, callback) {
  var iterator, k, i, l, s;

  if (!iterable) throw new Error('obliterator/forEach: invalid iterable.');

  if (typeof callback !== 'function')
    throw new Error('obliterator/forEach: expecting a callback.');

  // The target is an array or a string or function arguments
  if (
    Array.isArray(iterable) ||
    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable)) ||
    typeof iterable === 'string' ||
    iterable.toString() === '[object Arguments]'
  ) {
    for (i = 0, l = iterable.length; i < l; i++) callback(iterable[i], i);
    return;
  }

  // The target has a #.forEach method
  if (typeof iterable.forEach === 'function') {
    iterable.forEach(callback);
    return;
  }

  // The target is iterable
  if (
    SYMBOL_SUPPORT &&
    Symbol.iterator in iterable &&
    typeof iterable.next !== 'function'
  ) {
    iterable = iterable[Symbol.iterator]();
  }

  // The target is an iterator
  if (typeof iterable.next === 'function') {
    iterator = iterable;
    i = 0;

    while (((s = iterator.next()), s.done !== true)) {
      callback(s.value, i);
      i++;
    }

    return;
  }

  // The target is a plain object
  for (k in iterable) {
    if (iterable.hasOwnProperty(k)) {
      callback(iterable[k], k);
    }
  }

  return;
};


/***/ }),

/***/ "./node_modules/obliterator/iterator.js":
/*!**********************************************!*\
  !*** ./node_modules/obliterator/iterator.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Obliterator Iterator Class
 * ===========================
 *
 * Simple class representing the library's iterators.
 */

/**
 * Iterator class.
 *
 * @constructor
 * @param {function} next - Next function.
 */
function Iterator(next) {
  if (typeof next !== 'function')
    throw new Error('obliterator/iterator: expecting a function!');

  this.next = next;
}

/**
 * If symbols are supported, we add `next` to `Symbol.iterator`.
 */
if (typeof Symbol !== 'undefined')
  Iterator.prototype[Symbol.iterator] = function () {
    return this;
  };

/**
 * Returning an iterator of the given values.
 *
 * @param  {any...} values - Values.
 * @return {Iterator}
 */
Iterator.of = function () {
  var args = arguments,
    l = args.length,
    i = 0;

  return new Iterator(function () {
    if (i >= l) return {done: true};

    return {done: false, value: args[i++]};
  });
};

/**
 * Returning an empty iterator.
 *
 * @return {Iterator}
 */
Iterator.empty = function () {
  var iterator = new Iterator(function () {
    return {done: true};
  });

  return iterator;
};

/**
 * Returning an iterator over the given indexed sequence.
 *
 * @param  {string|Array} sequence - Target sequence.
 * @return {Iterator}
 */
Iterator.fromSequence = function (sequence) {
  var i = 0,
    l = sequence.length;

  return new Iterator(function () {
    if (i >= l) return {done: true};

    return {done: false, value: sequence[i++]};
  });
};

/**
 * Returning whether the given value is an iterator.
 *
 * @param  {any} value - Value.
 * @return {boolean}
 */
Iterator.is = function (value) {
  if (value instanceof Iterator) return true;

  return (
    typeof value === 'object' &&
    value !== null &&
    typeof value.next === 'function'
  );
};

/**
 * Exporting.
 */
module.exports = Iterator;


/***/ }),

/***/ "./node_modules/obliterator/support.js":
/*!*********************************************!*\
  !*** ./node_modules/obliterator/support.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';
exports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';


/***/ }),

/***/ "./node_modules/pandemonium/random.js":
/*!********************************************!*\
  !*** ./node_modules/pandemonium/random.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Pandemonium Random
 * ===================
 *
 * Random function.
 */

/**
 * Creating a function returning a random integer such as a <= N <= b.
 *
 * @param  {function} rng - RNG function returning uniform random.
 * @return {function}     - The created function.
 */
function createRandom(rng) {
  /**
   * Random function.
   *
   * @param  {number} a - From.
   * @param  {number} b - To.
   * @return {number}
   */
  return function (a, b) {
    return a + Math.floor(rng() * (b - a + 1));
  };
}

/**
 * Default random using `Math.random`.
 */
var random = createRandom(Math.random);

/**
 * Exporting.
 */
random.createRandom = createRandom;
module.exports = random;


/***/ }),

/***/ "./node_modules/pandemonium/shuffle-in-place.js":
/*!******************************************************!*\
  !*** ./node_modules/pandemonium/shuffle-in-place.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Pandemonium Shuffle In Place
 * =============================
 *
 * Shuffle function applying the Fisher-Yates algorithm to the provided array.
 */
var createRandom = (__webpack_require__(/*! ./random.js */ "./node_modules/pandemonium/random.js").createRandom);

/**
 * Creating a function returning the given array shuffled.
 *
 * @param  {function} rng - The RNG to use.
 * @return {function}     - The created function.
 */
function createShuffleInPlace(rng) {
  var customRandom = createRandom(rng);

  /**
   * Function returning the shuffled array.
   *
   * @param  {array}  sequence - Target sequence.
   * @return {array}           - The shuffled sequence.
   */
  return function (sequence) {
    var length = sequence.length,
      lastIndex = length - 1;

    var index = -1;

    while (++index < length) {
      var r = customRandom(index, lastIndex),
        value = sequence[r];

      sequence[r] = sequence[index];
      sequence[index] = value;
    }
  };
}

/**
 * Default shuffle in place using `Math.random`.
 */
var shuffleInPlace = createShuffleInPlace(Math.random);

/**
 * Exporting.
 */
shuffleInPlace.createShuffleInPlace = createShuffleInPlace;
module.exports = shuffleInPlace;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/edge.line.js":
/*!******************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/edge.line.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __webpack_require__(/*! ../../../utils */ "./node_modules/sigma/utils/index.js");
var edge_1 = __webpack_require__(/*! ./common/edge */ "./node_modules/sigma/rendering/webgl/programs/common/edge.js");
var edge_line_vert_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.line.vert.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.line.vert.glsl.js"));
var edge_line_frag_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.line.frag.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.line.frag.glsl.js"));
var UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE, FLOAT = WebGLRenderingContext.FLOAT;
var UNIFORMS = ["u_matrix"];
var EdgeLineProgram = /** @class */ (function (_super) {
    __extends(EdgeLineProgram, _super);
    function EdgeLineProgram() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EdgeLineProgram.prototype.getDefinition = function () {
        return {
            VERTICES: 2,
            ARRAY_ITEMS_PER_VERTEX: 3,
            VERTEX_SHADER_SOURCE: edge_line_vert_glsl_1.default,
            FRAGMENT_SHADER_SOURCE: edge_line_frag_glsl_1.default,
            UNIFORMS: UNIFORMS,
            ATTRIBUTES: [
                { name: "a_position", size: 2, type: FLOAT },
                { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
            ],
        };
    };
    EdgeLineProgram.prototype.processVisibleItem = function (i, sourceData, targetData, data) {
        var array = this.array;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0, utils_1.floatColor)(data.color);
        // First point
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = color;
        // Second point
        array[i++] = x2;
        array[i++] = y2;
        array[i] = color;
    };
    EdgeLineProgram.prototype.draw = function (params) {
        var gl = this.gl;
        var u_matrix = this.uniformLocations.u_matrix;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.drawArrays(gl.LINES, 0, this.verticesCount);
    };
    return EdgeLineProgram;
}(edge_1.EdgeProgram));
exports["default"] = EdgeLineProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/edge.triangle.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/edge.triangle.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __webpack_require__(/*! ../../../utils */ "./node_modules/sigma/utils/index.js");
var edge_1 = __webpack_require__(/*! ./common/edge */ "./node_modules/sigma/rendering/webgl/programs/common/edge.js");
var edge_triangle_vert_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.triangle.vert.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.triangle.vert.glsl.js"));
var edge_triangle_frag_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.triangle.frag.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.triangle.frag.glsl.js"));
var UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE, FLOAT = WebGLRenderingContext.FLOAT;
var UNIFORMS = ["u_matrix", "u_sizeRatio", "u_correctionRatio"];
var EdgeTriangleProgram = /** @class */ (function (_super) {
    __extends(EdgeTriangleProgram, _super);
    function EdgeTriangleProgram() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EdgeTriangleProgram.prototype.getDefinition = function () {
        return {
            VERTICES: 3,
            ARRAY_ITEMS_PER_VERTEX: 5,
            VERTEX_SHADER_SOURCE: edge_triangle_vert_glsl_1.default,
            FRAGMENT_SHADER_SOURCE: edge_triangle_frag_glsl_1.default,
            UNIFORMS: UNIFORMS,
            ATTRIBUTES: [
                { name: "a_position", size: 2, type: FLOAT },
                { name: "a_normal", size: 2, type: FLOAT },
                { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
            ],
        };
    };
    EdgeTriangleProgram.prototype.processVisibleItem = function (i, sourceData, targetData, data) {
        var thickness = data.size || 1;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0, utils_1.floatColor)(data.color);
        // Computing normals
        var dx = x2 - x1;
        var dy = y2 - y1;
        var len = dx * dx + dy * dy;
        var n1 = 0;
        var n2 = 0;
        if (len) {
            len = 1 / Math.sqrt(len);
            n1 = -dy * len * thickness;
            n2 = dx * len * thickness;
        }
        var array = this.array;
        // First point
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = n1;
        array[i++] = n2;
        array[i++] = color;
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = color;
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = 0;
        array[i++] = 0;
        array[i] = color;
    };
    EdgeTriangleProgram.prototype.draw = function (params) {
        var gl = this.gl;
        var _a = this.uniformLocations, u_matrix = _a.u_matrix, u_sizeRatio = _a.u_sizeRatio, u_correctionRatio = _a.u_correctionRatio;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.drawArrays(gl.TRIANGLES, 0, this.verticesCount);
    };
    return EdgeTriangleProgram;
}(edge_1.EdgeProgram));
exports["default"] = EdgeTriangleProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/node.circle.js":
/*!********************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/node.circle.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __webpack_require__(/*! ../../../utils */ "./node_modules/sigma/utils/index.js");
var node_1 = __webpack_require__(/*! ./common/node */ "./node_modules/sigma/rendering/webgl/programs/common/node.js");
var node_circle_vert_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/node.circle.vert.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/node.circle.vert.glsl.js"));
var node_circle_frag_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/node.circle.frag.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/node.circle.frag.glsl.js"));
var UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE, FLOAT = WebGLRenderingContext.FLOAT;
var UNIFORMS = ["u_sizeRatio", "u_correctionRatio", "u_matrix"];
var NodeCircleProgram = /** @class */ (function (_super) {
    __extends(NodeCircleProgram, _super);
    function NodeCircleProgram() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeCircleProgram.prototype.getDefinition = function () {
        return {
            VERTICES: 3,
            ARRAY_ITEMS_PER_VERTEX: 5,
            VERTEX_SHADER_SOURCE: node_circle_vert_glsl_1.default,
            FRAGMENT_SHADER_SOURCE: node_circle_frag_glsl_1.default,
            UNIFORMS: UNIFORMS,
            ATTRIBUTES: [
                { name: "a_position", size: 2, type: FLOAT },
                { name: "a_size", size: 1, type: FLOAT },
                { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
                { name: "a_angle", size: 1, type: FLOAT },
            ],
        };
    };
    NodeCircleProgram.prototype.processVisibleItem = function (i, data) {
        var array = this.array;
        var color = (0, utils_1.floatColor)(data.color);
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = data.size;
        array[i++] = color;
        array[i++] = NodeCircleProgram.ANGLE_1;
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = data.size;
        array[i++] = color;
        array[i++] = NodeCircleProgram.ANGLE_2;
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = data.size;
        array[i++] = color;
        array[i] = NodeCircleProgram.ANGLE_3;
    };
    NodeCircleProgram.prototype.draw = function (params) {
        var gl = this.gl;
        var _a = this.uniformLocations, u_sizeRatio = _a.u_sizeRatio, u_correctionRatio = _a.u_correctionRatio, u_matrix = _a.u_matrix;
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.drawArrays(gl.TRIANGLES, 0, this.verticesCount);
    };
    NodeCircleProgram.ANGLE_1 = 0;
    NodeCircleProgram.ANGLE_2 = (2 * Math.PI) / 3;
    NodeCircleProgram.ANGLE_3 = (4 * Math.PI) / 3;
    return NodeCircleProgram;
}(node_1.NodeProgram));
exports["default"] = NodeCircleProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/edge.line.frag.glsl.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/edge.line.frag.glsl.js ***!
  \***************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(o,r)=>{for(var t in r)e.o(r,t)&&!e.o(o,t)&&Object.defineProperty(o,t,{enumerable:!0,get:r[t]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},o={};e.r(o),e.d(o,{default:()=>r});const r="precision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n";module.exports=o})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/edge.line.vert.glsl.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/edge.line.vert.glsl.js ***!
  \***************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var o={d:(e,n)=>{for(var t in n)o.o(n,t)&&!o.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},o:(o,e)=>Object.prototype.hasOwnProperty.call(o,e),r:o=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})}},e={};o.r(e),o.d(e,{default:()=>n});const n="attribute vec2 a_position;\nattribute vec4 a_color;\n\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  // Scale from [[-1 1] [-1 1]] to the container:\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";module.exports=e})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/edge.triangle.frag.glsl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/edge.triangle.frag.glsl.js ***!
  \*******************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(o,r)=>{for(var t in r)e.o(r,t)&&!e.o(o,t)&&Object.defineProperty(o,t,{enumerable:!0,get:r[t]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},o={};e.r(o),e.d(o,{default:()=>r});const r="precision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n";module.exports=o})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/edge.triangle.vert.glsl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/edge.triangle.vert.glsl.js ***!
  \*******************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var n={d:(o,e)=>{for(var t in e)n.o(e,t)&&!n.o(o,t)&&Object.defineProperty(o,t,{enumerable:!0,get:e[t]})},o:(n,o)=>Object.prototype.hasOwnProperty.call(n,o),r:n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}},o={};n.r(o),n.d(o,{default:()=>e});const e="attribute vec4 a_color;\nattribute vec2 a_normal;\nattribute vec2 a_position;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  // The only different here with edge.vert.glsl is that we need to handle null\n  // input normal vector. Apart from that, you can read edge.vert.glsl more info\n  // on how it works:\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n  if (normalLength <= 0.0) unitNormal = a_normal;\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  gl_Position = vec4((u_matrix * vec3(a_position + unitNormal * webGLThickness, 1)).xy, 0, 1);\n\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";module.exports=o})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/node.circle.frag.glsl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/node.circle.frag.glsl.js ***!
  \*****************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(n,r)=>{for(var t in r)e.o(r,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:r[t]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};e.r(n),e.d(n,{default:()=>r});const r="precision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float dist = length(v_diffVector) - v_radius;\n\n  float t = 0.0;\n  if (dist > v_border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / v_border;\n\n  gl_FragColor = mix(v_color, transparent, t);\n}\n";module.exports=n})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/node.circle.vert.glsl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/node.circle.vert.glsl.js ***!
  \*****************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var o={d:(n,t)=>{for(var e in t)o.o(t,e)&&!o.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},o:(o,n)=>Object.prototype.hasOwnProperty.call(o,n),r:o=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})}},n={};o.r(n),o.d(n,{default:()=>t});const t="attribute vec2 a_position;\nattribute float a_size;\nattribute float a_angle;\nattribute vec4 a_color;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\nconst float marginRatio = 1.05;\n\nvoid main() {\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\n  vec2 position = a_position + diffVector * marginRatio;\n  gl_Position = vec4(\n    (u_matrix * vec3(position, 1)).xy,\n    0,\n    1\n  );\n\n  v_border = u_correctionRatio;\n  v_diffVector = diffVector;\n  v_radius = size / 2.0 / marginRatio;\n\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";module.exports=n})();

/***/ }),

/***/ "./node_modules/choices.js/public/assets/styles/choices.min.css":
/*!**********************************************************************!*\
  !*** ./node_modules/choices.js/public/assets/styles/choices.min.css ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var api = __webpack_require__(/*! !../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../../../../css-loader/dist/cjs.js!./choices.min.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/choices.js/public/assets/styles/choices.min.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/xml-writer/index.js":
/*!******************************************!*\
  !*** ./node_modules/xml-writer/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/xml-writer.js */ "./node_modules/xml-writer/lib/xml-writer.js");


/***/ }),

/***/ "./node_modules/xml-writer/lib/xml-writer.js":
/*!***************************************************!*\
  !*** ./node_modules/xml-writer/lib/xml-writer.js ***!
  \***************************************************/
/***/ ((module) => {


function isFalse(s) {
  return typeof s !== 'number' && !s;
}

function strval(s) {
  if (typeof s == 'string') {
    return s;
  }
  else if (typeof s == 'number') {
    return s+'';
  }
  else if (typeof s == 'function') {
    return s();
  }
  else if (s instanceof XMLWriter) {
    return s.toString();
  }
  else throw Error('Bad Parameter');
}

function XMLWriter(indent, callback) {

    if (!(this instanceof XMLWriter)) {
        return new XMLWriter();
    }

    this.name_regex = /[_:A-Za-z][-._:A-Za-z0-9]*/;
    this.indent = indent ? true : false;
    this.indentString = this.indent && typeof indent === 'string' ? indent : '    ';
    this.output = '';
    this.stack = [];
    this.tags = 0;
    this.attributes = 0;
    this.attribute = 0;
    this.texts = 0;
    this.comment = 0;
    this.dtd = 0;
    this.root = '';
    this.pi = 0;
    this.cdata = 0;
    this.started_write = false;
    this.writer;
    this.writer_encoding = 'UTF-8';

    if (typeof callback == 'function') {
        this.writer = callback;
    } else {
        this.writer = function (s, e) {
            this.output += s;
        }
    }
}

XMLWriter.prototype = {
    toString : function () {
        this.flush();
        return this.output;
    },

    indenter : function () {
      if (this.indent) {
        this.write('\n');
        for (var i = 1; i < this.tags; i++) {
          this.write(this.indentString);
        }
      }
    },

    write : function () {
        for (var i = 0; i < arguments.length; i++) {
            this.writer(arguments[i], this.writer_encoding);
        }
    },


    flush : function () {
        for (var i = this.tags; i > 0; i--) {
            this.endElement();
        }
        this.tags = 0;
    },

    startDocument : function (version, encoding, standalone) {
        if (this.tags || this.attributes) return this;

        this.startPI('xml');
        this.startAttribute('version');
        this.text(typeof version == "string" ? version : "1.0");
        this.endAttribute();
        if (typeof encoding == "string") {
            this.startAttribute('encoding');
            this.text(encoding);
            this.endAttribute();
            this.writer_encoding = encoding;
        }
        if (standalone) {
            this.startAttribute('standalone');
            this.text("yes");
            this.endAttribute();
        }
        this.endPI();
        if (!this.indent) {
          this.write('\n');
        }
        return this;
    },

    endDocument : function () {
        if (this.attributes) this.endAttributes();
        return this;
    },

    writeElement : function (name, content) {
        return this.startElement(name).text(content).endElement();
    },

    writeElementNS : function (prefix, name, uri, content) {
        if (!content) {
            content = uri;
        }
        return this.startElementNS(prefix, name, uri).text(content).endElement();
    },

    startElement : function (name) {
        name = strval(name);
        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');
        if (this.tags === 0 && this.root && this.root !== name) throw Error('Invalid Parameter');
        if (this.attributes) this.endAttributes();
        ++this.tags;
        this.texts = 0;
        if (this.stack.length > 0)
          this.stack[this.stack.length-1].containsTag = true;

        this.stack.push({
            name: name,
            tags: this.tags
        });
        if (this.started_write) this.indenter();
        this.write('<', name);
        this.startAttributes();
        this.started_write = true;
        return this;
    },
    startElementNS : function (prefix, name, uri) {
        prefix = strval(prefix);
        name = strval(name);

        if (!prefix.match(this.name_regex)) throw Error('Invalid Parameter');
        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');
        if (this.attributes) this.endAttributes();
        ++this.tags;
        this.texts = 0;
        if (this.stack.length > 0)
          this.stack[this.stack.length-1].containsTag = true;

        this.stack.push({
            name: prefix + ':' + name,
            tags: this.tags
        });
        if (this.started_write) this.indenter();
        this.write('<', prefix + ':' + name);
        this.startAttributes();
        this.started_write = true;
        return this;
    },

    endElement : function () {
        if (!this.tags) return this;
        var t = this.stack.pop();
        if (this.attributes > 0) {
            if (this.attribute) {
                if (this.texts) this.endAttribute();
                this.endAttribute();
            }
            this.write('/');
            this.endAttributes();
        } else {
            if (t.containsTag) this.indenter();
            this.write('</', t.name, '>');
        }
        --this.tags;
        this.texts = 0;
        return this;
    },

    writeAttribute : function (name, content) {
        if (typeof content == 'function') {
          content = content();
        }
        if (isFalse(content)) {
           return this;
        }
        return this.startAttribute(name).text(content).endAttribute();
    },
    writeAttributeNS : function (prefix, name, uri, content) {
        if (!content) {
            content = uri;
        }
        if (typeof content == 'function') {
          content = content();
        }
        if (isFalse(content)) {
          return this;
        }
        return this.startAttributeNS(prefix, name, uri).text(content).endAttribute();
    },

    startAttributes : function () {
        this.attributes = 1;
        return this;
    },

    endAttributes : function () {
        if (!this.attributes) return this;
        if (this.attribute) this.endAttribute();
        this.attributes = 0;
        this.attribute = 0;
        this.texts = 0;
        this.write('>');
        return this;
    },

    startAttribute : function (name) {
        name = strval(name);
        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');
        if (!this.attributes && !this.pi) return this;
        if (this.attribute) return this;
        this.attribute = 1;
        this.write(' ', name, '="');
        return this;
    },
    startAttributeNS : function (prefix, name, uri) {
        prefix = strval(prefix);
        name = strval(name);

        if (!prefix.match(this.name_regex)) throw Error('Invalid Parameter');
        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');
        if (!this.attributes && !this.pi) return this;
        if (this.attribute) return this;
        this.attribute = 1;
        this.write(' ', prefix + ':' + name, '="');
        return this;
    },
    endAttribute : function () {
        if (!this.attribute) return this;
        this.attribute = 0;
        this.texts = 0;
        this.write('"');
        return this;
    },

    text : function (content) {
        content = strval(content);
        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;
        if (this.attributes && this.attribute) {
            ++this.texts;
            this.write(content
                       .replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/"/g, '&quot;')
                       .replace(/\t/g, '&#x9;')
                       .replace(/\n/g, '&#xA;')
                       .replace(/\r/g, '&#xD;')
                      );
            return this;
        } else if (this.attributes && !this.attribute) {
            this.endAttributes();
        }
        if (this.comment || this.cdata) {
            this.write(content);
        }
        else {
          this.write(content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'));
        }
        ++this.texts;
        this.started_write = true;
        return this;
    },

    writeComment : function (content) {
        return this.startComment().text(content).endComment();
    },

    startComment : function () {
        if (this.comment) return this;
        if (this.attributes) this.endAttributes();
        this.indenter();
        this.write('<!--');
        this.comment = 1;
        this.started_write = true;
        return this;
    },

    endComment : function () {
        if (!this.comment) return this;
        this.write('-->');
        this.comment = 0;
        return this;
    },

    writeDocType : function (name, pubid, sysid, subset) {
        return this.startDocType(name, pubid, sysid, subset).endDocType()
    },

    startDocType : function (name, pubid, sysid, subset) {
        if (this.dtd || this.tags) return this;

        name = strval(name);
        pubid = pubid ? strval(pubid) : pubid;
        sysid = sysid ? strval(sysid) : sysid;
        subset = subset ? strval(subset) : subset;

        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');
        if (pubid && !pubid.match(/^[\w\-][\w\s\-\/\+\:\.]*/)) throw Error('Invalid Parameter');
        if (sysid && !sysid.match(/^[\w\.][\w\-\/\\\:\.]*/)) throw Error('Invalid Parameter');
        if (subset && !subset.match(/[\w\s\<\>\+\.\!\#\-\?\*\,\(\)\|]*/)) throw Error('Invalid Parameter');

        pubid = pubid ? ' PUBLIC "' + pubid + '"' : (sysid) ? ' SYSTEM' : '';
        sysid = sysid ? ' "' + sysid + '"' : '';
        subset = subset ? ' [' + subset + ']': '';

        if (this.started_write) this.indenter();
        this.write('<!DOCTYPE ', name, pubid, sysid, subset);
        this.root = name;
        this.dtd = 1;
        this.started_write = true;
        return this;
    },

    endDocType : function () {
        if (!this.dtd) return this;
        this.write('>');
        return this;
    },

    writePI : function (name, content) {
        return this.startPI(name).text(content).endPI()
    },

    startPI : function (name) {
        name = strval(name);
        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');
        if (this.pi) return this;
        if (this.attributes) this.endAttributes();
        if (this.started_write) this.indenter();
        this.write('<?', name);
        this.pi = 1;
        this.started_write = true;
        return this;
    },

    endPI : function () {
        if (!this.pi) return this;
        this.write('?>');
        this.pi = 0;
        return this;
    },

    writeCData : function (content) {
        return this.startCData().text(content).endCData();
    },

    startCData : function () {
        if (this.cdata) return this;
        if (this.attributes) this.endAttributes();
        this.indenter();
        this.write('<![CDATA[');
        this.cdata = 1;
        this.started_write = true;
        return this;
    },

    endCData : function () {
        if (!this.cdata) return this;
        this.write(']]>');
        this.cdata = 0;
        return this;
    },

    writeRaw : function(content) {
        content = strval(content);
        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;
        if (this.attributes && this.attribute) {
            ++this.texts;
            this.write(content.replace('&', '&amp;').replace('"', '&quot;'));
            return this;
        } else if (this.attributes && !this.attribute) {
            this.endAttributes();
        }
        ++this.texts;
        this.write(content);
        this.started_write = true;
        return this;
    }

}

module.exports = XMLWriter;


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_yomguithereal_sigma-experiments-renderers_edge_edge_curve_js-node_module-008457.00efc89d3a2e641b91f8.js.map