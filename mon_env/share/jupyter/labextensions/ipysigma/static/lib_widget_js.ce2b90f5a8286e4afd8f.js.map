{"version":3,"file":"lib_widget_js.ce2b90f5a8286e4afd8f.js","mappings":";;;;;;;;;AAAa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uCAAuC,mBAAO,CAAC,6CAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW,sCAAsC;AAC1F,sBAAsB,QAAQ,EAAE,KAAK,KAAK,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACtDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ,EAAE,KAAK,KAAK,KAAK;AAC/C;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACda;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,0BAA0B,GAAG,2BAA2B,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,gBAAgB;AAC/M,gBAAgB;AAChB,kBAAkB;AAClB,qBAAqB;AACrB,uBAAuB;AACvB,gBAAgB;AAChB,iBAAiB;AACjB,2BAA2B;AAC3B,0BAA0B;AAC1B,mBAAmB;AACnB;;;;;;;;;;;ACZa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,mBAAO,CAAC,mEAAU;AACrD,iCAAiC,mBAAO,CAAC,iGAAoB;AAC7D,2BAA2B,mBAAO,CAAC,oFAA8B;AACjE,qCAAqC,mBAAO,CAAC,yEAAY;AACzD,iBAAiB,mBAAO,CAAC,iCAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AC/Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,qBAAqB,GAAG,qBAAqB;AACpE,qBAAqB;AACrB,MAAM,qCAAqC;AAC3C,MAAM,+CAA+C;AACrD,MAAM,qCAAqC;AAC3C,MAAM,yCAAyC;AAC/C,MAAM,iCAAiC;AACvC,MAAM,uCAAuC;AAC7C,MAAM,sCAAsC;AAC5C,MAAM,oCAAoC;AAC1C;AACA,qBAAqB;AACrB;AACA,iCAAiC,iBAAiB;AAClD;AACA,CAAC;AACD;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;;;;;ACtBa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,uBAAuB;AAClI,gCAAgC,mBAAO,CAAC,0DAAO;AAC/C,qCAAqC,mBAAO,CAAC,yEAAY;AACzD,0BAA0B,mBAAO,CAAC,gFAAyB;AAC3D;AACA,mCAAmC,mBAAO,CAAC,0EAAyB;AACpE;AACA,mBAAmB,mBAAO,CAAC,0EAAyB;AACpD;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,6CAA6C,WAAW;AACxD,eAAe;AACf,KAAK;AACL;AACA;AACA,6CAA6C,WAAW,kDAAkD;AAC1G,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA,mDAAmD,0BAA0B;AAC7E;AACA,kBAAkB;AAClB;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA,kBAAkB;AAClB;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uBAAuB;AAC1E;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uFAAuF,MAAM,GAAG,UAAU;AAC1G;AACA,sBAAsB;AACtB;;;;;;;;;;;ACnJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,sBAAsB;AAC5C;AACA;AACA;AACA,aAAa,mBAAO,CAAC,uCAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;;AClBa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,uBAAuB,GAAG,2BAA2B,GAAG,wBAAwB,GAAG,cAAc;AACvI,oCAAoC,mBAAO,CAAC,kEAAqB;AACjE,kCAAkC,mBAAO,CAAC,mCAAW;AACrD,mBAAmB,mBAAO,CAAC,mEAAU;AACrC,iCAAiC,mBAAO,CAAC,iGAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;;;;;;;;;;ACvSa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,kBAAkB;AACtC,eAAe,mBAAO,CAAC,oFAAuB;AAC9C,qCAAqC,mBAAO,CAAC,yEAAY;AACzD,iCAAiC,mBAAO,CAAC,oGAAsC;AAC/E,iCAAiC,mBAAO,CAAC,8FAAmC;AAC5E,wDAAwD,mBAAO,CAAC,kIAA+B;AAC/F,yDAAyD,mBAAO,CAAC,qIAAgC;AACjG,gBAAgB,mBAAO,CAAC,0EAAyB;AACjD,oCAAoC,mBAAO,CAAC,sEAAW;AACvD,gCAAgC,mBAAO,CAAC,0DAAO;AAC/C,kBAAkB,mBAAO,CAAC,kEAAqB;AAC/C,eAAe,mBAAO,CAAC,gHAA4C;AACnE,qCAAqC,mBAAO,CAAC,8GAA2C;AACxF,4CAA4C,mBAAO,CAAC,8JAAmE;AACvH,oCAAoC,mBAAO,CAAC,8IAA2D;AACvG,yCAAyC,mBAAO,CAAC,wJAAgE;AACjH,oCAAoC,mBAAO,CAAC,4GAA0C;AACtF,yCAAyC,mBAAO,CAAC,sHAA+C;AAChG,wCAAwC,mBAAO,CAAC,oHAA8C;AAC9F,qCAAqC,mBAAO,CAAC,gJAA4D;AACzG,iCAAiC,mBAAO,CAAC,+CAAQ;AACjD,qCAAqC,mBAAO,CAAC,yEAAY;AACzD,uCAAuC,mBAAO,CAAC,+EAAc;AAC7D,qCAAqC,mBAAO,CAAC,yEAAY;AACzD,qCAAqC,mBAAO,CAAC,yEAAY;AACzD,mCAAmC,mBAAO,CAAC,mEAAU;AACrD,kBAAkB,mBAAO,CAAC,mCAAW;AACrC,uCAAuC,mBAAO,CAAC,6CAAgB;AAC/D,uCAAuC,mBAAO,CAAC,6CAAgB;AAC/D,2BAA2B,mBAAO,CAAC,qDAAoB;AACvD,gBAAgB,mBAAO,CAAC,+BAAS;AACjC,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,gBAAgB,mBAAO,CAAC,+BAAS;AACjC,mBAAO,CAAC,uHAAiD;AACzD,mBAAO,CAAC,2CAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uBAAuB,0QAA0Q,sBAAsB,+GAA+G;AACnd;AACA;AACA,kBAAkB;AAClB,yCAAyC;AACzC;AACA;AACA;AACA,oCAAoC;AACpC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK,WAAW,KAAK,IAAI,KAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA,0BAA0B,4BAA4B,EAAE,yDAAyD;AACjH,eAAe,WAAW,SAAS,yCAAyC,mBAAmB,wCAAwC;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB,IAAI,wBAAwB;AAC7C;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,IAAI,kBAAkB;AACrF;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,mEAAmE,eAAe;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iBAAiB,UAAU,OAAO;AAChG;AACA;AACA,8DAA8D,iBAAiB,UAAU,QAAQ;AACjG;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA,4EAA4E,kBAAkB,wCAAwC,kBAAkB;AACxJ;AACA;AACA,6DAA6D,kBAAkB,aAAa,mBAAmB,yBAAyB,kBAAkB,aAAa,kBAAkB;AACzL;AACA;AACA;AACA,8DAA8D,iBAAiB,UAAU,QAAQ;AACjG;AACA;AACA;AACA,kDAAkD,cAAc;AAChE;AACA;AACA;AACA,0GAA0G,OAAO,gBAAgB,IAAI,wBAAwB,MAAM,0CAA0C,MAAM;AACnN,yBAAyB;AACzB;AACA;AACA,qEAAqE,6BAA6B;AAClG;AACA;AACA;AACA,iEAAiE,aAAa;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D,qCAAqC,0BAA0B,KAAK,yBAAyB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,oBAAoB,OAAO,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oCAAoC;AAC9E;AACA,gDAAgD,sCAAsC;AACtF,iDAAiD,uCAAuC;AACxF;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,6CAA6C,MAAM;AACnD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,wBAAwB,qBAAqB;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,eAAe;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gCAAgC;AAC7E,aAAa;AACb,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oCAAoC;AACrF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wDAAwD,yBAAyB;AACjF,aAAa;AACb,+CAA+C,qBAAqB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM;AACnD,gDAAgD,+BAA+B;AAC/E,aAAa;AACb,6CAA6C,MAAM;AACnD,gDAAgD,+BAA+B;AAC/E,aAAa;AACb,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;;;ACl0CA;AACA,kCAAkC,mBAAO,CAAC,qGAAgD;AAC1F;AACA;AACA,iFAAiF,uBAAuB,GAAG,sCAAsC,qBAAqB,4BAA4B,8BAA8B,2BAA2B,wBAAwB,GAAG,iDAAiD,kCAAkC,GAAG,qCAAqC,4BAA4B,qBAAqB,wBAAwB,GAAG,iDAAiD,yFAAyF,gBAAgB,eAAe,8BAA8B,4BAA4B,iBAAiB,GAAG,yCAAyC,sBAAsB,GAAG,kDAAkD,qBAAqB,GAAG,yBAAyB,gBAAgB,iBAAiB,8BAA8B,oBAAoB,uBAAuB,GAAG,2CAA2C,uBAAuB,cAAc,eAAe,GAAG,4CAA4C,uBAAuB,cAAc,gBAAgB,iBAAiB,iBAAiB,GAAG,mDAAmD,yBAAyB,GAAG,kDAAkD,4BAA4B,8BAA8B,sBAAsB,oBAAoB,2BAA2B,wBAAwB,GAAG,uCAAuC,oBAAoB,uBAAuB,4BAA4B,8BAA8B,sBAAsB,GAAG,gDAAgD,iBAAiB,oBAAoB,GAAG,oDAAoD,kBAAkB,GAAG,6CAA6C,uBAAuB,GAAG,yCAAyC,gBAAgB,iBAAiB,oBAAoB,sBAAsB,2BAA2B,GAAG,4CAA4C,qBAAqB,GAAG,8CAA8C,qBAAqB,GAAG,kDAAkD,qBAAqB,GAAG,kDAAkD,qBAAqB,GAAG,gDAAgD,gBAAgB,qBAAqB,kBAAkB,GAAG,iGAAiG,qBAAqB,GAAG,wCAAwC,oBAAoB,sBAAsB,sBAAsB,GAAG,sDAAsD,0BAA0B,+BAA+B,oBAAoB,GAAG,oDAAoD,gBAAgB,kDAAkD,qBAAqB,4BAA4B,8BAA8B,2BAA2B,oBAAoB,sBAAsB,kBAAkB,GAAG,yDAAyD,qCAAqC,GAAG,2DAA2D,gBAAgB,qBAAqB,2BAA2B,oBAAoB,sBAAsB,kBAAkB,GAAG,6GAA6G,iBAAiB,oBAAoB,GAAG,yFAAyF,2BAA2B,GAAG,uCAAuC,mBAAmB,GAAG,uCAAuC,mBAAmB,GAAG,6EAA6E,mBAAmB,GAAG,kDAAkD,oBAAoB,kBAAkB,sBAAsB,uBAAuB,iBAAiB,eAAe,GAAG,uJAAuJ,sBAAsB,GAAG,gCAAgC,oBAAoB,GAAG,sDAAsD,gBAAgB,kCAAkC,GAAG,0KAA0K,yBAAyB,GAAG;AAC79I;AACA;;;;;;;;;;;ACNA,UAAU,mBAAO,CAAC,oJAAwE;AAC1F,0BAA0B,mBAAO,CAAC,qHAAuD;;AAEzF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA","sources":["webpack://ipysigma/./lib/custom-hover.js","webpack://ipysigma/./lib/custom-label.js","webpack://ipysigma/./lib/icons.js","webpack://ipysigma/./lib/palette.js","webpack://ipysigma/./lib/shapes.js","webpack://ipysigma/./lib/utils.js","webpack://ipysigma/./lib/version.js","webpack://ipysigma/./lib/visual-variables.js","webpack://ipysigma/./lib/widget.js","webpack://ipysigma/./css/widget.css","webpack://ipysigma/./css/widget.css?a195"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst custom_label_1 = __importDefault(require(\"./custom-label\"));\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nfunction drawHover(context, data, settings) {\n    const size = data.labelSize || settings.labelSize;\n    const font = settings.labelFont;\n    const weight = settings.labelWeight;\n    data = Object.assign(Object.assign({}, data), { label: data.label || data.hoverLabel });\n    context.font = `${weight} ${size}px ${font}`;\n    // Then we draw the label background\n    context.fillStyle = '#FFF';\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n    context.shadowBlur = 8;\n    context.shadowColor = '#000';\n    const PADDING = 2;\n    if (typeof data.label === 'string') {\n        const textWidth = context.measureText(data.label).width;\n        const boxWidth = Math.round(textWidth + 5);\n        const boxHeight = Math.round(size + 2 * PADDING);\n        const radius = Math.max(data.size, size / 2) + PADDING;\n        const angleRadian = Math.asin(boxHeight / 2 / radius);\n        const xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n        context.beginPath();\n        context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n        context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n        context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n        context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n        context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n        context.closePath();\n        context.fill();\n    }\n    else {\n        context.beginPath();\n        context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n        context.closePath();\n        context.fill();\n    }\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n    context.shadowBlur = 0;\n    // And finally we draw the label\n    (0, custom_label_1.default)(context, data, settings);\n}\nexports.default = drawHover;\n//# sourceMappingURL=custom-hover.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction drawLabel(context, data, settings) {\n    if (!data.label)\n        return;\n    const size = data.labelSize || settings.labelSize;\n    const font = settings.labelFont;\n    const weight = settings.labelWeight;\n    const color = data.labelColor || settings.labelColor.color;\n    context.fillStyle = color;\n    context.font = `${weight} ${size}px ${font}`;\n    context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\nexports.default = drawLabel;\n//# sourceMappingURL=custom-label.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scatterIcon = exports.fullscreenExitIcon = exports.fullscreenEnterIcon = exports.pauseIcon = exports.playIcon = exports.resetLayoutIcon = exports.resetZoomIcon = exports.unzoomIcon = exports.zoomIcon = void 0;\nexports.zoomIcon = `<svg width=\"20\" height=\"20\" focusable=\"false\" viewBox=\"0 0 24 24\"><path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"></path><path d=\"M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z\"></path></svg>`;\nexports.unzoomIcon = `<svg width=\"20\" height=\"20\" focusable=\"false\" viewBox=\"0 0 24 24\"><path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z\"></path></svg>`;\nexports.resetZoomIcon = `<svg width=\"20\" height=\"20\" focusable=\"false\" viewBox=\"0 0 24 24\"><path d=\"M5 15H3v4c0 1.1.9 2 2 2h4v-2H5v-4zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2V5zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2zm0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4zM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z\"></path></svg>`;\nexports.resetLayoutIcon = `<svg width=\"20\" height=\"20\" focusable=\"false\" viewBox=\"0 0 24 24\"><path d=\"M7.11 8.53 5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z\"></path></svg>`;\nexports.playIcon = `<svg width=\"20\" height=\"20\" focusable=\"false\" viewBox=\"0 0 24 24\"><path d=\"M8 5v14l11-7z\"></path></svg>`;\nexports.pauseIcon = `<svg width=\"20\" height=\"20\" focusable=\"false\" viewBox=\"0 0 24 24\"><path d=\"M6 19h4V5H6v14zm8-14v14h4V5h-4z\"></path></svg>`;\nexports.fullscreenEnterIcon = `<svg width=\"20\" height=\"20\" focusable=\"false\" viewBox=\"0 0 24 24\"><path d=\"M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z\"></path></svg>`;\nexports.fullscreenExitIcon = `<svg width=\"20\" height=\"20\" focusable=\"false\" viewBox=\"0 0 24 24\"><path d=\"M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z\"></path></svg>`;\nexports.scatterIcon = `<svg width=\"20\" height=\"20\" focusable=\"false\" viewBox=\"0 0 24 24\"><circle cx=\"7\" cy=\"14\" r=\"3\"></circle><circle cx=\"11\" cy=\"6\" r=\"3\"></circle><circle cx=\"16.6\" cy=\"17.6\" r=\"3\"></circle></svg>`;\n//# sourceMappingURL=icons.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst iwanthue_1 = __importDefault(require(\"iwanthue\"));\nconst d3Chromatic = __importStar(require(\"d3-scale-chromatic\"));\nconst shuffle_in_place_1 = require(\"pandemonium/shuffle-in-place\");\nconst seedrandom_1 = __importDefault(require(\"seedrandom\"));\nconst shapes_1 = require(\"./shapes\");\nfunction getDefaultDefaultValue(kind) {\n    if (kind === 'color')\n        return '#ccc';\n    else\n        return shapes_1.UNKNOWN_SHAPE;\n}\nclass Palette {\n    constructor(name, kind, map, defaultValue) {\n        this.name = name;\n        this.kind = kind;\n        this.map = map;\n        this.defaultValue = defaultValue;\n        this.size = this.map.size;\n    }\n    get(key) {\n        const value = this.map.get(key);\n        if (value === undefined)\n            return this.defaultValue;\n        return value;\n    }\n    forEach(callback) {\n        this.map.forEach(callback);\n    }\n    static getMacroDefault(kind) {\n        if (kind === 'color')\n            return '#ccc';\n        else\n            return shapes_1.UNKNOWN_SHAPE;\n    }\n    static fromScheme(name, kind, scheme, values, defaultValue) {\n        const target = d3Chromatic['scheme' + scheme];\n        let colors;\n        if (Array.isArray(target[target.length - 1])) {\n            const firstValidCount = target.findIndex((c) => Array.isArray(c));\n            colors = target[Math.min(Math.max(firstValidCount, values.length), target.length)];\n        }\n        else {\n            colors = target.slice();\n            const shuffleInPlace = (0, shuffle_in_place_1.createShuffleInPlace)((0, seedrandom_1.default)(name));\n            shuffleInPlace(colors);\n            colors = colors.slice(0, Math.min(values.length, colors.length));\n        }\n        const map = new Map();\n        values.slice(0, colors.length).forEach((v, i) => {\n            map.set(v, colors[i]);\n        });\n        return new Palette(name, kind, map, defaultValue || getDefaultDefaultValue(kind));\n    }\n    static fromEntries(name, kind, entries, defaultValue) {\n        return new Palette(name, kind, new Map(entries), defaultValue || getDefaultDefaultValue(kind));\n    }\n    static generateFromValues(name, kind, values, defaultValue) {\n        if (kind === 'color') {\n            const settings = {\n                colorSpace: 'sensible',\n                seed: name,\n                clustering: 'force-vector',\n                attempts: 5,\n            };\n            if (values.length === 0)\n                return new Palette(name, kind, new Map(), defaultValue || getDefaultDefaultValue(kind));\n            const colors = (0, iwanthue_1.default)(values.length, settings);\n            const map = new Map();\n            values.forEach((v, i) => {\n                map.set(v, colors[i]);\n            });\n            return new Palette(name, kind, map, defaultValue || getDefaultDefaultValue(kind));\n        }\n        else {\n            const map = new Map();\n            shapes_1.USEFUL_SHAPES.slice(0, Math.min(values.length, shapes_1.USEFUL_SHAPES.length)).forEach((shape, i) => {\n                map.set(values[i], shape.name);\n            });\n            return new Palette(name, kind, map, defaultValue || getDefaultDefaultValue(kind));\n        }\n    }\n}\nexports.default = Palette;\n//# sourceMappingURL=palette.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shapeToPicto = exports.UNKNOWN_SHAPE = exports.USEFUL_SHAPES = void 0;\nexports.USEFUL_SHAPES = [\n    { name: 'circle', pictogram: 'circle' },\n    { name: 'triangle', pictogram: 'change_history' },\n    { name: 'square', pictogram: 'square' },\n    { name: 'pentagon', pictogram: 'pentagon' },\n    { name: 'star', pictogram: 'star' },\n    { name: 'hexagon', pictogram: 'hexagon' },\n    { name: 'heart', pictogram: 'favorite' },\n    { name: 'cloud', pictogram: 'cloudy' },\n];\nexports.UNKNOWN_SHAPE = 'help';\nconst SHAPES_MAP = new Map();\nexports.USEFUL_SHAPES.forEach(({ name, pictogram }) => {\n    SHAPES_MAP.set(name, pictogram);\n});\nfunction shapeToPicto(shape) {\n    return SHAPES_MAP.get(shape) || shape;\n}\nexports.shapeToPicto = shapeToPicto;\n//# sourceMappingURL=shapes.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pictogramToUrl = exports.saveAsSVG = exports.saveAsGEXF = exports.saveAsJSON = exports.saveAsPNG = exports.renderAsDataURL = void 0;\nconst sigma_1 = __importDefault(require(\"sigma\"));\nconst file_saver_1 = __importDefault(require(\"file-saver\"));\nconst gexf = __importStar(require(\"graphology-gexf/browser\"));\n// @ts-ignore\nconst renderer_1 = __importDefault(require(\"graphology-svg/renderer\"));\n// @ts-ignore\nconst defaults_1 = require(\"graphology-svg/defaults\");\n// Taken and adapted from: https://github.com/jacomyal/sigma.js/blob/main/examples/png-snapshot/saveAsPNG.ts\nfunction renderToAuxiliaryCanvas(renderer, inputLayers) {\n    const { width, height } = renderer.getDimensions();\n    // This pixel ratio is here to deal with retina displays.\n    // Indeed, for dimensions W and H, on a retina display, the canvases\n    // dimensions actually are 2 * W and 2 * H. Sigma properly deals with it, but\n    // we need to readapt here:\n    const pixelRatio = window.devicePixelRatio || 1;\n    const tmpRoot = document.createElement('DIV');\n    tmpRoot.style.width = `${width}px`;\n    tmpRoot.style.height = `${height}px`;\n    tmpRoot.style.position = 'absolute';\n    tmpRoot.style.right = '101%';\n    tmpRoot.style.bottom = '101%';\n    document.body.appendChild(tmpRoot);\n    // Instantiate sigma:\n    const tmpRenderer = new sigma_1.default(renderer.getGraph(), tmpRoot, renderer.getSettings());\n    // Copy camera and force to render now, to avoid having to wait the schedule /\n    // debounce frame:\n    tmpRenderer.getCamera().setState(renderer.getCamera().getState());\n    tmpRenderer.refresh();\n    // Create a new canvas, on which the different layers will be drawn:\n    const canvas = document.createElement('CANVAS');\n    canvas.setAttribute('width', width * pixelRatio + '');\n    canvas.setAttribute('height', height * pixelRatio + '');\n    const ctx = canvas.getContext('2d');\n    // Draw a white background first:\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0, 0, width * pixelRatio, height * pixelRatio);\n    // For each layer, draw it on our canvas:\n    const canvases = tmpRenderer.getCanvases();\n    const layers = inputLayers\n        ? inputLayers.filter((id) => !!canvases[id])\n        : Object.keys(canvases);\n    layers.forEach((id) => {\n        ctx.drawImage(canvases[id], 0, 0, width * pixelRatio, height * pixelRatio, 0, 0, width * pixelRatio, height * pixelRatio);\n    });\n    return [\n        canvas,\n        () => {\n            // Cleanup:\n            tmpRenderer.kill();\n            tmpRoot.remove();\n        },\n    ];\n}\nfunction copyGraphForGexf(renderer) {\n    const original = renderer.getGraph();\n    const copy = original.copy();\n    copy.updateEachNodeAttributes((node, attr) => {\n        const displayData = renderer.getNodeDisplayData(node);\n        const { x, y } = renderer.graphToViewport(displayData);\n        return Object.assign(Object.assign({}, attr), { color: displayData.color, size: displayData.size, x,\n            y });\n    });\n    copy.updateEachEdgeAttributes((edge, attr) => {\n        const displayData = renderer.getEdgeDisplayData(edge);\n        return Object.assign(Object.assign({}, attr), { color: displayData.color, size: displayData.size });\n    });\n    return copy;\n}\nfunction renderAsDataURL(renderer) {\n    const [canvas, cleanup] = renderToAuxiliaryCanvas(renderer);\n    const dataURL = canvas.toDataURL();\n    cleanup();\n    return dataURL;\n}\nexports.renderAsDataURL = renderAsDataURL;\nfunction saveAsPNG(renderer) {\n    const [canvas, cleanup] = renderToAuxiliaryCanvas(renderer);\n    // Save the canvas as a PNG image:\n    canvas.toBlob((blob) => {\n        if (blob)\n            file_saver_1.default.saveAs(blob, 'graph.png');\n        cleanup();\n    }, 'image/png');\n}\nexports.saveAsPNG = saveAsPNG;\nfunction saveAsJSON(renderer) {\n    const data = JSON.stringify(renderer.getGraph(), null, 2);\n    file_saver_1.default.saveAs(new Blob([data], { type: 'application/json' }), 'graph.json');\n}\nexports.saveAsJSON = saveAsJSON;\nfunction saveAsGEXF(renderer) {\n    const data = gexf.write(copyGraphForGexf(renderer));\n    file_saver_1.default.saveAs(new Blob([data], { type: 'application/xml' }), 'graph.gexf');\n}\nexports.saveAsGEXF = saveAsGEXF;\nfunction saveAsSVG(renderer) {\n    const rendererSettings = renderer.getSettings();\n    const settings = Object.assign({}, defaults_1.DEFAULTS);\n    settings.nodes = {\n        // @ts-ignore\n        reducer: (_, n, a) => rendererSettings.nodeReducer(n, a),\n        defaultColor: rendererSettings.defaultNodeColor,\n    };\n    settings.edges = {\n        // @ts-ignore\n        reducer: (_, e, a) => rendererSettings.edgeReducer(e, a),\n        defaultColor: rendererSettings.defaultEdgeColor,\n    };\n    const data = (0, renderer_1.default)(renderer.getGraph(), settings);\n    file_saver_1.default.saveAs(new Blob([data], { type: 'image/svg+xml' }), 'graph.svg');\n}\nexports.saveAsSVG = saveAsSVG;\nfunction pictogramToUrl(picto, qualifier = 'default') {\n    if (picto.startsWith('http'))\n        return picto;\n    return `https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/${picto}/${qualifier}/48px.svg`;\n}\nexports.pictogramToUrl = pictogramToUrl;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MODULE_NAME = exports.MODULE_VERSION = void 0;\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst data = require('../package.json');\n/**\n * The _model_module_version/_view_module_version this package implements.\n *\n * The html widget manager assumes that this is the same as the npm package\n * version number.\n */\nexports.MODULE_VERSION = data.version;\n/*\n * The current package name.\n */\nexports.MODULE_NAME = data.name;\n//# sourceMappingURL=version.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VisualVariableScalesBuilder = exports.CategorySummary = exports.AttributeCategories = exports.AttributeExtents = exports.Extent = void 0;\nconst multi_set_1 = __importDefault(require(\"mnemonist/multi-set\"));\nconst palette_1 = __importDefault(require(\"./palette\"));\nconst d3_scale_1 = require(\"d3-scale\");\nconst d3Chromatic = __importStar(require(\"d3-scale-chromatic\"));\n/**\n * Constants.\n */\nconst MAX_CATEGORICAL_COLORS = 10;\nconst DEFAULT_DEFAULT_CONTINUOUS_NUMERICAL_VALUE = 1;\nconst DEFAULT_DEFAULT_CONTINUOUS_COLOR_VALUE = 'black';\nconst ESPILON = 1e-8;\n/**\n * Helper functions.\n */\nfunction isValidNumber(value) {\n    return (typeof value === 'number' &&\n        !Number.isNaN(value) &&\n        value !== Infinity &&\n        value !== -Infinity);\n}\nfunction rangeIsConstant(range) {\n    if (!Array.isArray(range))\n        return false;\n    if (typeof range[0] === 'string')\n        return range[0] === range[1];\n    return Math.abs(range[0] - range[1]) <= ESPILON;\n}\nfunction getContinuousDefaultValue(variable) {\n    if (typeof variable.range === 'string' ||\n        typeof variable.range[0] === 'string') {\n        // Color\n        if (typeof variable.default === 'string')\n            return variable.default;\n        if (Array.isArray(variable.range) && typeof variable.range[0] === 'string')\n            return variable.range[0];\n        return DEFAULT_DEFAULT_CONTINUOUS_COLOR_VALUE;\n    }\n    else {\n        // Size\n        if (isValidNumber(variable.default))\n            return variable.default;\n        if (Array.isArray(variable.range) && isValidNumber(variable.range[0]))\n            return variable.range[0];\n        return DEFAULT_DEFAULT_CONTINUOUS_NUMERICAL_VALUE;\n    }\n}\nfunction createContinuousScale(variable, extent) {\n    const defaultValue = getContinuousDefaultValue(variable);\n    if (rangeIsConstant(variable.range) || extent.isConstant()) {\n        return () => defaultValue;\n    }\n    let scale;\n    const definition = variable.scale;\n    let isLogPlusOne = false;\n    if (!definition)\n        scale = (0, d3_scale_1.scaleLinear)();\n    else {\n        const [type, param] = definition;\n        if (type === 'lin')\n            scale = (0, d3_scale_1.scaleLinear)();\n        else if (type === 'log' || type === 'log+1') {\n            isLogPlusOne = type === 'log+1';\n            scale = (0, d3_scale_1.scaleLog)();\n            if (param)\n                scale.base(param);\n        }\n        else if (type === 'pow') {\n            scale = (0, d3_scale_1.scalePow)();\n            scale.exponent(param ? param : 2);\n        }\n        else if (type === 'sqrt') {\n            scale = (0, d3_scale_1.scaleSqrt)();\n            if (param)\n                scale.exponent(1 / param);\n        }\n        else\n            throw new Error('unknown scale type');\n    }\n    const offset = isLogPlusOne ? 1 : 0;\n    scale.domain([extent.min + offset, extent.max + offset]);\n    if (typeof variable.range === 'string') {\n        const chromatic = d3Chromatic['interpolate' + variable.range];\n        return (attr) => {\n            let value = attr[variable.attribute];\n            if (!isValidNumber(value))\n                return defaultValue;\n            value += offset;\n            return chromatic(scale(value));\n        };\n    }\n    else if (variable.range) {\n        scale.range(variable.range);\n        return (attr) => {\n            let value = attr[variable.attribute];\n            if (!isValidNumber(value))\n                return defaultValue;\n            value += offset;\n            return scale(value);\n        };\n    }\n    throw new Error('could not create valid continuous scale');\n}\n/**\n * Helper classes.\n */\nclass Extent {\n    constructor() {\n        this.min = Infinity;\n        this.max = -Infinity;\n    }\n    add(value) {\n        if (value < this.min)\n            this.min = value;\n        if (value > this.max)\n            this.max = value;\n    }\n    isConstant() {\n        return this.min === Infinity || this.min === this.max;\n    }\n}\nexports.Extent = Extent;\nclass AttributeExtents {\n    constructor(names) {\n        this.attributes = {};\n        // NOTE: this naturally deduplicates names\n        names.forEach((name) => (this.attributes[name] = new Extent()));\n    }\n    add(attributes) {\n        for (const name in this.attributes) {\n            const value = attributes[name];\n            if (!isValidNumber(value))\n                continue;\n            this.attributes[name].add(value);\n        }\n    }\n}\nexports.AttributeExtents = AttributeExtents;\nclass AttributeCategories {\n    constructor(names) {\n        this.attributes = {};\n        // NOTE: this naturally deduplicates names\n        names.forEach((name) => (this.attributes[name] = new multi_set_1.default()));\n    }\n    add(attributes) {\n        for (const name in this.attributes) {\n            this.attributes[name].add(attributes[name]);\n        }\n    }\n}\nexports.AttributeCategories = AttributeCategories;\nclass CategorySummary {\n    constructor(name, kind, palette, overflowing = false) {\n        this.name = name;\n        this.kind = kind;\n        this.palette = palette;\n        this.overflowing = overflowing;\n    }\n    static fromTopValues(name, kind, frequencies, defaultValue, scheme, maxCount = MAX_CATEGORICAL_COLORS) {\n        const count = Math.min(maxCount, frequencies.dimension);\n        const topValues = frequencies.top(count);\n        const overflowing = count < frequencies.dimension;\n        const values = topValues.map((item) => item[0]);\n        const palette = !scheme || scheme === 'IWantHue'\n            ? palette_1.default.generateFromValues(name, kind, values, defaultValue)\n            : palette_1.default.fromScheme(name, kind, scheme, values, defaultValue);\n        return new CategorySummary(name, kind, palette, overflowing);\n    }\n    static fromEntries(name, kind, entries, defaultValue) {\n        const palette = palette_1.default.fromEntries(name, kind, entries, defaultValue);\n        return new CategorySummary(name, kind, palette);\n    }\n}\nexports.CategorySummary = CategorySummary;\nclass VisualVariableScalesBuilder {\n    constructor(visualVariables, maxCategories = MAX_CATEGORICAL_COLORS) {\n        this.variables = visualVariables;\n        this.maxCategories = maxCategories;\n        const nodeExtentAttributes = [];\n        const nodeCategoryAttributes = [];\n        const edgeExtentAttributes = [];\n        const edgeCategoryAttributes = [];\n        for (const variableName in visualVariables) {\n            const variable = visualVariables[variableName];\n            if (variableName.startsWith('node')) {\n                if (variable.type === 'category') {\n                    if (!variable.palette || typeof variable.palette === 'string')\n                        nodeCategoryAttributes.push(variable.attribute);\n                }\n                else if (variable.type === 'continuous' ||\n                    variableName === 'nodeSize') {\n                    nodeExtentAttributes.push(variable.attribute);\n                }\n            }\n            else if (variableName.startsWith('edge')) {\n                if (variable.type === 'category') {\n                    if (!variable.palette || typeof variable.palette === 'string')\n                        edgeCategoryAttributes.push(variable.attribute);\n                }\n                else if (variable.type === 'continuous') {\n                    edgeExtentAttributes.push(variable.attribute);\n                }\n            }\n        }\n        this.nodeExtents = new AttributeExtents(nodeExtentAttributes);\n        this.edgeExtents = new AttributeExtents(edgeExtentAttributes);\n        this.nodeCategories = new AttributeCategories(nodeCategoryAttributes);\n        this.edgeCategories = new AttributeCategories(edgeCategoryAttributes);\n    }\n    readGraph(graph) {\n        graph.forEachNode((node, attr) => {\n            this.nodeExtents.add(attr);\n            this.nodeCategories.add(attr);\n        });\n        graph.forEachEdge((edge, attr) => {\n            this.edgeExtents.add(attr);\n            this.edgeCategories.add(attr);\n        });\n    }\n    build() {\n        const scales = {};\n        for (const variableName in this.variables) {\n            const variable = this.variables[variableName];\n            let scale = null;\n            // Raw variables\n            if (variable.type === 'raw') {\n                scale = (attr) => attr[variable.attribute] || variable.default;\n            }\n            // Constant variables\n            else if (variable.type === 'constant') {\n                scale = () => variable.default;\n            }\n            // Category variables\n            else if (variable.type === 'category') {\n                const categories = variableName.startsWith('node')\n                    ? this.nodeCategories\n                    : this.edgeCategories;\n                const summary = variable.palette && typeof variable.palette !== 'string'\n                    ? CategorySummary.fromEntries(variable.attribute, variable.kind || 'color', variable.palette, variable.default)\n                    : CategorySummary.fromTopValues(variable.attribute, variable.kind || 'color', categories.attributes[variable.attribute], variable.default, variable.palette, this.maxCategories);\n                const palette = summary.palette;\n                scale = (attr) => palette.get(attr[variable.attribute]);\n                scale.summary = summary;\n            }\n            // Continuous variables\n            else if (variable.type === 'continuous') {\n                const extents = variableName.startsWith('node')\n                    ? this.nodeExtents\n                    : this.edgeExtents;\n                const extent = extents.attributes[variable.attribute];\n                scale = createContinuousScale(variable, extent);\n            }\n            if (scale)\n                scales[variableName] = scale;\n        }\n        return scales;\n    }\n    inferLabelRenderedSizeThreshold() {\n        const variable = this.variables.nodeSize;\n        if (variable.type === 'continuous') {\n            const range = variable.range;\n            return Math.min(6, range[0]);\n        }\n        return 6;\n    }\n}\nexports.VisualVariableScalesBuilder = VisualVariableScalesBuilder;\n//# sourceMappingURL=visual-variables.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SigmaView = exports.SigmaModel = void 0;\nconst base_1 = require(\"@jupyter-widgets/base\");\nconst graphology_1 = __importDefault(require(\"graphology\"));\nconst worker_1 = __importDefault(require(\"graphology-layout-forceatlas2/worker\"));\nconst worker_2 = __importDefault(require(\"graphology-layout-noverlap/worker\"));\nconst graphology_layout_forceatlas2_1 = __importDefault(require(\"graphology-layout-forceatlas2\"));\nconst graphology_communities_louvain_1 = __importDefault(require(\"graphology-communities-louvain\"));\nconst utils_1 = require(\"graphology-layout/utils\");\nconst chroma_js_1 = __importDefault(require(\"chroma-js\"));\nconst sigma_1 = __importDefault(require(\"sigma\"));\nconst animate_1 = require(\"sigma/utils/animate\");\nconst node_1 = require(\"sigma/rendering/webgl/programs/common/node\");\nconst node_point_1 = __importDefault(require(\"sigma/rendering/webgl/programs/node.point\"));\nconst node_point_border_1 = __importDefault(require(\"@yomguithereal/sigma-experiments-renderers/node/node.point.border\"));\nconst node_halo_1 = __importDefault(require(\"@yomguithereal/sigma-experiments-renderers/node/node.halo\"));\nconst node_pictogram_1 = __importDefault(require(\"@yomguithereal/sigma-experiments-renderers/node/node.pictogram\"));\nconst edge_line_1 = __importDefault(require(\"sigma/rendering/webgl/programs/edge.line\"));\nconst edge_rectangle_1 = __importDefault(require(\"sigma/rendering/webgl/programs/edge.rectangle\"));\nconst edge_triangle_1 = __importDefault(require(\"sigma/rendering/webgl/programs/edge.triangle\"));\nconst edge_curve_1 = __importDefault(require(\"@yomguithereal/sigma-experiments-renderers/edge/edge.curve\"));\nconst events_1 = __importDefault(require(\"events\"));\nconst seedrandom_1 = __importDefault(require(\"seedrandom\"));\nconst comma_number_1 = __importDefault(require(\"comma-number\"));\nconst choices_js_1 = __importDefault(require(\"choices.js\"));\nconst screenfull_1 = __importDefault(require(\"screenfull\"));\nconst debounce_1 = __importDefault(require(\"debounce\"));\nconst version_1 = require(\"./version\");\nconst custom_hover_1 = __importDefault(require(\"./custom-hover\"));\nconst custom_label_1 = __importDefault(require(\"./custom-label\"));\nconst visual_variables_1 = require(\"./visual-variables\");\nconst utils_2 = require(\"./utils\");\nconst shapes_1 = require(\"./shapes\");\nconst icons_1 = require(\"./icons\");\nrequire(\"choices.js/public/assets/styles/choices.min.css\");\nrequire(\"../css/widget.css\");\n/**\n * Constants.\n */\nconst NODE_VIZ_ATTRIBUTES = new Set(['label', 'size', 'color', 'x', 'y']);\nconst EDGE_VIZ_ATTRIBUTES = new Set(['label', 'size', 'color']);\nconst MUTED_NODE_COLOR = '#ccc';\nconst IPYSIGMA_KWARG_PREFIX = 'ipysigma_kwarg_';\n/**\n * Template.\n */\nconst TEMPLATE = `\n<div class=\"ipysigma-container\"></div>\n<div class=\"ipysigma-left-panel\">\n  <div class=\"ipysigma-graph-description\"></div>\n  <div>\n    <button class=\"ipysigma-zoom-button ipysigma-button ipysigma-svg-icon\" title=\"zoom\">\n      ${icons_1.zoomIcon}\n    </button>\n    <button class=\"ipysigma-unzoom-button ipysigma-button ipysigma-svg-icon\" title=\"unzoom\">\n      ${icons_1.unzoomIcon}\n    </button>\n    <button class=\"ipysigma-reset-zoom-button ipysigma-button ipysigma-svg-icon\" title=\"reset zoom\">\n      ${icons_1.resetZoomIcon}\n    </button>\n  </div>\n  <div>\n    <button class=\"ipysigma-fullscreen-button ipysigma-button ipysigma-svg-icon\" title=\"enter fullscreen\">\n      ${icons_1.fullscreenEnterIcon}\n    </button>\n  </div>\n  <div class=\"ipysigma-layout-controls\">\n    <button class=\"ipysigma-layout-button ipysigma-button ipysigma-svg-icon\" title=\"start layout\">\n      ${icons_1.playIcon}\n    </button>\n    <button class=\"ipysigma-noverlap-button ipysigma-button ipysigma-svg-icon\" title=\"spread nodes\">\n      ${icons_1.scatterIcon}\n    </button>\n    <button class=\"ipysigma-reset-layout-button ipysigma-button ipysigma-svg-icon\" title=\"reset layout\">\n      ${icons_1.resetLayoutIcon}\n    </button>\n  </div>\n</div>\n<div class=\"ipysigma-right-panel\">\n  <select class=\"ipysigma-search\">\n    <option value=\"\">Search a node...</option>\n  </select>\n  <div class=\"ipysigma-information-shadow-display\" style=\"display: none;\">\n    <span class=\"ipysigma-information-show-button\">show info</span>\n  </div>\n  <div class=\"ipysigma-information-display\">\n    <div class=\"ipysigma-information-display-tabs\">\n      <span class=\"ipysigma-information-legend-button ipysigma-tab-button\">legend</span>\n      &middot;\n      <span class=\"ipysigma-information-info-button ipysigma-tab-button\">info</span>\n      <span class=\"ipysigma-information-hide-button\">hide</span>\n    </div>\n    <hr>\n    <div class=\"ipysigma-legend\"></div>\n    <div class=\"ipysigma-information-contents\"></div>\n  </div>\n  <div class=\"ipysigma-download-controls\">\n    <button class=\"ipysigma-download-png-button ipysigma-button\">\n      png\n    </button>\n    <button class=\"ipysigma-download-svg-button ipysigma-button\">\n      svg\n    </button>\n    <button class=\"ipysigma-download-gexf-button ipysigma-button\">\n      gexf\n    </button>\n    <button class=\"ipysigma-download-json-button ipysigma-button\">\n      json\n    </button>\n  </div>\n</div>\n`;\n/**\n * Model declaration.\n */\nclass SigmaModel extends base_1.DOMWidgetModel {\n    defaults() {\n        return Object.assign(Object.assign({}, super.defaults()), { _model_name: SigmaModel.model_name, _model_module: SigmaModel.model_module, _model_module_version: SigmaModel.model_module_version, _view_name: SigmaModel.view_name, _view_module: SigmaModel.view_module, _view_module_version: SigmaModel.view_module_version, data: { nodes: [], edges: [] }, height: 500, start_layout: false, snapshot: null, layout: null, clickableEdges: false, visual_variables: {} });\n    }\n}\nexports.SigmaModel = SigmaModel;\nSigmaModel.serializers = Object.assign({}, base_1.DOMWidgetModel.serializers);\nSigmaModel.model_name = 'SigmaModel';\nSigmaModel.model_module = version_1.MODULE_NAME;\nSigmaModel.model_module_version = version_1.MODULE_VERSION;\nSigmaModel.view_name = 'SigmaView'; // Set to null if no view\nSigmaModel.view_module = version_1.MODULE_NAME; // Set to null if no view\nSigmaModel.view_module_version = version_1.MODULE_VERSION;\n/**\n * Helper functions.\n */\nfunction createRng() {\n    return (0, seedrandom_1.default)('ipysigma');\n}\nfunction isValidNumber(value) {\n    return typeof value === 'number' && !isNaN(value);\n}\nfunction escapeHtml(unsafe) {\n    return ('' + unsafe)\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#039;');\n}\nfunction renderTypedValue(value) {\n    let safe = escapeHtml('' + value);\n    let type = 'unknown';\n    if (typeof value === 'number') {\n        type = 'number';\n    }\n    else if (typeof value === 'string') {\n        type = 'string';\n    }\n    else if (typeof value === 'boolean') {\n        type = 'boolean';\n        safe = value ? 'True' : 'False';\n    }\n    else if (value === null) {\n        type = 'keyword';\n        safe = 'null';\n    }\n    return `<span class=\"ipysigma-${type}\" title=\"${type}\">${safe}</span>`;\n}\nfunction buildGraph(data, rng) {\n    const graph = graphology_1.default.from(data);\n    // Rectifications\n    graph.updateEachNodeAttributes((key, attr) => {\n        // Random position for nodes without positions\n        if (!isValidNumber(attr.x))\n            attr.x = rng();\n        if (!isValidNumber(attr.y))\n            attr.y = rng();\n        return attr;\n    });\n    return graph;\n}\nfunction createElement(tag, options) {\n    const element = document.createElement(tag);\n    const { className, style, innerHTML, title } = options || {};\n    if (className)\n        element.setAttribute('class', className);\n    for (const prop in style) {\n        element.style[prop] = style[prop];\n    }\n    if (innerHTML)\n        element.innerHTML = innerHTML;\n    if (title)\n        element.setAttribute('title', title);\n    return element;\n}\nfunction hide(el) {\n    el.style.display = 'none';\n}\nfunction show(el) {\n    el.style.display = 'block';\n}\nfunction disable(el) {\n    el.classList.add('disabled');\n    el.disabled = true;\n}\nfunction enable(el) {\n    el.classList.remove('disabled');\n    el.disabled = false;\n}\nconst SPINNER_STATES = ['⣾', '⣽', '⣻', '⢿', '⡿', '⣟', '⣯', '⣷'];\nfunction createSpinner() {\n    const span = createElement('span', {\n        className: 'ipysigma-spinner',\n        innerHTML: SPINNER_STATES[0],\n    });\n    let state = -1;\n    let frame = null;\n    const update = () => {\n        state++;\n        state %= SPINNER_STATES.length;\n        span.innerHTML = SPINNER_STATES[state];\n        frame = setTimeout(update, 80);\n    };\n    update();\n    return [span, () => frame !== null && clearTimeout(frame)];\n}\nfunction getGraphDescription(name, graph) {\n    let html = '';\n    if (name) {\n        html += `<u>${escapeHtml(name)}</u><br>`;\n    }\n    const graphTitle = `${graph.multi ? 'Multi ' : ''}${graph.type === 'undirected' ? 'Undirected' : 'Directed'} Graph`;\n    html += `${graphTitle}<br><b>${(0, comma_number_1.default)(graph.order)}</b> nodes<br><b>${(0, comma_number_1.default)(graph.size)}</b> edges`;\n    return html;\n}\nconst SYNC_REGISTRY = new Map();\n/**\n * View declaration.\n */\nclass SigmaView extends base_1.DOMWidgetView {\n    constructor() {\n        super(...arguments);\n        this.emitter = new events_1.default();\n        this.edgeWeightAttribute = null;\n        this.syncHoveredNode = null;\n        this.syncListeners = {};\n        this.layoutSpinner = null;\n        this.currentTab = 'legend';\n        this.isInformationShown = true;\n        this.selectedNode = null;\n        this.selectedEdge = null;\n        this.focusedNodes = null;\n        this.selectedNodeCategoryValues = null;\n        this.selectedEdgeCategoryValues = null;\n    }\n    render() {\n        super.render();\n        this.el.classList.add('ipysigma-widget');\n        const height = this.model.get('height');\n        const backgroundColor = this.model.get('background_color');\n        const name = this.model.get('name');\n        const data = this.model.get('data');\n        this.el.style.backgroundColor = backgroundColor;\n        const graph = buildGraph(data, createRng());\n        this.graph = graph;\n        // Preexisting layout?\n        const preexistingLayout = this.model.get('layout');\n        if (preexistingLayout) {\n            (0, utils_1.assignLayout)(graph, preexistingLayout);\n        }\n        else {\n            this.saveLayout();\n        }\n        this.originalLayoutPositions = (0, utils_1.collectLayout)(graph);\n        // Selection state\n        const selectedNodeCategoryValues = this.model.get('selected_node_category_values');\n        const selectedEdgeCategoryValues = this.model.get('selected_edge_category_values');\n        if (selectedNodeCategoryValues)\n            this.selectedNodeCategoryValues = new Set(selectedNodeCategoryValues);\n        if (selectedEdgeCategoryValues)\n            this.selectedEdgeCategoryValues = new Set(selectedEdgeCategoryValues);\n        // Widget-side metrics\n        this.edgeWeightAttribute = this.model.get('edge_weight');\n        let nodeMetrics = this.model.get('node_metrics') || {};\n        // NOTE: for some untractable reason, I need a completly new deep object\n        nodeMetrics = JSON.parse(JSON.stringify(nodeMetrics));\n        for (const attrName in nodeMetrics) {\n            const metricSpec = nodeMetrics[attrName];\n            const metric = metricSpec.name;\n            if (metric === 'louvain') {\n                const communities = (0, graphology_communities_louvain_1.default)(graph, {\n                    getEdgeWeight: this.edgeWeightAttribute,\n                    rng: createRng(),\n                    resolution: metricSpec.resolution || 1,\n                });\n                metricSpec.result = communities;\n                graph.updateEachNodeAttributes((node, attr) => {\n                    attr[attrName] = communities[node];\n                    return attr;\n                }, { attributes: [attrName] });\n            }\n            else {\n                throw new Error(`unkown metric \"${metric}\"` + metric);\n            }\n        }\n        this.model.set('node_metrics', nodeMetrics);\n        this.touch();\n        this.el.insertAdjacentHTML('beforeend', TEMPLATE);\n        this.el.style.width = '100%';\n        this.el.style.height = height;\n        this.container = this.el.querySelector('.ipysigma-container');\n        this.container.style.width = '100%';\n        this.container.style.height = height;\n        // Description\n        const description = this.el.querySelector('.ipysigma-graph-description');\n        description.innerHTML = getGraphDescription(name, graph);\n        // Camera controls\n        this.zoomButton = this.el.querySelector('.ipysigma-zoom-button');\n        this.unzoomButton = this.el.querySelector('.ipysigma-unzoom-button');\n        this.resetZoomButton = this.el.querySelector('.ipysigma-reset-zoom-button');\n        // Fullscreen controls\n        this.fullscreenButton = this.el.querySelector('.ipysigma-fullscreen-button');\n        // Layout controls\n        this.layoutControls = this.el.querySelector('.ipysigma-layout-controls');\n        this.layoutButton = this.el.querySelector('.ipysigma-layout-button');\n        this.noverlapButton = this.el.querySelector('.ipysigma-noverlap-button');\n        this.resetLayoutButton = this.el.querySelector('.ipysigma-reset-layout-button');\n        // Search\n        var searchContainer = this.el.querySelector('.ipysigma-search');\n        const nodeLabelAttribute = this.model.get('visual_variables').nodeLabel.attribute;\n        const options = graph.mapNodes((key, attr) => {\n            let labelParts = [escapeHtml(key)];\n            const label = attr[nodeLabelAttribute];\n            if (label && label !== key) {\n                labelParts.push(` <small style=\"font-size: 75%;\">${escapeHtml(label)}</small>`);\n            }\n            return { value: key, label: labelParts.join(' ') };\n        });\n        this.choices = new choices_js_1.default(searchContainer, {\n            allowHTML: true,\n            removeItemButton: true,\n            renderChoiceLimit: 10,\n            choices: options,\n            itemSelectText: '',\n            position: 'bottom',\n        });\n        this.informationDisplayElement = this.el.querySelector('.ipysigma-information-display');\n        this.informationShadowDisplayElement = this.el.querySelector('.ipysigma-information-shadow-display');\n        this.itemInfoElement = this.el.querySelector('.ipysigma-information-contents');\n        this.legendElement = this.el.querySelector('.ipysigma-legend');\n        this.nodeInfoButton = this.el.querySelector('.ipysigma-information-info-button');\n        this.legendButton = this.el.querySelector('.ipysigma-information-legend-button');\n        this.hideInformationButton = this.el.querySelector('.ipysigma-information-hide-button');\n        this.showInformationButton = this.el.querySelector('.ipysigma-information-show-button');\n        this.changeInformationDisplayTab('legend');\n        // Download controls\n        this.downloadPNGButton = this.el.querySelector('.ipysigma-download-png-button');\n        this.downloadGEXFButton = this.el.querySelector('.ipysigma-download-gexf-button');\n        this.downloadSVGButton = this.el.querySelector('.ipysigma-download-svg-button');\n        this.downloadJSONButton = this.el.querySelector('.ipysigma-download-json-button');\n        // Waiting for widget to be mounted to register events\n        this.displayed.then(() => {\n            // const programSettings = this.model.get(\n            //   'program_settings'\n            // ) as IPysigmaProgramSettings;\n            var _a, _b, _c;\n            const visualVariables = this.model.get('visual_variables');\n            const nodeColorSaturationEnabled = visualVariables.nodeColorSaturation.type !== 'disabled';\n            const nodeBordersEnabled = visualVariables.nodeBorderColor.type !== 'disabled' &&\n                (visualVariables.nodeBorderSize.type !== 'disabled' ||\n                    visualVariables.nodeBorderRatio.type !== 'disabled');\n            const nodePictogramsEnabled = visualVariables.nodePictogram.type !== 'disabled';\n            const nodeShapeEnabled = visualVariables.nodeShape.type !== 'disabled';\n            const nodeHaloEnabled = visualVariables.nodeHaloSize.type !== 'disabled' &&\n                visualVariables.nodeHaloColor.type !== 'disabled';\n            const edgeProgramClasses = {\n                rectangle: edge_rectangle_1.default,\n                line: edge_line_1.default,\n                triangle: edge_triangle_1.default,\n                curve: edge_curve_1.default,\n            };\n            const NodePictogramProgram = (0, node_pictogram_1.default)({\n                correctCentering: true,\n                forcedSvgSize: 384,\n                keepWithinCircle: true,\n            });\n            const NodeShapeProgram = (0, node_pictogram_1.default)({\n                correctCentering: true,\n                forcedSvgSize: 384,\n                keepWithinCircle: false,\n            });\n            const nodeProgramClasses = {\n                point: node_point_1.default,\n                halo: (0, node_1.createNodeCompoundProgram)([node_halo_1.default, node_point_1.default]),\n                border: node_point_border_1.default,\n                picto: (0, node_1.createNodeCompoundProgram)([\n                    node_point_1.default,\n                    NodePictogramProgram,\n                ]),\n                shape: NodeShapeProgram,\n                'border+picto': (0, node_1.createNodeCompoundProgram)([\n                    node_point_border_1.default,\n                    NodePictogramProgram,\n                ]),\n                'border+halo': (0, node_1.createNodeCompoundProgram)([\n                    node_halo_1.default,\n                    node_point_border_1.default,\n                ]),\n                'border+halo+picto': (0, node_1.createNodeCompoundProgram)([\n                    node_halo_1.default,\n                    node_point_border_1.default,\n                    NodePictogramProgram,\n                ]),\n                'halo+picto': (0, node_1.createNodeCompoundProgram)([\n                    node_halo_1.default,\n                    node_point_1.default,\n                    NodePictogramProgram,\n                ]),\n            };\n            const nodeHoverProgramClasses = {\n                halo: node_point_1.default,\n                'border+halo': node_point_border_1.default,\n                'border+halo+picto': (0, node_1.createNodeCompoundProgram)([\n                    node_point_border_1.default,\n                    NodePictogramProgram,\n                ]),\n                'halo+picto': (0, node_1.createNodeCompoundProgram)([\n                    node_point_1.default,\n                    NodePictogramProgram,\n                ]),\n            };\n            let rendererSettings = this.model.get('renderer_settings');\n            rendererSettings = Object.assign({ hoverRenderer: custom_hover_1.default, labelRenderer: custom_label_1.default, edgeProgramClasses,\n                nodeProgramClasses,\n                nodeHoverProgramClasses, defaultNodeType: 'point', defaultEdgeType: 'rectangle' }, rendererSettings);\n            // Gathering info about the graph to build reducers correctly\n            const maxCategoricalColors = this.model.get('max_categorical_colors');\n            const scaleBuilder = new visual_variables_1.VisualVariableScalesBuilder(visualVariables, maxCategoricalColors);\n            scaleBuilder.readGraph(graph);\n            if (!('labelRenderedSizeThreshold' in rendererSettings))\n                rendererSettings.labelRenderedSizeThreshold =\n                    scaleBuilder.inferLabelRenderedSizeThreshold();\n            const scales = scaleBuilder.build();\n            this.updateLegend(visualVariables, {\n                nodeColor: (_a = scales.nodeColor) === null || _a === void 0 ? void 0 : _a.summary,\n                nodeBorderColor: (_b = scales.nodeBorderColor) === null || _b === void 0 ? void 0 : _b.summary,\n                edgeColor: (_c = scales.edgeColor) === null || _c === void 0 ? void 0 : _c.summary,\n            });\n            const nodeDisplayDataRegister = {};\n            const nodeCategoryAttribute = visualVariables.nodeColor.type === 'category'\n                ? visualVariables.nodeColor.attribute\n                : null;\n            const edgeCategoryAttribute = visualVariables.edgeColor.type === 'category'\n                ? visualVariables.edgeColor.attribute\n                : null;\n            const edgeColorFrom = visualVariables.edgeColor.type === 'dependent'\n                ? visualVariables.edgeColor.value\n                : null;\n            const nodeBorderColorFrom = visualVariables.nodeBorderColor.type === 'dependent'\n                ? visualVariables.nodeBorderColor.value\n                : undefined;\n            // Node reducer\n            rendererSettings.nodeReducer = (node, data) => {\n                const displayData = {\n                    x: data.x,\n                    y: data.y,\n                };\n                // Visual variables\n                const categoryValue = nodeCategoryAttribute\n                    ? data[nodeCategoryAttribute]\n                    : undefined;\n                if (categoryValue !== undefined) {\n                    displayData.categoryValue = categoryValue;\n                }\n                displayData.color = scales.nodeColor(data);\n                displayData.size = scales.nodeSize(data);\n                displayData.label = (scales.nodeLabel(data) || node);\n                displayData.labelSize = scales.nodeLabelSize(data);\n                displayData.labelColor = scales.nodeLabelColor(data);\n                if (nodeColorSaturationEnabled) {\n                    const color = (0, chroma_js_1.default)(displayData.color);\n                    displayData.color = color\n                        .set('lch.c', color.get('lch.c') * scales.nodeColorSaturation(data))\n                        .hex();\n                }\n                if (nodeBordersEnabled) {\n                    if (visualVariables.nodeBorderRatio.type !== 'disabled')\n                        displayData.borderRatio = scales.nodeBorderRatio(data);\n                    else {\n                        displayData.borderSize = scales.nodeBorderSize(data);\n                        displayData.size += displayData.borderSize;\n                    }\n                    if (nodeBorderColorFrom) {\n                        displayData.borderColor = (0, chroma_js_1.default)(displayData.color).darken().hex();\n                    }\n                    else {\n                        displayData.borderColor = scales.nodeBorderColor(data);\n                    }\n                }\n                if (nodePictogramsEnabled) {\n                    displayData.pictogram = (0, utils_2.pictogramToUrl)(scales.nodePictogram(data));\n                    displayData.pictogramColor = scales.nodePictogramColor(data);\n                }\n                if (nodeShapeEnabled) {\n                    displayData.pictogram = (0, utils_2.pictogramToUrl)((0, shapes_1.shapeToPicto)(scales.nodeShape(data)) || 'circle', 'wght700fill1');\n                    displayData.pictogramColor = displayData.color;\n                }\n                if (nodeHaloEnabled) {\n                    const haloSize = scales.nodeHaloSize(data);\n                    if (haloSize !== 0) {\n                        displayData.haloSize = displayData.size + haloSize;\n                    }\n                    else {\n                        displayData.haloSize = 0;\n                    }\n                    displayData.haloColor = scales.nodeHaloColor(data);\n                }\n                // Transient state\n                if (node === this.selectedNode || node === this.syncHoveredNode) {\n                    displayData.highlighted = true;\n                }\n                if ((this.focusedNodes && !this.focusedNodes.has(node)) ||\n                    (this.selectedNodeCategoryValues &&\n                        !this.selectedNodeCategoryValues.has(categoryValue))) {\n                    if (!nodeShapeEnabled) {\n                        displayData.type = 'point';\n                        displayData.color = MUTED_NODE_COLOR;\n                    }\n                    else {\n                        displayData.pictogramColor = MUTED_NODE_COLOR;\n                    }\n                    displayData.zIndex = 0;\n                    displayData.size = displayData.size ? displayData.size / 2 : 1;\n                    displayData.hoverLabel = displayData.label;\n                    displayData.label = '';\n                }\n                else {\n                    displayData.zIndex = 1;\n                }\n                nodeDisplayDataRegister[node] = displayData;\n                return displayData;\n            };\n            // Edge reducer\n            rendererSettings.edgeReducer = (edge, data) => {\n                var _a, _b;\n                const displayData = {};\n                const [source, target] = graph.extremities(edge);\n                // Visual variables\n                const categoryValue = edgeCategoryAttribute\n                    ? data[edgeCategoryAttribute]\n                    : null;\n                if (edgeColorFrom) {\n                    displayData.color =\n                        nodeDisplayDataRegister[edgeColorFrom === 'source' ? source : target].color;\n                }\n                else {\n                    displayData.color = scales.edgeColor(data);\n                }\n                displayData.size = scales.edgeSize(data);\n                if (scales.edgeLabel)\n                    displayData.label = scales.edgeLabel(data);\n                if (rendererSettings.defaultEdgeType === 'curve') {\n                    displayData.curveness = scales.edgeCurveness(data);\n                }\n                // Transient state\n                if (this.selectedNode && this.focusedNodes) {\n                    if (source !== this.selectedNode && target !== this.selectedNode) {\n                        displayData.hidden = true;\n                    }\n                }\n                if (this.selectedNodeCategoryValues) {\n                    if (!this.selectedNodeCategoryValues.has((_a = nodeDisplayDataRegister[source]) === null || _a === void 0 ? void 0 : _a.categoryValue) &&\n                        !this.selectedNodeCategoryValues.has((_b = nodeDisplayDataRegister[target]) === null || _b === void 0 ? void 0 : _b.categoryValue)) {\n                        displayData.hidden = true;\n                    }\n                }\n                if (this.selectedEdgeCategoryValues) {\n                    if (!this.selectedEdgeCategoryValues.has(categoryValue)) {\n                        displayData.hidden = true;\n                    }\n                }\n                if (this.selectedEdge) {\n                    displayData.hidden = edge !== this.selectedEdge;\n                }\n                return displayData;\n            };\n            this.renderer = new sigma_1.default(graph, this.container, rendererSettings);\n            const uiSettings = this.model.get('ui_settings');\n            const initialCameraState = this.model.get('camera_state');\n            this.renderer.getCamera().setState(initialCameraState);\n            const selectedNode = this.model.get('selected_node');\n            const selectedEdge = this.model.get('selected_edge');\n            if (selectedNode)\n                this.selectItem('node', selectedNode);\n            else if (selectedEdge)\n                this.selectItem('edge', graph.edge(selectedEdge[0], selectedEdge[1]));\n            else\n                this.clearSelectedItem();\n            if (uiSettings.hideInfoPanel)\n                this.toggleInformationDisplay();\n            if (uiSettings.hideSearch) {\n                this.choices.destroy();\n                hide(searchContainer);\n                this.informationDisplayElement.classList.add('full');\n            }\n            this.bindMessageHandlers();\n            this.bindRendererHandlers();\n            this.bindChoicesHandlers();\n            this.bindInformationDisplayHandlers();\n            this.bindDownloadHandlers();\n            this.bindCameraHandlers();\n            this.bindFullscreenHandlers();\n            this.bindLayoutHandlers();\n            this.syncKey = this.model.get('sync_key');\n            if (this.syncKey) {\n                const currentSyncEntry = SYNC_REGISTRY.get(this.syncKey);\n                if (!currentSyncEntry) {\n                    const emitter = new events_1.default();\n                    SYNC_REGISTRY.set(this.syncKey, {\n                        emitter,\n                        renderers: new Set([this.renderer]),\n                    });\n                    this.bindSyncEvents(emitter);\n                }\n                else {\n                    currentSyncEntry.renderers.add(this.renderer);\n                    this.bindSyncEvents(currentSyncEntry.emitter);\n                }\n            }\n        });\n    }\n    renderSnapshot() {\n        this.model.set('snapshot', (0, utils_2.renderAsDataURL)(this.renderer));\n        this.touch();\n    }\n    saveCameraState(state) {\n        this.model.set('camera_state', state);\n        this.touch();\n    }\n    saveLayout() {\n        const mapping = (0, utils_1.collectLayout)(this.graph);\n        this.model.set('layout', mapping);\n        this.touch();\n    }\n    resetLayout() {\n        this.model.set('layout', this.originalLayoutPositions);\n        this.touch();\n    }\n    changeInformationDisplayTab(tab) {\n        if (tab === 'legend') {\n            hide(this.itemInfoElement);\n            show(this.legendElement);\n            this.legendButton.classList.remove('selectable');\n            this.nodeInfoButton.classList.add('selectable');\n        }\n        else {\n            hide(this.legendElement);\n            show(this.itemInfoElement);\n            this.legendButton.classList.add('selectable');\n            this.nodeInfoButton.classList.remove('selectable');\n        }\n    }\n    toggleInformationDisplay() {\n        var _a, _b;\n        if (this.isInformationShown) {\n            // Hiding\n            hide(this.informationDisplayElement);\n            show(this.informationShadowDisplayElement);\n            (_a = this.el.querySelector('.ipysigma-right-panel')) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');\n            this.isInformationShown = false;\n        }\n        else {\n            // Showing\n            show(this.informationDisplayElement);\n            hide(this.informationShadowDisplayElement);\n            (_b = this.el\n                .querySelector('.ipysigma-right-panel')) === null || _b === void 0 ? void 0 : _b.classList.remove('hidden');\n            this.isInformationShown = true;\n        }\n    }\n    updateLegend(variables, summaries) {\n        const categoryMap = new Map();\n        let dataId = 0;\n        function renderLegend(type, title, variable, summary, defaultColor) {\n            if (variable.type === 'disabled' || variable.type === 'constant')\n                return null;\n            let html = `<b>${title}</b><br>`;\n            if (variable.type === 'dependent') {\n                html += `based on <span class=\"ipysigma-keyword\">${variable.value}</span> color`;\n            }\n            else {\n                const source = variable.attribute.startsWith(IPYSIGMA_KWARG_PREFIX)\n                    ? 'kwarg'\n                    : 'attribute';\n                const name = variable.attribute.startsWith(IPYSIGMA_KWARG_PREFIX)\n                    ? variable.attribute.slice(IPYSIGMA_KWARG_PREFIX.length)\n                    : variable.attribute;\n                if (variable.type === 'raw') {\n                    html += `<span class=\"ipysigma-keyword\">${escapeHtml(name)}</span> ${source}`;\n                }\n                else if (variable.type === 'continuous') {\n                    html += `<span class=\"ipysigma-keyword\">${escapeHtml(name)}</span> ${source} `;\n                    if (typeof variable.range === 'string') {\n                        html += `(using the <span class=\"ipysigma-keyword\">${variable.range}</span> color scheme)`;\n                    }\n                    else if (typeof variable.range[0] === 'number') {\n                        html += `(scaled to <span class=\"ipysigma-number\">${variable.range[0]}</span>-<span class=\"ipysigma-number\">${variable.range[1]}</span> px)`;\n                    }\n                    else {\n                        html += `(from <span style=\"color: ${variable.range[0]}\">■</span> ${variable.range[0]} to <span style=\"color: ${variable.range[1]}\">■</span> ${variable.range[1]})`;\n                    }\n                }\n                else {\n                    html += `<span class=\"ipysigma-keyword\">${escapeHtml(name)}</span> ${source} as a category:`;\n                    const paletteItems = [];\n                    if (summary && summary.kind === 'color') {\n                        const values = [];\n                        categoryMap.set(dataId, { type, values });\n                        let i = 0;\n                        summary.palette.forEach((color, value) => {\n                            values.push(value);\n                            paletteItems.push(`<span title=\"click to filter\" class=\"category\" data-key=\"${dataId}\" data-index=\"${i++}\"><span style=\"color: ${color}\">■</span> <span class=\"category-value\">${value}</span></span>`);\n                        });\n                        dataId++;\n                        if (summary.overflowing) {\n                            paletteItems.push(`<span style=\"color: ${summary.palette.defaultValue}\">■</span> ...`);\n                        }\n                    }\n                    else {\n                        paletteItems.push(`<span style=\"color: ${defaultColor}\">■</span> default`);\n                    }\n                    html += '<br>' + paletteItems.join('<br>');\n                }\n            }\n            return html;\n        }\n        const items = [\n            renderLegend('node', 'Node labels', variables.nodeLabel),\n            renderLegend('node', 'Node colors', variables.nodeColor, summaries.nodeColor),\n            renderLegend('node', 'Node border colors', variables.nodeBorderColor, summaries.nodeBorderColor),\n            renderLegend('node', 'Node sizes', variables.nodeSize),\n            renderLegend('edge', 'Edge colors', variables.edgeColor, summaries.edgeColor),\n            renderLegend('edge', 'Edge sizes', variables.edgeSize),\n            renderLegend('edge', 'Edge labels', variables.edgeLabel),\n        ];\n        this.legendElement.innerHTML = items.filter((l) => l).join('<hr>');\n        // Binding category span events\n        function getSpanInfo(span) {\n            const key = +span.getAttribute('data-key');\n            const index = +span.getAttribute('data-index');\n            const record = categoryMap.get(key);\n            if (!record)\n                throw new Error('error registering category span click event handlers');\n            return { type: record.type, value: record.values[index] };\n        }\n        const categorySpans = this.legendElement.querySelectorAll('.category');\n        const updateSpans = () => {\n            categorySpans.forEach((span) => {\n                const { type, value } = getSpanInfo(span);\n                if (type === 'node') {\n                    if (!this.selectedNodeCategoryValues ||\n                        this.selectedNodeCategoryValues.has(value)) {\n                        span.classList.remove('evicted');\n                    }\n                    else {\n                        span.classList.add('evicted');\n                    }\n                }\n                else if (type === 'edge') {\n                    if (!this.selectedEdgeCategoryValues ||\n                        this.selectedEdgeCategoryValues.has(value)) {\n                        span.classList.remove('evicted');\n                    }\n                    else {\n                        span.classList.add('evicted');\n                    }\n                }\n            });\n        };\n        categorySpans.forEach((span) => {\n            span.onclick = () => {\n                const { type, value } = getSpanInfo(span);\n                const relatedPaletteCount = (type === 'node' ? summaries.nodeColor : summaries.edgeColor);\n                this.toggleCategoryValue(type, relatedPaletteCount.palette.size, value);\n                updateSpans();\n                this.renderer.refresh();\n            };\n        });\n        updateSpans();\n    }\n    clearSelectedItem() {\n        this.selectedEdge = null;\n        this.selectedNode = null;\n        this.focusedNodes = null;\n        this.syncHoveredNode = null;\n        this.choices.setChoiceByValue('');\n        if (this.model.get('clickable_edges')) {\n            this.itemInfoElement.innerHTML =\n                '<i>Click on a node/edge or search a node to display information about it...</i>';\n        }\n        else {\n            this.itemInfoElement.innerHTML =\n                '<i>Click on a node or search a node to display information about it...</i>';\n        }\n        this.changeInformationDisplayTab('legend');\n        this.model.set('selected_node', null);\n        this.model.set('selected_edge', null);\n        this.touch();\n        this.renderer.refresh();\n        this.emitter.emit('clearSelectedItem');\n    }\n    toggleCategoryValue(type, max, value) {\n        let target = type === 'node'\n            ? this.selectedNodeCategoryValues\n            : this.selectedEdgeCategoryValues;\n        if (!target) {\n            target = new Set([value]);\n        }\n        else if (target.size === max - 1) {\n            target = null;\n        }\n        else if (target.has(value)) {\n            if (target.size === 1) {\n                target = null;\n            }\n            else {\n                target.delete(value);\n            }\n        }\n        else {\n            target.add(value);\n        }\n        const update = target ? Array.from(target) : null;\n        if (type === 'node') {\n            this.selectedNodeCategoryValues = target;\n            this.model.set('selected_node_category_values', update);\n        }\n        else {\n            this.selectedEdgeCategoryValues = target;\n            this.model.set('selected_edge_category_values', update);\n        }\n        this.touch();\n    }\n    selectItem(type, key) {\n        const graph = this.graph;\n        if (type === 'node') {\n            this.selectedEdge = null;\n            this.selectedNode = key;\n            const focusedNodes = new Set();\n            focusedNodes.add(this.selectedNode);\n            graph.forEachNeighbor(key, (neighbor) => {\n                focusedNodes.add(neighbor);\n            });\n            this.focusedNodes = focusedNodes;\n            this.choices.setChoiceByValue(key);\n            this.model.set('selected_node', key);\n            this.model.set('selected_edge', null);\n        }\n        else {\n            const extremities = graph.extremities(key);\n            this.selectedEdge = key;\n            this.selectedNode = null;\n            this.focusedNodes = new Set(extremities);\n            this.choices.setChoiceByValue('');\n            this.model.set('selected_edge', extremities);\n            this.model.set('selected_node', null);\n        }\n        this.touch();\n        const attr = type === 'node'\n            ? graph.getNodeAttributes(key)\n            : graph.getEdgeAttributes(key);\n        let innerHTML = '';\n        if (type === 'node') {\n            innerHTML += `<b>Node</b> <i>${renderTypedValue(key)}</i>`;\n        }\n        else {\n            const [source, target] = this.graph.extremities(key);\n            innerHTML += '<b>Edge</b>';\n            if (!key.startsWith('geid_'))\n                innerHTML += ` <i>${renderTypedValue(key)}</i>`;\n            innerHTML += `<br>from ${renderTypedValue(source)} to ${renderTypedValue(target)}`;\n        }\n        const kwargInfo = [];\n        const vizInfo = [];\n        const info = [];\n        const vizAttributes = type === 'node' ? NODE_VIZ_ATTRIBUTES : EDGE_VIZ_ATTRIBUTES;\n        for (let k in attr) {\n            let target = info;\n            if (vizAttributes.has(k))\n                target = vizInfo;\n            else if (k.startsWith(IPYSIGMA_KWARG_PREFIX))\n                target = kwargInfo;\n            target.push(`<b>${k.startsWith(IPYSIGMA_KWARG_PREFIX)\n                ? k.slice(IPYSIGMA_KWARG_PREFIX.length)\n                : k}</b> ${renderTypedValue(attr[k])}`);\n        }\n        if (kwargInfo.length !== 0)\n            innerHTML += '<hr>From kwargs:<br>' + kwargInfo.join('<br>');\n        if (info.length !== 0)\n            innerHTML += `<hr>Attributes:<br>` + info.join('<br>');\n        if (vizInfo.length !== 0)\n            innerHTML += '<hr>Known viz data:<br>' + vizInfo.join('<br>');\n        if (type === 'node') {\n            innerHTML += '<hr>Computed metrics:<br>';\n            innerHTML += `<b>degree</b> ${renderTypedValue(graph.degree(key))}<br>`;\n            if (graph.directedSize !== 0) {\n                innerHTML += `<b>indegree</b> ${renderTypedValue(graph.inDegree(key))}<br>`;\n                innerHTML += `<b>outdegree</b> ${renderTypedValue(graph.outDegree(key))}<br>`;\n            }\n        }\n        this.itemInfoElement.innerHTML = innerHTML;\n        this.changeInformationDisplayTab('info');\n        this.renderer.refresh();\n        this.emitter.emit('selectItem', { type, key });\n    }\n    moveCameraToNode(node) {\n        const pos = this.renderer.getNodeDisplayData(node);\n        if (!pos)\n            return;\n        this.renderer.getCamera().animate(pos, { duration: 500 });\n    }\n    bindMessageHandlers() {\n        this.model.on('msg:custom', (content) => {\n            if (content.msg === 'render_snapshot') {\n                this.renderSnapshot();\n            }\n        });\n    }\n    bindRendererHandlers() {\n        const debouncedSaveCameraState = (0, debounce_1.default)(this.saveCameraState.bind(this), 500);\n        this.renderer.getCamera().on('updated', (state) => {\n            debouncedSaveCameraState(state);\n        });\n        let hoveredCount = 0;\n        this.renderer.on('enterNode', () => {\n            hoveredCount++;\n            this.container.style.cursor = 'pointer';\n        });\n        this.renderer.on('leaveNode', () => {\n            hoveredCount--;\n            if (hoveredCount === 0)\n                this.container.style.cursor = 'default';\n        });\n        this.renderer.on('clickNode', ({ node }) => {\n            if (node === this.selectedNode)\n                return;\n            this.selectItem('node', node);\n        });\n        this.renderer.on('clickStage', () => {\n            if (!this.selectedNode && !this.selectedEdge)\n                return;\n            this.clearSelectedItem();\n        });\n        if (this.model.get('clickable_edges')) {\n            this.renderer.on('enterEdge', () => {\n                hoveredCount++;\n                this.container.style.cursor = 'pointer';\n            });\n            this.renderer.on('leaveEdge', () => {\n                hoveredCount--;\n                if (hoveredCount === 0)\n                    this.container.style.cursor = 'default';\n            });\n            this.renderer.on('clickEdge', ({ edge }) => {\n                if (edge === this.selectedEdge)\n                    return;\n                this.selectItem('edge', edge);\n            });\n        }\n    }\n    bindChoicesHandlers() {\n        this.choices.passedElement.element.addEventListener('change', (event) => {\n            const node = event.detail.value;\n            if (node === this.selectedNode)\n                return;\n            if (!node)\n                return this.clearSelectedItem();\n            this.selectItem('node', node);\n            // We don't need to move the camera if we are fully unzoomed\n            if (this.renderer.getCamera().getState().ratio >= 1)\n                return;\n            this.moveCameraToNode(node);\n        });\n    }\n    bindInformationDisplayHandlers() {\n        this.legendButton.onclick = () => {\n            if (!this.legendButton.classList.contains('selectable'))\n                return;\n            this.changeInformationDisplayTab('legend');\n        };\n        this.nodeInfoButton.onclick = () => {\n            if (!this.nodeInfoButton.classList.contains('selectable'))\n                return;\n            this.changeInformationDisplayTab('info');\n        };\n        this.hideInformationButton.onclick = () => {\n            this.toggleInformationDisplay();\n        };\n        this.showInformationButton.onclick = () => {\n            this.toggleInformationDisplay();\n        };\n    }\n    bindDownloadHandlers() {\n        this.downloadPNGButton.onclick = () => {\n            (0, utils_2.saveAsPNG)(this.renderer);\n        };\n        this.downloadGEXFButton.onclick = () => {\n            (0, utils_2.saveAsGEXF)(this.renderer);\n        };\n        this.downloadSVGButton.onclick = () => {\n            (0, utils_2.saveAsSVG)(this.renderer);\n        };\n        this.downloadJSONButton.onclick = () => {\n            (0, utils_2.saveAsJSON)(this.renderer);\n        };\n    }\n    bindCameraHandlers() {\n        this.zoomButton.onclick = () => {\n            this.renderer.getCamera().animatedZoom();\n        };\n        this.unzoomButton.onclick = () => {\n            this.renderer.getCamera().animatedUnzoom();\n        };\n        this.resetZoomButton.onclick = () => {\n            this.renderer.getCamera().animatedReset();\n        };\n    }\n    bindFullscreenHandlers() {\n        const enter = () => {\n            this.el.style.height = '100%';\n            this.container.style.height = '100%';\n            this.fullscreenButton.innerHTML = icons_1.fullscreenExitIcon;\n            this.fullscreenButton.setAttribute('title', 'exit fullscreen');\n            this.renderer.scheduleRefresh();\n        };\n        const exit = () => {\n            const targetHeight = this.model.get('height');\n            this.el.style.height = targetHeight;\n            this.container.style.height = targetHeight;\n            this.fullscreenButton.innerHTML = icons_1.fullscreenEnterIcon;\n            this.fullscreenButton.setAttribute('title', 'enter fullscreen');\n            this.renderer.scheduleRefresh();\n        };\n        screenfull_1.default.onchange(() => {\n            if (screenfull_1.default.isFullscreen)\n                enter();\n            else\n                exit();\n        });\n        this.fullscreenButton.onclick = () => {\n            if (screenfull_1.default.isFullscreen) {\n                screenfull_1.default.exit();\n            }\n            else {\n                screenfull_1.default.request(this.el);\n            }\n        };\n    }\n    bindLayoutHandlers() {\n        const graph = this.graph;\n        const renderer = this.renderer;\n        let settings = (this.model.get('layout_settings') ||\n            {});\n        const inferredSettings = graphology_layout_forceatlas2_1.default.inferSettings(graph);\n        settings = Object.assign(inferredSettings, settings);\n        this.layout = new worker_1.default(graph, {\n            settings,\n            getEdgeWeight: this.edgeWeightAttribute,\n        });\n        this.noverlap = new worker_2.default(graph, {\n            inputReducer(key, attr) {\n                var _a;\n                const pos = renderer.graphToViewport(attr);\n                return {\n                    x: pos.x,\n                    y: pos.y,\n                    size: (_a = renderer.getNodeDisplayData(key)) === null || _a === void 0 ? void 0 : _a.size,\n                };\n            },\n            outputReducer(key, attr) {\n                return renderer.viewportToGraph(attr);\n            },\n            onConverged() {\n                stopNoverlap(true);\n            },\n            settings: { ratio: 1, margin: 3 },\n        });\n        hide(this.resetLayoutButton);\n        let layoutStoppingTimeout = null;\n        const stopLayout = () => {\n            if (layoutStoppingTimeout)\n                clearTimeout(layoutStoppingTimeout);\n            layoutStoppingTimeout = null;\n            if (this.layoutSpinner) {\n                this.layoutControls.removeChild(this.layoutSpinner[0]);\n                this.layoutSpinner[1]();\n                this.layoutSpinner = null;\n            }\n            this.layoutButton.innerHTML = icons_1.playIcon;\n            this.layoutButton.setAttribute('title', 'start layout');\n            this.layout.stop();\n            this.saveLayout();\n            enable(this.noverlapButton);\n            show(this.resetLayoutButton);\n        };\n        const startLayout = () => {\n            this.layoutSpinner = createSpinner();\n            this.layoutButton.innerHTML = icons_1.pauseIcon;\n            this.layoutControls.appendChild(this.layoutSpinner[0]);\n            this.layoutButton.setAttribute('title', 'stop layout');\n            this.layout.start();\n            disable(this.noverlapButton);\n            hide(this.resetLayoutButton);\n        };\n        const stopNoverlap = (disableButton = false) => {\n            if (this.layoutSpinner) {\n                this.layoutControls.removeChild(this.layoutSpinner[0]);\n                this.layoutSpinner[1]();\n                this.layoutSpinner = null;\n            }\n            this.noverlapButton.innerHTML = icons_1.scatterIcon;\n            this.noverlapButton.setAttribute('title', 'spread nodes');\n            this.noverlap.stop();\n            this.saveLayout();\n            enable(this.layoutButton);\n            show(this.resetLayoutButton);\n            if (disableButton)\n                disable(this.noverlapButton);\n        };\n        const startNoverlap = () => {\n            this.layoutSpinner = createSpinner();\n            this.noverlapButton.innerHTML = icons_1.pauseIcon;\n            this.layoutControls.appendChild(this.layoutSpinner[0]);\n            this.noverlapButton.setAttribute('title', 'stop');\n            this.noverlap.start();\n            disable(this.layoutButton);\n            hide(this.resetLayoutButton);\n        };\n        const resetLayout = () => {\n            enable(this.noverlapButton);\n            hide(this.resetLayoutButton);\n            this.resetLayout();\n            (0, animate_1.animateNodes)(graph, this.originalLayoutPositions, { duration: 250 });\n        };\n        if (this.model.get('start_layout')) {\n            const seconds = this.model.get('start_layout_for_seconds');\n            if (seconds) {\n                layoutStoppingTimeout = setTimeout(() => {\n                    stopLayout();\n                }, seconds * 1000);\n            }\n            startLayout();\n        }\n        this.layoutButton.onclick = () => {\n            if (this.layout.isRunning()) {\n                stopLayout();\n            }\n            else {\n                startLayout();\n            }\n        };\n        this.noverlapButton.onclick = () => {\n            if (this.noverlap.isRunning()) {\n                stopNoverlap();\n            }\n            else {\n                startNoverlap();\n            }\n        };\n        this.resetLayoutButton.onclick = () => {\n            resetLayout();\n        };\n    }\n    bindSyncEvents(syncEmitter) {\n        let locks = {\n            camera: false,\n            nodeAttributesUpdated: false,\n            eachNodeAttributesUpdated: false,\n            selectItem: false,\n            clearSelectedItem: false,\n        };\n        const syncTargets = new Set(this.model.get('sync_targets'));\n        // NOTE: all of this is very sketchy. This is here to make suuuure we\n        // don't encounter a dead lock.\n        const resetLocks = () => {\n            for (const k in locks)\n                locks[k] = false;\n        };\n        let resetLockFrame = null;\n        const scheduleResetLocks = () => {\n            if (resetLockFrame)\n                return;\n            resetLockFrame = setTimeout(() => {\n                resetLockFrame = null;\n                resetLocks();\n            }, 0);\n        };\n        const lock = (name) => {\n            locks[name] = true;\n            scheduleResetLocks();\n        };\n        const camera = this.renderer.getCamera();\n        const graph = this.renderer.getGraph();\n        // Camera\n        if (syncTargets.has('camera')) {\n            camera.on('updated', (state) => {\n                if (locks.camera) {\n                    locks.camera = false;\n                    return;\n                }\n                syncEmitter.emit('camera', { state, renderer: this.renderer });\n            });\n            this.syncListeners.camera = ({ state, renderer }) => {\n                if (renderer === this.renderer)\n                    return;\n                lock('camera');\n                camera.setState(state);\n            };\n        }\n        // Layout\n        if (syncTargets.has('layout')) {\n            graph.on('nodeAttributesUpdated', ({ key, attributes }) => {\n                if (locks.nodeAttributesUpdated) {\n                    locks.nodeAttributesUpdated = false;\n                    return;\n                }\n                syncEmitter.emit('nodePosition', {\n                    node: key,\n                    position: { x: attributes.x, y: attributes.y },\n                    renderer: this.renderer,\n                });\n            });\n            graph.on('eachNodeAttributesUpdated', () => {\n                if (locks.eachNodeAttributesUpdated) {\n                    locks.eachNodeAttributesUpdated = false;\n                    return;\n                }\n                syncEmitter.emit('layout', {\n                    layout: (0, utils_1.collectLayout)(graph),\n                    renderer: this.renderer,\n                });\n            });\n            this.syncListeners.layout = ({ layout, renderer }) => {\n                if (renderer === this.renderer)\n                    return;\n                lock('eachNodeAttributesUpdated');\n                (0, utils_1.assignLayout)(graph, layout);\n            };\n            this.syncListeners.nodePosition = ({ node, position, renderer }) => {\n                if (renderer === this.renderer)\n                    return;\n                lock('nodeAttributesUpdated');\n                graph.mergeNodeAttributes(node, position);\n            };\n        }\n        // Selection\n        if (syncTargets.has('selection')) {\n            this.emitter.on('selectItem', (payload) => {\n                if (locks.selectItem) {\n                    locks.selectItem = false;\n                    return;\n                }\n                const type = payload.type;\n                let key = payload.key;\n                if (type === 'edge') {\n                    key = this.graph.extremities(key);\n                }\n                syncEmitter.emit('selectItem', { type, key, renderer: this.renderer });\n            });\n            this.emitter.on('clearSelectedItem', () => {\n                if (locks.clearSelectedItem) {\n                    locks.clearSelectedItem = false;\n                    return;\n                }\n                syncEmitter.emit('clearSelectedItem', { renderer: this.renderer });\n            });\n            this.syncListeners.selectItem = ({ renderer, key, type }) => {\n                if (renderer === this.renderer)\n                    return;\n                lock('selectItem');\n                if (type === 'edge')\n                    key = this.graph.edge(key[0], key[1]);\n                this.selectItem(type, key);\n            };\n            this.syncListeners.clearSelectedItem = ({ renderer }) => {\n                if (renderer === this.renderer)\n                    return;\n                lock('clearSelectedItem');\n                this.clearSelectedItem();\n            };\n        }\n        // Hover\n        if (syncTargets.has('hover')) {\n            this.renderer.on('enterNode', ({ node }) => {\n                syncEmitter.emit('enterNode', { node, renderer: this.renderer });\n            });\n            this.renderer.on('leaveNode', ({ node }) => {\n                syncEmitter.emit('leaveNode', { node, renderer: this.renderer });\n            });\n            this.syncListeners.enterNode = ({ node, renderer }) => {\n                if (renderer === this.renderer)\n                    return;\n                this.syncHoveredNode = node;\n                this.renderer.scheduleRefresh();\n            };\n            this.syncListeners.leaveNode = ({ renderer }) => {\n                if (renderer === this.renderer)\n                    return;\n                this.syncHoveredNode = null;\n                this.renderer.scheduleRefresh();\n            };\n        }\n        // Registering events\n        for (const eventName in this.syncListeners) {\n            syncEmitter.on(eventName, this.syncListeners[eventName]);\n        }\n    }\n    remove() {\n        // Cleanup to avoid leaks and free GPU slots\n        if (this.renderer)\n            this.renderer.kill();\n        if (this.layout)\n            this.layout.kill();\n        if (this.noverlap)\n            this.noverlap.kill();\n        if (this.syncKey) {\n            const syncEntry = SYNC_REGISTRY.get(this.syncKey);\n            if (!syncEntry) {\n                throw new Error('sync entry not found on remove. this should not happen!');\n            }\n            if (syncEntry.renderers.size > 1) {\n                syncEntry.renderers.delete(this.renderer);\n                for (const eventName in this.syncListeners) {\n                    syncEntry.emitter.removeListener(eventName, this.syncListeners[eventName]);\n                }\n            }\n            else {\n                syncEntry.emitter.removeAllListeners();\n                SYNC_REGISTRY.delete(this.syncKey);\n            }\n        }\n        this.emitter.removeAllListeners();\n        super.remove();\n    }\n}\nexports.SigmaView = SigmaView;\n//# sourceMappingURL=widget.js.map","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \"/* Choices.js overrides */\\n.ipysigma-widget .choices {\\n  margin-bottom: 5px;\\n}\\n\\n.ipysigma-widget .choices__inner {\\n  border-radius: 0;\\n  background-color: white;\\n  border: 1px solid #e0e0e0;\\n  box-sizing: border-box;\\n  padding-right: 50px;\\n}\\n\\n.ipysigma-widget .choices__item--selectable {\\n  padding-right: 0px !important;\\n}\\n\\n.ipysigma-widget .choices__item {\\n  text-overflow: ellipsis;\\n  overflow: hidden;\\n  white-space: nowrap;\\n}\\n\\n/* Ipysigma own styles */\\n.ipysigma-widget {\\n  /* Background color is now set by widget directly! */\\n  /* background-color: white; */\\n  margin: 0;\\n  padding: 0;\\n  border: 1px solid #e0e0e0;\\n  font-family: sans-serif;\\n  color: black;\\n}\\n\\n.ipysigma-widget ~ .ipysigma-widget {\\n  border-left: none;\\n}\\n\\n.widget-hbox ~ .widget-hbox .ipysigma-widget {\\n  border-top: none;\\n}\\n\\n.ipysigma-widget hr {\\n  height: 1px;\\n  border: none;\\n  background-color: #e0e0e0;\\n  margin-top: 6px;\\n  margin-bottom: 6px;\\n}\\n\\n.ipysigma-widget .ipysigma-left-panel {\\n  position: absolute;\\n  top: 10px;\\n  left: 10px;\\n}\\n\\n.ipysigma-widget .ipysigma-right-panel {\\n  position: absolute;\\n  top: 10px;\\n  right: 10px;\\n  width: 250px;\\n  height: 100%;\\n}\\n\\n.ipysigma-widget .ipysigma-right-panel.hidden {\\n  pointer-events: none;\\n}\\n\\n.ipysigma-widget .ipysigma-graph-description {\\n  background-color: white;\\n  border: 1px solid #e0e0e0;\\n  padding: 5px 10px;\\n  font-size: 12px;\\n  /* font-style: italic; */\\n  line-height: 16px;\\n}\\n\\n.ipysigma-widget .ipysigma-button {\\n  cursor: pointer;\\n  text-align: center;\\n  background-color: white;\\n  border: 1px solid #e0e0e0;\\n  user-select: none;\\n}\\n\\n.ipysigma-widget .ipysigma-button.disabled {\\n  border: none;\\n  cursor: default;\\n}\\n\\n.ipysigma-widget .ipysigma-button.disabled svg {\\n  fill: #efefef;\\n}\\n\\n.ipysigma-widget .ipysigma-button:hover {\\n  border-color: grey;\\n}\\n\\n.ipysigma-widget .ipysigma-svg-icon {\\n  width: 32px;\\n  height: 32px;\\n  font-size: 24px;\\n  line-height: 30px;\\n  box-sizing: border-box;\\n}\\n\\n.ipysigma-widget .ipysigma-zoom-button {\\n  margin-top: 10px;\\n}\\n\\n.ipysigma-widget .ipysigma-unzoom-button {\\n  margin-top: 10px;\\n}\\n\\n.ipysigma-widget .ipysigma-reset-zoom-button {\\n  margin-top: 10px;\\n}\\n\\n.ipysigma-widget .ipysigma-fullscreen-button {\\n  margin-top: 10px;\\n}\\n\\n.ipysigma-widget .ipysigma-layout-controls {\\n  width: 100%;\\n  margin-top: 10px;\\n  display: flex;\\n}\\n\\n.ipysigma-widget .ipysigma-reset-layout-button,\\n.ipysigma-widget .ipysigma-noverlap-button {\\n  margin-left: 4px;\\n}\\n\\n.ipysigma-widget .ipysigma-spinner {\\n  font-size: 20px;\\n  padding-left: 5px;\\n  line-height: 26px;\\n}\\n\\n.ipysigma-widget .ipysigma-tab-button.selectable {\\n  color: cornflowerblue;\\n  text-decoration: underline;\\n  cursor: pointer;\\n}\\n\\n.ipysigma-widget .ipysigma-information-display {\\n  width: 100%;\\n  height: calc(100% - 45px - 5px - 20px - 25px);\\n  overflow-y: auto;\\n  background-color: white;\\n  border: 1px solid #e0e0e0;\\n  box-sizing: border-box;\\n  font-size: 12px;\\n  line-height: 16px;\\n  padding: 10px;\\n}\\n\\n.ipysigma-widget .ipysigma-information-display.full {\\n  height: calc(100% - 20px - 25px);\\n}\\n\\n.ipysigma-widget .ipysigma-information-shadow-display {\\n  width: 100%;\\n  overflow-y: auto;\\n  box-sizing: border-box;\\n  font-size: 12px;\\n  line-height: 16px;\\n  padding: 10px;\\n}\\n\\n.ipysigma-widget .ipysigma-information-hide-button,\\n.ipysigma-widget .ipysigma-information-show-button {\\n  float: right;\\n  cursor: pointer;\\n}\\n\\n.ipysigma-widget .ipysigma-information-contents,\\n.ipysigma-widget .ipysigma-legend {\\n  font-family: monospace;\\n}\\n\\n.ipysigma-widget .ipysigma-string {\\n  color: #bc2828;\\n}\\n\\n.ipysigma-widget .ipysigma-number {\\n  color: #008800;\\n}\\n\\n.ipysigma-widget .ipysigma-boolean,\\n.ipysigma-widget .ipysigma-keyword {\\n  color: #0457ab;\\n}\\n\\n.ipysigma-widget .ipysigma-download-controls {\\n  margin-top: 5px;\\n  display: flex;\\n  text-align: right;\\n  position: absolute;\\n  bottom: 20px;\\n  right: 0px;\\n}\\n\\n.ipysigma-widget .ipysigma-download-png-button,\\n.ipysigma-widget .ipysigma-download-svg-button,\\n.ipysigma-widget .ipysigma-download-gexf-button {\\n  margin-right: 3px;\\n}\\n\\n.ipysigma-widget .category {\\n  cursor: pointer;\\n}\\n.ipysigma-widget .category.evicted .category-value {\\n  color: gray;\\n  text-decoration: line-through;\\n}\\n\\n.ipysigma-widget .ipysigma-search,\\n.ipysigma-widget .ipysigma-download-controls,\\n.ipysigma-widget .ipysigma-information-shadow-display,\\n.ipysigma-widget .choices {\\n  pointer-events: auto;\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n","var api = require(\"!../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../node_modules/css-loader/dist/cjs.js!./widget.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};"],"names":[],"sourceRoot":""}