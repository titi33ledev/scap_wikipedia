{"version":3,"file":"vendors-node_modules_graphology-communities-louvain_index_js.2cdb99a5f00564f84123.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,8EAA2B;AACzD,cAAc,mBAAO,CAAC,8EAA2B;AACjD,gBAAgB,mBAAO,CAAC,kFAA6B;AACrD,gBAAgB,mBAAO,CAAC,oEAAsB;AAC9C,qBAAqB,mBAAO,CAAC,gFAA4B;AACzD,wBAAwB,qHAAqD;;AAE7E,cAAc,mBAAO,CAAC,gFAA4B;;AAElD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,OAAO;AAC3B;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,OAAO;AAC3B;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,WAAW;AACvB,YAAY,WAAW;AACvB,YAAY,WAAW;AACvB,YAAY,WAAW;AACvB,YAAY,WAAW;AACvB,YAAY,WAAW;AACvB,YAAY,WAAW;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/wBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,MAAM,MAAM,EAAE,EAAE,GAAG,MAAM,EAAE,KAAK,GAAG,OAAO,EAAE,MAAM,MAAM,EAAE,EAAE,IAAI,QAAQ,GAAG,MAAM,EAAE,EAAE,EAAE,OAAO,MAAM,EAAE,EAAE,GAAG,MAAM,EAAE,KAAK,GAAG,OAAO,EAAE,MAAM,MAAM,EAAE,EAAE,IAAI,QAAQ,GAAG,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,MAAM,EAAE,EAAE,KAAK,GAAG,OAAO,EAAE,MAAM,MAAM,EAAE,EAAE,MAAM,GAAG,MAAM,EAAE,EAAE,EAAE,OAAO,MAAM,EAAE,EAAE,KAAK,GAAG,OAAO,EAAE,MAAM,MAAM,EAAE,EAAE,MAAM,GAAG,MAAM,EAAE,EAAE,EAAE,MAAM;AACvW,kBAAkB,GAAG,EAAE,IAAI,IAAI,EAAE,OAAO,OAAO,EAAE,EAAE,IAAI,QAAQ,EAAE,EAAE,IAAI,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,EAAE,IAAI,QAAQ,EAAE,EAAE,MAAM,IAAI;AAC7H,kBAAkB,GAAG,EAAE,IAAI,IAAI,EAAE,OAAO,WAAW,EAAE,EAAE,IAAI,IAAI,EAAE,IAAI,EAAE,gBAAgB,EAAE,EAAE,MAAM,IAAI;AACrG;AACA;AACA;AACA,oBAAoB,EAAE,MAAM,MAAM,EAAE,EAAE,GAAG,KAAK,KAAK,IAAI,MAAM,KAAK,EAAE,OAAO,OAAO,EAAE,EAAE,OAAO,KAAK,GAAG,WAAW,EAAE,EAAE,QAAQ,KAAK,IAAI,MAAM,GAAG,GAAG,OAAO,MAAM,EAAE,EAAE,GAAG,KAAK,KAAK,IAAI,MAAM,KAAK,EAAE,OAAO,OAAO,EAAE,EAAE,OAAO,KAAK,GAAG,WAAW,EAAE,EAAE,QAAQ,KAAK,IAAI,MAAM,GAAG,GAAG,MAAM,EAAE,OAAO,EAAE,MAAM,MAAM,EAAE,EAAE,KAAK,EAAE,OAAO,MAAM,EAAE,EAAE,OAAO,MAAM,EAAE,EAAE,UAAU,GAAG,GAAG,OAAO,MAAM,EAAE,EAAE,KAAK,EAAE,OAAO,MAAM,EAAE,EAAE,OAAO,MAAM,EAAE,EAAE,UAAU,GAAG,GAAG,MAAM;AACvb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,oFAA8B;AAClD,sBAAsB,mBAAO,CAAC,8EAA2B;AACzD;AACA,EAAE,0HAA0D;;AAE5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,mDAAmD,OAAO;AAC1D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,0BAA0B,OAAO;AACjC;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,OAAO;;AAEvB;AACA,IAAI;AACJ,gBAAgB,OAAO;AACvB;;AAEA;AACA,0BAA0B,OAAO;AACjC;;AAEA;AACA;AACA;;AAEA,qDAAqD,OAAO;AAC5D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,YAAY;AAC1B;AACA;;AAEA,qDAAqD,OAAO;AAC5D;;AAEA;;AAEA;AACA;AACA;;AAEA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,kCAAkC,OAAO;;AAEzC;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oDAAoD,OAAO;AAC3D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,gDAAgD,OAAO;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,0BAA0B,OAAO;AACjC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,OAAO;;AAEvB;AACA,IAAI;AACJ,gBAAgB,OAAO;AACvB;;AAEA;AACA,0BAA0B,OAAO;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD,OAAO;AAC5D;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,YAAY;AAC1B;AACA;;AAEA,kDAAkD,OAAO;AACzD;;AAEA;;AAEA;AACA;AACA;;AAEA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;;AAEA,8BAA8B;AAC9B,4BAA4B;;;;;;;;;;;AC5/B5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,oEAAsB;AAC7C,sBAAsB,sHAAkD;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,WAAW;AACvB,YAAY;AACZ;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,oEAAsB;AAC7C,sBAAsB,sHAAkD;;AAExE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,WAAW;AACvB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACzNA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","sources":["webpack://ipysigma/./node_modules/graphology-communities-louvain/index.js","webpack://ipysigma/./node_modules/graphology-indices/louvain.js","webpack://ipysigma/./node_modules/graphology-utils/defaults.js","webpack://ipysigma/./node_modules/mnemonist/sparse-map.js","webpack://ipysigma/./node_modules/mnemonist/sparse-queue-set.js","webpack://ipysigma/./node_modules/pandemonium/random-index.js"],"sourcesContent":["/**\n * Graphology Louvain Algorithm\n * =============================\n *\n * JavaScript implementation of the famous Louvain community detection\n * algorithm for graphology.\n *\n * [Articles]\n * M. E. J. Newman, « Modularity and community structure in networks »,\n * Proc. Natl. Acad. Sci. USA, vol. 103, no 23, 2006, p. 8577–8582\n * https://dx.doi.org/10.1073%2Fpnas.0601602103\n *\n * Newman, M. E. J. « Community detection in networks: Modularity optimization\n * and maximum likelihood are equivalent ». Physical Review E, vol. 94, no 5,\n * novembre 2016, p. 052315. arXiv.org, doi:10.1103/PhysRevE.94.052315.\n * https://arxiv.org/pdf/1606.02319.pdf\n *\n * Blondel, Vincent D., et al. « Fast unfolding of communities in large\n * networks ». Journal of Statistical Mechanics: Theory and Experiment,\n * vol. 2008, no 10, octobre 2008, p. P10008. DOI.org (Crossref),\n * doi:10.1088/1742-5468/2008/10/P10008.\n * https://arxiv.org/pdf/0803.0476.pdf\n *\n * Nicolas Dugué, Anthony Perez. Directed Louvain: maximizing modularity in\n * directed networks. [Research Report] Université d’Orléans. 2015. hal-01231784\n * https://hal.archives-ouvertes.fr/hal-01231784\n *\n * R. Lambiotte, J.-C. Delvenne and M. Barahona. Laplacian Dynamics and\n * Multiscale Modular Structure in Networks,\n * doi:10.1109/TNSE.2015.2391998.\n * https://arxiv.org/abs/0812.1770\n *\n * Traag, V. A., et al. « From Louvain to Leiden: Guaranteeing Well-Connected\n * Communities ». Scientific Reports, vol. 9, no 1, décembre 2019, p. 5233.\n * DOI.org (Crossref), doi:10.1038/s41598-019-41695-z.\n * https://arxiv.org/abs/1810.08473\n */\nvar resolveDefaults = require('graphology-utils/defaults');\nvar isGraph = require('graphology-utils/is-graph');\nvar inferType = require('graphology-utils/infer-type');\nvar SparseMap = require('mnemonist/sparse-map');\nvar SparseQueueSet = require('mnemonist/sparse-queue-set');\nvar createRandomIndex = require('pandemonium/random-index').createRandomIndex;\n\nvar indices = require('graphology-indices/louvain');\n\nvar UndirectedLouvainIndex = indices.UndirectedLouvainIndex;\nvar DirectedLouvainIndex = indices.DirectedLouvainIndex;\n\nvar DEFAULTS = {\n  nodeCommunityAttribute: 'community',\n  getEdgeWeight: 'weight',\n  fastLocalMoves: true,\n  randomWalk: true,\n  resolution: 1,\n  rng: Math.random\n};\n\nfunction addWeightToCommunity(map, community, weight) {\n  var currentWeight = map.get(community);\n\n  if (typeof currentWeight === 'undefined') currentWeight = 0;\n\n  currentWeight += weight;\n\n  map.set(community, currentWeight);\n}\n\nvar EPSILON = 1e-10;\n\nfunction tieBreaker(\n  bestCommunity,\n  currentCommunity,\n  targetCommunity,\n  delta,\n  bestDelta\n) {\n  if (Math.abs(delta - bestDelta) < EPSILON) {\n    if (bestCommunity === currentCommunity) {\n      return false;\n    } else {\n      return targetCommunity > bestCommunity;\n    }\n  } else if (delta > bestDelta) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction undirectedLouvain(detailed, graph, options) {\n  var index = new UndirectedLouvainIndex(graph, {\n    getEdgeWeight: options.getEdgeWeight,\n    keepDendrogram: detailed,\n    resolution: options.resolution\n  });\n\n  var randomIndex = createRandomIndex(options.rng);\n\n  // State variables\n  var moveWasMade = true,\n    localMoveWasMade = true;\n\n  // Communities\n  var currentCommunity, targetCommunity;\n  var communities = new SparseMap(Float64Array, index.C);\n\n  // Traversal\n  var queue, start, end, weight, ci, ri, s, i, j, l;\n\n  // Metrics\n  var degree, targetCommunityDegree;\n\n  // Moves\n  var bestCommunity, bestDelta, deltaIsBetter, delta;\n\n  // Details\n  var deltaComputations = 0,\n    nodesVisited = 0,\n    moves = [],\n    localMoves,\n    currentMoves;\n\n  if (options.fastLocalMoves) queue = new SparseQueueSet(index.C);\n\n  while (moveWasMade) {\n    l = index.C;\n\n    moveWasMade = false;\n    localMoveWasMade = true;\n\n    if (options.fastLocalMoves) {\n      currentMoves = 0;\n\n      // Traversal of the graph\n      ri = options.randomWalk ? randomIndex(l) : 0;\n\n      for (s = 0; s < l; s++, ri++) {\n        i = ri % l;\n        queue.enqueue(i);\n      }\n\n      while (queue.size !== 0) {\n        i = queue.dequeue();\n        nodesVisited++;\n\n        degree = 0;\n        communities.clear();\n\n        currentCommunity = index.belongings[i];\n\n        start = index.starts[i];\n        end = index.starts[i + 1];\n\n        // Traversing neighbors\n        for (; start < end; start++) {\n          j = index.neighborhood[start];\n          weight = index.weights[start];\n\n          targetCommunity = index.belongings[j];\n\n          // Incrementing metrics\n          degree += weight;\n          addWeightToCommunity(communities, targetCommunity, weight);\n        }\n\n        // Finding best community to move to\n        bestDelta = index.fastDeltaWithOwnCommunity(\n          i,\n          degree,\n          communities.get(currentCommunity) || 0,\n          currentCommunity\n        );\n        bestCommunity = currentCommunity;\n\n        for (ci = 0; ci < communities.size; ci++) {\n          targetCommunity = communities.dense[ci];\n\n          if (targetCommunity === currentCommunity) continue;\n\n          targetCommunityDegree = communities.vals[ci];\n\n          deltaComputations++;\n\n          delta = index.fastDelta(\n            i,\n            degree,\n            targetCommunityDegree,\n            targetCommunity\n          );\n\n          deltaIsBetter = tieBreaker(\n            bestCommunity,\n            currentCommunity,\n            targetCommunity,\n            delta,\n            bestDelta\n          );\n\n          if (deltaIsBetter) {\n            bestDelta = delta;\n            bestCommunity = targetCommunity;\n          }\n        }\n\n        // Should we move the node?\n        if (bestDelta < 0) {\n          // NOTE: this is to allow nodes to move back to their own singleton\n          // This code however only deals with modularity (e.g. the condition\n          // about bestDelta < 0, which is the delta for moving back to\n          // singleton wrt. modularity). Indeed, rarely, the Louvain\n          // algorithm can produce such cases when a node would be better in\n          // a singleton that in its own community when considering self loops\n          // or a resolution != 1. In this case, delta with your own community\n          // is indeed less than 0. To handle different metrics, one should\n          // consider computing the delta for going back to singleton because\n          // it might not be 0.\n          bestCommunity = index.isolate(i, degree);\n\n          // If the node was already in a singleton community, we don't consider\n          // a move was made\n          if (bestCommunity === currentCommunity) continue;\n        } else {\n          // If no move was made, we continue to next node\n          if (bestCommunity === currentCommunity) {\n            continue;\n          } else {\n            // Actually moving the node to a new community\n            index.move(i, degree, bestCommunity);\n          }\n        }\n\n        moveWasMade = true;\n        currentMoves++;\n\n        // Adding neighbors from other communities to the queue\n        start = index.starts[i];\n        end = index.starts[i + 1];\n\n        for (; start < end; start++) {\n          j = index.neighborhood[start];\n          targetCommunity = index.belongings[j];\n\n          if (targetCommunity !== bestCommunity) queue.enqueue(j);\n        }\n      }\n\n      moves.push(currentMoves);\n    } else {\n      localMoves = [];\n      moves.push(localMoves);\n\n      // Traditional Louvain iterative traversal of the graph\n      while (localMoveWasMade) {\n        localMoveWasMade = false;\n        currentMoves = 0;\n\n        ri = options.randomWalk ? randomIndex(l) : 0;\n\n        for (s = 0; s < l; s++, ri++) {\n          i = ri % l;\n\n          nodesVisited++;\n\n          degree = 0;\n          communities.clear();\n\n          currentCommunity = index.belongings[i];\n\n          start = index.starts[i];\n          end = index.starts[i + 1];\n\n          // Traversing neighbors\n          for (; start < end; start++) {\n            j = index.neighborhood[start];\n            weight = index.weights[start];\n\n            targetCommunity = index.belongings[j];\n\n            // Incrementing metrics\n            degree += weight;\n            addWeightToCommunity(communities, targetCommunity, weight);\n          }\n\n          // Finding best community to move to\n          bestDelta = index.fastDeltaWithOwnCommunity(\n            i,\n            degree,\n            communities.get(currentCommunity) || 0,\n            currentCommunity\n          );\n          bestCommunity = currentCommunity;\n\n          for (ci = 0; ci < communities.size; ci++) {\n            targetCommunity = communities.dense[ci];\n\n            if (targetCommunity === currentCommunity) continue;\n\n            targetCommunityDegree = communities.vals[ci];\n\n            deltaComputations++;\n\n            delta = index.fastDelta(\n              i,\n              degree,\n              targetCommunityDegree,\n              targetCommunity\n            );\n\n            deltaIsBetter = tieBreaker(\n              bestCommunity,\n              currentCommunity,\n              targetCommunity,\n              delta,\n              bestDelta\n            );\n\n            if (deltaIsBetter) {\n              bestDelta = delta;\n              bestCommunity = targetCommunity;\n            }\n          }\n\n          // Should we move the node?\n          if (bestDelta < 0) {\n            // NOTE: this is to allow nodes to move back to their own singleton\n            // This code however only deals with modularity (e.g. the condition\n            // about bestDelta < 0, which is the delta for moving back to\n            // singleton wrt. modularity). Indeed, rarely, the Louvain\n            // algorithm can produce such cases when a node would be better in\n            // a singleton that in its own community when considering self loops\n            // or a resolution != 1. In this case, delta with your own community\n            // is indeed less than 0. To handle different metrics, one should\n            // consider computing the delta for going back to singleton because\n            // it might not be 0.\n            bestCommunity = index.isolate(i, degree);\n\n            // If the node was already in a singleton community, we don't consider\n            // a move was made\n            if (bestCommunity === currentCommunity) continue;\n          } else {\n            // If no move was made, we continue to next node\n            if (bestCommunity === currentCommunity) {\n              continue;\n            } else {\n              // Actually moving the node to a new community\n              index.move(i, degree, bestCommunity);\n            }\n          }\n\n          localMoveWasMade = true;\n          currentMoves++;\n        }\n\n        localMoves.push(currentMoves);\n\n        moveWasMade = localMoveWasMade || moveWasMade;\n      }\n    }\n\n    // We continue working on the induced graph\n    if (moveWasMade) index.zoomOut();\n  }\n\n  var results = {\n    index: index,\n    deltaComputations: deltaComputations,\n    nodesVisited: nodesVisited,\n    moves: moves\n  };\n\n  return results;\n}\n\nfunction directedLouvain(detailed, graph, options) {\n  var index = new DirectedLouvainIndex(graph, {\n    getEdgeWeight: options.getEdgeWeight,\n    keepDendrogram: detailed,\n    resolution: options.resolution\n  });\n\n  var randomIndex = createRandomIndex(options.rng);\n\n  // State variables\n  var moveWasMade = true,\n    localMoveWasMade = true;\n\n  // Communities\n  var currentCommunity, targetCommunity;\n  var communities = new SparseMap(Float64Array, index.C);\n\n  // Traversal\n  var queue, start, end, offset, out, weight, ci, ri, s, i, j, l;\n\n  // Metrics\n  var inDegree, outDegree, targetCommunityDegree;\n\n  // Moves\n  var bestCommunity, bestDelta, deltaIsBetter, delta;\n\n  // Details\n  var deltaComputations = 0,\n    nodesVisited = 0,\n    moves = [],\n    localMoves,\n    currentMoves;\n\n  if (options.fastLocalMoves) queue = new SparseQueueSet(index.C);\n\n  while (moveWasMade) {\n    l = index.C;\n\n    moveWasMade = false;\n    localMoveWasMade = true;\n\n    if (options.fastLocalMoves) {\n      currentMoves = 0;\n\n      // Traversal of the graph\n      ri = options.randomWalk ? randomIndex(l) : 0;\n\n      for (s = 0; s < l; s++, ri++) {\n        i = ri % l;\n        queue.enqueue(i);\n      }\n\n      while (queue.size !== 0) {\n        i = queue.dequeue();\n        nodesVisited++;\n\n        inDegree = 0;\n        outDegree = 0;\n        communities.clear();\n\n        currentCommunity = index.belongings[i];\n\n        start = index.starts[i];\n        end = index.starts[i + 1];\n        offset = index.offsets[i];\n\n        // Traversing neighbors\n        for (; start < end; start++) {\n          out = start < offset;\n          j = index.neighborhood[start];\n          weight = index.weights[start];\n\n          targetCommunity = index.belongings[j];\n\n          // Incrementing metrics\n          if (out) outDegree += weight;\n          else inDegree += weight;\n\n          addWeightToCommunity(communities, targetCommunity, weight);\n        }\n\n        // Finding best community to move to\n        bestDelta = index.deltaWithOwnCommunity(\n          i,\n          inDegree,\n          outDegree,\n          communities.get(currentCommunity) || 0,\n          currentCommunity\n        );\n        bestCommunity = currentCommunity;\n\n        for (ci = 0; ci < communities.size; ci++) {\n          targetCommunity = communities.dense[ci];\n\n          if (targetCommunity === currentCommunity) continue;\n\n          targetCommunityDegree = communities.vals[ci];\n\n          deltaComputations++;\n\n          delta = index.delta(\n            i,\n            inDegree,\n            outDegree,\n            targetCommunityDegree,\n            targetCommunity\n          );\n\n          deltaIsBetter = tieBreaker(\n            bestCommunity,\n            currentCommunity,\n            targetCommunity,\n            delta,\n            bestDelta\n          );\n\n          if (deltaIsBetter) {\n            bestDelta = delta;\n            bestCommunity = targetCommunity;\n          }\n        }\n\n        // Should we move the node?\n        if (bestDelta < 0) {\n          // NOTE: this is to allow nodes to move back to their own singleton\n          // This code however only deals with modularity (e.g. the condition\n          // about bestDelta < 0, which is the delta for moving back to\n          // singleton wrt. modularity). Indeed, rarely, the Louvain\n          // algorithm can produce such cases when a node would be better in\n          // a singleton that in its own community when considering self loops\n          // or a resolution != 1. In this case, delta with your own community\n          // is indeed less than 0. To handle different metrics, one should\n          // consider computing the delta for going back to singleton because\n          // it might not be 0.\n          bestCommunity = index.isolate(i, inDegree, outDegree);\n\n          // If the node was already in a singleton community, we don't consider\n          // a move was made\n          if (bestCommunity === currentCommunity) continue;\n        } else {\n          // If no move was made, we continue to next node\n          if (bestCommunity === currentCommunity) {\n            continue;\n          } else {\n            // Actually moving the node to a new community\n            index.move(i, inDegree, outDegree, bestCommunity);\n          }\n        }\n\n        moveWasMade = true;\n        currentMoves++;\n\n        // Adding neighbors from other communities to the queue\n        start = index.starts[i];\n        end = index.starts[i + 1];\n\n        for (; start < end; start++) {\n          j = index.neighborhood[start];\n          targetCommunity = index.belongings[j];\n\n          if (targetCommunity !== bestCommunity) queue.enqueue(j);\n        }\n      }\n\n      moves.push(currentMoves);\n    } else {\n      localMoves = [];\n      moves.push(localMoves);\n\n      // Traditional Louvain iterative traversal of the graph\n      while (localMoveWasMade) {\n        localMoveWasMade = false;\n        currentMoves = 0;\n\n        ri = options.randomWalk ? randomIndex(l) : 0;\n\n        for (s = 0; s < l; s++, ri++) {\n          i = ri % l;\n\n          nodesVisited++;\n\n          inDegree = 0;\n          outDegree = 0;\n          communities.clear();\n\n          currentCommunity = index.belongings[i];\n\n          start = index.starts[i];\n          end = index.starts[i + 1];\n          offset = index.offsets[i];\n\n          // Traversing neighbors\n          for (; start < end; start++) {\n            out = start < offset;\n            j = index.neighborhood[start];\n            weight = index.weights[start];\n\n            targetCommunity = index.belongings[j];\n\n            // Incrementing metrics\n            if (out) outDegree += weight;\n            else inDegree += weight;\n\n            addWeightToCommunity(communities, targetCommunity, weight);\n          }\n\n          // Finding best community to move to\n          bestDelta = index.deltaWithOwnCommunity(\n            i,\n            inDegree,\n            outDegree,\n            communities.get(currentCommunity) || 0,\n            currentCommunity\n          );\n          bestCommunity = currentCommunity;\n\n          for (ci = 0; ci < communities.size; ci++) {\n            targetCommunity = communities.dense[ci];\n\n            if (targetCommunity === currentCommunity) continue;\n\n            targetCommunityDegree = communities.vals[ci];\n\n            deltaComputations++;\n\n            delta = index.delta(\n              i,\n              inDegree,\n              outDegree,\n              targetCommunityDegree,\n              targetCommunity\n            );\n\n            deltaIsBetter = tieBreaker(\n              bestCommunity,\n              currentCommunity,\n              targetCommunity,\n              delta,\n              bestDelta\n            );\n\n            if (deltaIsBetter) {\n              bestDelta = delta;\n              bestCommunity = targetCommunity;\n            }\n          }\n\n          // Should we move the node?\n          if (bestDelta < 0) {\n            // NOTE: this is to allow nodes to move back to their own singleton\n            // This code however only deals with modularity (e.g. the condition\n            // about bestDelta < 0, which is the delta for moving back to\n            // singleton wrt. modularity). Indeed, rarely, the Louvain\n            // algorithm can produce such cases when a node would be better in\n            // a singleton that in its own community when considering self loops\n            // or a resolution != 1. In this case, delta with your own community\n            // is indeed less than 0. To handle different metrics, one should\n            // consider computing the delta for going back to singleton because\n            // it might not be 0.\n            bestCommunity = index.isolate(i, inDegree, outDegree);\n\n            // If the node was already in a singleton community, we don't consider\n            // a move was made\n            if (bestCommunity === currentCommunity) continue;\n          } else {\n            // If no move was made, we continue to next node\n            if (bestCommunity === currentCommunity) {\n              continue;\n            } else {\n              // Actually moving the node to a new community\n              index.move(i, inDegree, outDegree, bestCommunity);\n            }\n          }\n\n          localMoveWasMade = true;\n          currentMoves++;\n        }\n\n        localMoves.push(currentMoves);\n\n        moveWasMade = localMoveWasMade || moveWasMade;\n      }\n    }\n\n    // We continue working on the induced graph\n    if (moveWasMade) index.zoomOut();\n  }\n\n  var results = {\n    index: index,\n    deltaComputations: deltaComputations,\n    nodesVisited: nodesVisited,\n    moves: moves\n  };\n\n  return results;\n}\n\n/**\n * Function returning the communities mapping of the graph.\n *\n * @param  {boolean} assign             - Assign communities to nodes attributes?\n * @param  {boolean} detailed           - Whether to return detailed information.\n * @param  {Graph}   graph              - Target graph.\n * @param  {object}  options            - Options:\n * @param  {string}    nodeCommunityAttribute - Community node attribute name.\n * @param  {string}    getEdgeWeight          - Weight edge attribute name or getter function.\n * @param  {string}    deltaComputation       - Method to use to compute delta computations.\n * @param  {boolean}   fastLocalMoves         - Whether to use the fast local move optimization.\n * @param  {boolean}   randomWalk             - Whether to traverse the graph in random order.\n * @param  {number}    resolution             - Resolution parameter.\n * @param  {function}  rng                    - RNG function to use.\n * @return {object}\n */\nfunction louvain(assign, detailed, graph, options) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-communities-louvain: the given graph is not a valid graphology instance.'\n    );\n\n  var type = inferType(graph);\n\n  if (type === 'mixed')\n    throw new Error(\n      'graphology-communities-louvain: cannot run the algorithm on a true mixed graph.'\n    );\n\n  // Attributes name\n  options = resolveDefaults(options, DEFAULTS);\n\n  // Empty graph case\n  var c = 0;\n\n  if (graph.size === 0) {\n    if (assign) {\n      graph.forEachNode(function (node) {\n        graph.setNodeAttribute(node, options.nodeCommunityAttribute, c++);\n      });\n\n      return;\n    }\n\n    var communities = {};\n\n    graph.forEachNode(function (node) {\n      communities[node] = c++;\n    });\n\n    if (!detailed) return communities;\n\n    return {\n      communities: communities,\n      count: graph.order,\n      deltaComputations: 0,\n      dendrogram: null,\n      level: 0,\n      modularity: NaN,\n      moves: null,\n      nodesVisited: 0,\n      resolution: options.resolution\n    };\n  }\n\n  var fn = type === 'undirected' ? undirectedLouvain : directedLouvain;\n\n  var results = fn(detailed, graph, options);\n\n  var index = results.index;\n\n  // Standard output\n  if (!detailed) {\n    if (assign) {\n      index.assign(options.nodeCommunityAttribute);\n      return;\n    }\n\n    return index.collect();\n  }\n\n  // Detailed output\n  var output = {\n    count: index.C,\n    deltaComputations: results.deltaComputations,\n    dendrogram: index.dendrogram,\n    level: index.level,\n    modularity: index.modularity(),\n    moves: results.moves,\n    nodesVisited: results.nodesVisited,\n    resolution: options.resolution\n  };\n\n  if (assign) {\n    index.assign(options.nodeCommunityAttribute);\n    return output;\n  }\n\n  output.communities = index.collect();\n\n  return output;\n}\n\n/**\n * Exporting.\n */\nvar fn = louvain.bind(null, false, false);\nfn.assign = louvain.bind(null, true, false);\nfn.detailed = louvain.bind(null, false, true);\nfn.defaults = DEFAULTS;\n\nmodule.exports = fn;\n","/**\n * Graphology Louvain Indices\n * ===========================\n *\n * Undirected & Directed Louvain Index structures used to compute the famous\n * Louvain community detection algorithm.\n *\n * Most of the rationale is explained in `graphology-metrics`.\n *\n * Note that this index shares a lot with the classic Union-Find data\n * structure. It also relies on a unused id stack to make sure we can\n * increase again the number of communites when isolating nodes.\n *\n * [Articles]\n * M. E. J. Newman, « Modularity and community structure in networks »,\n * Proc. Natl. Acad. Sci. USA, vol. 103, no 23, 2006, p. 8577–8582\n * https://dx.doi.org/10.1073%2Fpnas.0601602103\n *\n * Newman, M. E. J. « Community detection in networks: Modularity optimization\n * and maximum likelihood are equivalent ». Physical Review E, vol. 94, no 5,\n * novembre 2016, p. 052315. arXiv.org, doi:10.1103/PhysRevE.94.052315.\n * https://arxiv.org/pdf/1606.02319.pdf\n *\n * Blondel, Vincent D., et al. « Fast unfolding of communities in large\n * networks ». Journal of Statistical Mechanics: Theory and Experiment,\n * vol. 2008, no 10, octobre 2008, p. P10008. DOI.org (Crossref),\n * doi:10.1088/1742-5468/2008/10/P10008.\n * https://arxiv.org/pdf/0803.0476.pdf\n *\n * Nicolas Dugué, Anthony Perez. Directed Louvain: maximizing modularity in\n * directed networks. [Research Report] Université d’Orléans. 2015. hal-01231784\n * https://hal.archives-ouvertes.fr/hal-01231784\n *\n * R. Lambiotte, J.-C. Delvenne and M. Barahona. Laplacian Dynamics and\n * Multiscale Modular Structure in Networks,\n * doi:10.1109/TNSE.2015.2391998.\n * https://arxiv.org/abs/0812.1770\n *\n * [Latex]:\n *\n * Undirected Case:\n * ----------------\n *\n * \\Delta Q=\\bigg{[}\\frac{\\sum^{c}_{in}-(2d_{c}+l)}{2m}-\\bigg{(}\\frac{\\sum^{c}_{tot}-(d+l)}{2m}\\bigg{)}^{2}+\\frac{\\sum^{t}_{in}+(2d_{t}+l)}{2m}-\\bigg{(}\\frac{\\sum^{t}_{tot}+(d+l)}{2m}\\bigg{)}^{2}\\bigg{]}-\\bigg{[}\\frac{\\sum^{c}_{in}}{2m}-\\bigg{(}\\frac{\\sum^{c}_{tot}}{2m}\\bigg{)}^{2}+\\frac{\\sum^{t}_{in}}{2m}-\\bigg{(}\\frac{\\sum^{t}_{tot}}{2m}\\bigg{)}^{2}\\bigg{]}\n * \\Delta Q=\\frac{d_{t}-d_{c}}{m}+\\frac{l\\sum^{c}_{tot}+d\\sum^{c}_{tot}-d^{2}-l^{2}-2dl-l\\sum^{t}_{tot}-d\\sum^{t}_{tot}}{2m^{2}}\n * \\Delta Q=\\frac{d_{t}-d_{c}}{m}+\\frac{(l+d)\\sum^{c}_{tot}-d^{2}-l^{2}-2dl-(l+d)\\sum^{t}_{tot}}{2m^{2}}\n *\n * Directed Case:\n * --------------\n * \\Delta Q_d=\\bigg{[}\\frac{\\sum^{c}_{in}-(d_{c.in}+d_{c.out}+l)}{m}-\\frac{(\\sum^{c}_{tot.in}-(d_{in}+l))(\\sum^{c}_{tot.out}-(d_{out}+l))}{m^{2}}+\\frac{\\sum^{t}_{in}+(d_{t.in}+d_{t.out}+l)}{m}-\\frac{(\\sum^{t}_{tot.in}+(d_{in}+l))(\\sum^{t}_{tot.out}+(d_{out}+l))}{m^{2}}\\bigg{]}-\\bigg{[}\\frac{\\sum^{c}_{in}}{m}-\\frac{\\sum^{c}_{tot.in}\\sum^{c}_{tot.out}}{m^{2}}+\\frac{\\sum^{t}_{in}}{m}-\\frac{\\sum^{t}_{tot.in}\\sum^{t}_{tot.out}}{m^{2}}\\bigg{]}\n *\n * [Notes]:\n * Louvain is a bit unclear on this but delta computation are not derived from\n * Q1 - Q2 but rather between Q when considered node is isolated in its own\n * community versus Q with this node in target community. This is in fact\n * an optimization because the subtract part is constant in the formulae and\n * does not affect delta comparisons.\n */\nvar typed = require('mnemonist/utils/typed-arrays');\nvar resolveDefaults = require('graphology-utils/defaults');\nvar createEdgeWeightGetter =\n  require('graphology-utils/getters').createEdgeWeightGetter;\n\nvar INSPECT = Symbol.for('nodejs.util.inspect.custom');\n\nvar DEFAULTS = {\n  getEdgeWeight: 'weight',\n  keepDendrogram: false,\n  resolution: 1\n};\n\nfunction UndirectedLouvainIndex(graph, options) {\n  // Solving options\n  options = resolveDefaults(options, DEFAULTS);\n\n  var resolution = options.resolution;\n\n  // Weight getters\n  var getEdgeWeight = createEdgeWeightGetter(options.getEdgeWeight).fromEntry;\n\n  // Building the index\n  var size = (graph.size - graph.selfLoopCount) * 2;\n\n  var NeighborhoodPointerArray = typed.getPointerArray(size);\n  var NodesPointerArray = typed.getPointerArray(graph.order + 1);\n\n  // NOTE: this memory optimization can yield overflow deopt when computing deltas\n  var WeightsArray = options.getEdgeWeight\n    ? Float64Array\n    : typed.getPointerArray(graph.size * 2);\n\n  // Properties\n  this.C = graph.order;\n  this.M = 0;\n  this.E = size;\n  this.U = 0;\n  this.resolution = resolution;\n  this.level = 0;\n  this.graph = graph;\n  this.nodes = new Array(graph.order);\n  this.keepDendrogram = options.keepDendrogram;\n\n  // Edge-level\n  this.neighborhood = new NodesPointerArray(size);\n  this.weights = new WeightsArray(size);\n\n  // Node-level\n  this.loops = new WeightsArray(graph.order);\n  this.starts = new NeighborhoodPointerArray(graph.order + 1);\n  this.belongings = new NodesPointerArray(graph.order);\n  this.dendrogram = [];\n  this.mapping = null;\n\n  // Community-level\n  this.counts = new NodesPointerArray(graph.order);\n  this.unused = new NodesPointerArray(graph.order);\n  this.totalWeights = new WeightsArray(graph.order);\n\n  var ids = {};\n\n  var weight;\n\n  var i = 0,\n    n = 0;\n\n  var self = this;\n\n  graph.forEachNode(function (node) {\n    self.nodes[i] = node;\n\n    // Node map to index\n    ids[node] = i;\n\n    // Initializing starts\n    n += graph.undirectedDegreeWithoutSelfLoops(node);\n    self.starts[i] = n;\n\n    // Belongings\n    self.belongings[i] = i;\n    self.counts[i] = 1;\n    i++;\n  });\n\n  // Single sweep over the edges\n  graph.forEachEdge(function (edge, attr, source, target, sa, ta, u) {\n    weight = getEdgeWeight(edge, attr, source, target, sa, ta, u);\n\n    source = ids[source];\n    target = ids[target];\n\n    self.M += weight;\n\n    // Self loop?\n    if (source === target) {\n      self.totalWeights[source] += weight * 2;\n      self.loops[source] = weight * 2;\n    } else {\n      self.totalWeights[source] += weight;\n      self.totalWeights[target] += weight;\n\n      var startSource = --self.starts[source],\n        startTarget = --self.starts[target];\n\n      self.neighborhood[startSource] = target;\n      self.neighborhood[startTarget] = source;\n\n      self.weights[startSource] = weight;\n      self.weights[startTarget] = weight;\n    }\n  });\n\n  this.starts[i] = this.E;\n\n  if (this.keepDendrogram) this.dendrogram.push(this.belongings.slice());\n  else this.mapping = this.belongings.slice();\n}\n\nUndirectedLouvainIndex.prototype.isolate = function (i, degree) {\n  var currentCommunity = this.belongings[i];\n\n  // The node is already isolated\n  if (this.counts[currentCommunity] === 1) return currentCommunity;\n\n  var newCommunity = this.unused[--this.U];\n\n  var loops = this.loops[i];\n\n  this.totalWeights[currentCommunity] -= degree + loops;\n  this.totalWeights[newCommunity] += degree + loops;\n\n  this.belongings[i] = newCommunity;\n\n  this.counts[currentCommunity]--;\n  this.counts[newCommunity]++;\n\n  return newCommunity;\n};\n\nUndirectedLouvainIndex.prototype.move = function (i, degree, targetCommunity) {\n  var currentCommunity = this.belongings[i],\n    loops = this.loops[i];\n\n  this.totalWeights[currentCommunity] -= degree + loops;\n  this.totalWeights[targetCommunity] += degree + loops;\n\n  this.belongings[i] = targetCommunity;\n\n  var nowEmpty = this.counts[currentCommunity]-- === 1;\n  this.counts[targetCommunity]++;\n\n  if (nowEmpty) this.unused[this.U++] = currentCommunity;\n};\n\nUndirectedLouvainIndex.prototype.computeNodeDegree = function (i) {\n  var o, l, weight;\n\n  var degree = 0;\n\n  for (o = this.starts[i], l = this.starts[i + 1]; o < l; o++) {\n    weight = this.weights[o];\n\n    degree += weight;\n  }\n\n  return degree;\n};\n\nUndirectedLouvainIndex.prototype.expensiveIsolate = function (i) {\n  var degree = this.computeNodeDegree(i);\n  return this.isolate(i, degree);\n};\n\nUndirectedLouvainIndex.prototype.expensiveMove = function (i, ci) {\n  var degree = this.computeNodeDegree(i);\n  this.move(i, degree, ci);\n};\n\nUndirectedLouvainIndex.prototype.zoomOut = function () {\n  var inducedGraph = new Array(this.C - this.U),\n    newLabels = {};\n\n  var N = this.nodes.length;\n\n  var C = 0,\n    E = 0;\n\n  var i, j, l, m, n, ci, cj, data, adj;\n\n  // Renumbering communities\n  for (i = 0, l = this.C; i < l; i++) {\n    ci = this.belongings[i];\n\n    if (!(ci in newLabels)) {\n      newLabels[ci] = C;\n      inducedGraph[C] = {\n        adj: {},\n        totalWeights: this.totalWeights[ci],\n        internalWeights: 0\n      };\n      C++;\n    }\n\n    // We do this to otpimize the number of lookups in next loop\n    this.belongings[i] = newLabels[ci];\n  }\n\n  // Actualizing dendrogram\n  var currentLevel, nextLevel;\n\n  if (this.keepDendrogram) {\n    currentLevel = this.dendrogram[this.level];\n    nextLevel = new (typed.getPointerArray(C))(N);\n\n    for (i = 0; i < N; i++) nextLevel[i] = this.belongings[currentLevel[i]];\n\n    this.dendrogram.push(nextLevel);\n  } else {\n    for (i = 0; i < N; i++) this.mapping[i] = this.belongings[this.mapping[i]];\n  }\n\n  // Building induced graph matrix\n  for (i = 0, l = this.C; i < l; i++) {\n    ci = this.belongings[i];\n\n    data = inducedGraph[ci];\n    adj = data.adj;\n    data.internalWeights += this.loops[i];\n\n    for (j = this.starts[i], m = this.starts[i + 1]; j < m; j++) {\n      n = this.neighborhood[j];\n      cj = this.belongings[n];\n\n      if (ci === cj) {\n        data.internalWeights += this.weights[j];\n        continue;\n      }\n\n      if (!(cj in adj)) adj[cj] = 0;\n\n      adj[cj] += this.weights[j];\n    }\n  }\n\n  // Rewriting neighborhood\n  this.C = C;\n\n  n = 0;\n\n  for (ci = 0; ci < C; ci++) {\n    data = inducedGraph[ci];\n    adj = data.adj;\n\n    ci = +ci;\n\n    this.totalWeights[ci] = data.totalWeights;\n    this.loops[ci] = data.internalWeights;\n    this.counts[ci] = 1;\n\n    this.starts[ci] = n;\n    this.belongings[ci] = ci;\n\n    for (cj in adj) {\n      this.neighborhood[n] = +cj;\n      this.weights[n] = adj[cj];\n\n      E++;\n      n++;\n    }\n  }\n\n  this.starts[C] = E;\n\n  this.E = E;\n  this.U = 0;\n  this.level++;\n\n  return newLabels;\n};\n\nUndirectedLouvainIndex.prototype.modularity = function () {\n  var ci, cj, i, j, m;\n\n  var Q = 0;\n  var M2 = this.M * 2;\n  var internalWeights = new Float64Array(this.C);\n\n  for (i = 0; i < this.C; i++) {\n    ci = this.belongings[i];\n    internalWeights[ci] += this.loops[i];\n\n    for (j = this.starts[i], m = this.starts[i + 1]; j < m; j++) {\n      cj = this.belongings[this.neighborhood[j]];\n\n      if (ci !== cj) continue;\n\n      internalWeights[ci] += this.weights[j];\n    }\n  }\n\n  for (i = 0; i < this.C; i++) {\n    Q +=\n      internalWeights[i] / M2 -\n      Math.pow(this.totalWeights[i] / M2, 2) * this.resolution;\n  }\n\n  return Q;\n};\n\nUndirectedLouvainIndex.prototype.delta = function (\n  i,\n  degree,\n  targetCommunityDegree,\n  targetCommunity\n) {\n  var M = this.M;\n\n  var targetCommunityTotalWeight = this.totalWeights[targetCommunity];\n\n  degree += this.loops[i];\n\n  return (\n    targetCommunityDegree / M - // NOTE: formula is a bit different here because targetCommunityDegree is passed without * 2\n    (targetCommunityTotalWeight * degree * this.resolution) / (2 * M * M)\n  );\n};\n\nUndirectedLouvainIndex.prototype.deltaWithOwnCommunity = function (\n  i,\n  degree,\n  targetCommunityDegree,\n  targetCommunity\n) {\n  var M = this.M;\n\n  var targetCommunityTotalWeight = this.totalWeights[targetCommunity];\n\n  degree += this.loops[i];\n\n  return (\n    targetCommunityDegree / M - // NOTE: formula is a bit different here because targetCommunityDegree is passed without * 2\n    ((targetCommunityTotalWeight - degree) * degree * this.resolution) /\n      (2 * M * M)\n  );\n};\n\n// NOTE: this is just a faster but equivalent version of #.delta\n// It is just off by a constant factor and is just faster to compute\nUndirectedLouvainIndex.prototype.fastDelta = function (\n  i,\n  degree,\n  targetCommunityDegree,\n  targetCommunity\n) {\n  var M = this.M;\n\n  var targetCommunityTotalWeight = this.totalWeights[targetCommunity];\n\n  degree += this.loops[i];\n\n  return (\n    targetCommunityDegree -\n    (degree * targetCommunityTotalWeight * this.resolution) / (2 * M)\n  );\n};\n\nUndirectedLouvainIndex.prototype.fastDeltaWithOwnCommunity = function (\n  i,\n  degree,\n  targetCommunityDegree,\n  targetCommunity\n) {\n  var M = this.M;\n\n  var targetCommunityTotalWeight = this.totalWeights[targetCommunity];\n\n  degree += this.loops[i];\n\n  return (\n    targetCommunityDegree -\n    (degree * (targetCommunityTotalWeight - degree) * this.resolution) / (2 * M)\n  );\n};\n\nUndirectedLouvainIndex.prototype.bounds = function (i) {\n  return [this.starts[i], this.starts[i + 1]];\n};\n\nUndirectedLouvainIndex.prototype.project = function () {\n  var self = this;\n\n  var projection = {};\n\n  self.nodes.slice(0, this.C).forEach(function (node, i) {\n    projection[node] = Array.from(\n      self.neighborhood.slice(self.starts[i], self.starts[i + 1])\n    ).map(function (j) {\n      return self.nodes[j];\n    });\n  });\n\n  return projection;\n};\n\nUndirectedLouvainIndex.prototype.collect = function (level) {\n  if (arguments.length < 1) level = this.level;\n\n  var o = {};\n\n  var mapping = this.keepDendrogram ? this.dendrogram[level] : this.mapping;\n\n  var i, l;\n\n  for (i = 0, l = mapping.length; i < l; i++) o[this.nodes[i]] = mapping[i];\n\n  return o;\n};\n\nUndirectedLouvainIndex.prototype.assign = function (prop, level) {\n  if (arguments.length < 2) level = this.level;\n\n  var mapping = this.keepDendrogram ? this.dendrogram[level] : this.mapping;\n\n  var i, l;\n\n  for (i = 0, l = mapping.length; i < l; i++)\n    this.graph.setNodeAttribute(this.nodes[i], prop, mapping[i]);\n};\n\nUndirectedLouvainIndex.prototype[INSPECT] = function () {\n  var proxy = {};\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: UndirectedLouvainIndex,\n    enumerable: false\n  });\n\n  proxy.C = this.C;\n  proxy.M = this.M;\n  proxy.E = this.E;\n  proxy.U = this.U;\n  proxy.resolution = this.resolution;\n  proxy.level = this.level;\n  proxy.nodes = this.nodes;\n  proxy.starts = this.starts.slice(0, proxy.C + 1);\n\n  var eTruncated = ['neighborhood', 'weights'];\n  var cTruncated = ['counts', 'loops', 'belongings', 'totalWeights'];\n\n  var self = this;\n\n  eTruncated.forEach(function (key) {\n    proxy[key] = self[key].slice(0, proxy.E);\n  });\n\n  cTruncated.forEach(function (key) {\n    proxy[key] = self[key].slice(0, proxy.C);\n  });\n\n  proxy.unused = this.unused.slice(0, this.U);\n\n  if (this.keepDendrogram) proxy.dendrogram = this.dendrogram;\n  else proxy.mapping = this.mapping;\n\n  return proxy;\n};\n\nfunction DirectedLouvainIndex(graph, options) {\n  // Solving options\n  options = resolveDefaults(options, DEFAULTS);\n\n  var resolution = options.resolution;\n\n  // Weight getters\n  var getEdgeWeight = createEdgeWeightGetter(options.getEdgeWeight).fromEntry;\n\n  // Building the index\n  var size = (graph.size - graph.selfLoopCount) * 2;\n\n  var NeighborhoodPointerArray = typed.getPointerArray(size);\n  var NodesPointerArray = typed.getPointerArray(graph.order + 1);\n\n  // NOTE: this memory optimization can yield overflow deopt when computing deltas\n  var WeightsArray = options.getEdgeWeight\n    ? Float64Array\n    : typed.getPointerArray(graph.size * 2);\n\n  // Properties\n  this.C = graph.order;\n  this.M = 0;\n  this.E = size;\n  this.U = 0;\n  this.resolution = resolution;\n  this.level = 0;\n  this.graph = graph;\n  this.nodes = new Array(graph.order);\n  this.keepDendrogram = options.keepDendrogram;\n\n  // Edge-level\n  // NOTE: edges are stored out then in, in this order\n  this.neighborhood = new NodesPointerArray(size);\n  this.weights = new WeightsArray(size);\n\n  // Node-level\n  this.loops = new WeightsArray(graph.order);\n  this.starts = new NeighborhoodPointerArray(graph.order + 1);\n  this.offsets = new NeighborhoodPointerArray(graph.order);\n  this.belongings = new NodesPointerArray(graph.order);\n  this.dendrogram = [];\n\n  // Community-level\n  this.counts = new NodesPointerArray(graph.order);\n  this.unused = new NodesPointerArray(graph.order);\n  this.totalInWeights = new WeightsArray(graph.order);\n  this.totalOutWeights = new WeightsArray(graph.order);\n\n  var ids = {};\n\n  var weight;\n\n  var i = 0,\n    n = 0;\n\n  var self = this;\n\n  graph.forEachNode(function (node) {\n    self.nodes[i] = node;\n\n    // Node map to index\n    ids[node] = i;\n\n    // Initializing starts & offsets\n    n += graph.outDegreeWithoutSelfLoops(node);\n    self.starts[i] = n;\n\n    n += graph.inDegreeWithoutSelfLoops(node);\n    self.offsets[i] = n;\n\n    // Belongings\n    self.belongings[i] = i;\n    self.counts[i] = 1;\n    i++;\n  });\n\n  // Single sweep over the edges\n  graph.forEachEdge(function (edge, attr, source, target, sa, ta, u) {\n    weight = getEdgeWeight(edge, attr, source, target, sa, ta, u);\n\n    source = ids[source];\n    target = ids[target];\n\n    self.M += weight;\n\n    // Self loop?\n    if (source === target) {\n      self.loops[source] += weight;\n      self.totalInWeights[source] += weight;\n      self.totalOutWeights[source] += weight;\n    } else {\n      self.totalOutWeights[source] += weight;\n      self.totalInWeights[target] += weight;\n\n      var startSource = --self.starts[source],\n        startTarget = --self.offsets[target];\n\n      self.neighborhood[startSource] = target;\n      self.neighborhood[startTarget] = source;\n\n      self.weights[startSource] = weight;\n      self.weights[startTarget] = weight;\n    }\n  });\n\n  this.starts[i] = this.E;\n\n  if (this.keepDendrogram) this.dendrogram.push(this.belongings.slice());\n  else this.mapping = this.belongings.slice();\n}\n\nDirectedLouvainIndex.prototype.bounds = UndirectedLouvainIndex.prototype.bounds;\n\nDirectedLouvainIndex.prototype.inBounds = function (i) {\n  return [this.offsets[i], this.starts[i + 1]];\n};\n\nDirectedLouvainIndex.prototype.outBounds = function (i) {\n  return [this.starts[i], this.offsets[i]];\n};\n\nDirectedLouvainIndex.prototype.project =\n  UndirectedLouvainIndex.prototype.project;\n\nDirectedLouvainIndex.prototype.projectIn = function () {\n  var self = this;\n\n  var projection = {};\n\n  self.nodes.slice(0, this.C).forEach(function (node, i) {\n    projection[node] = Array.from(\n      self.neighborhood.slice(self.offsets[i], self.starts[i + 1])\n    ).map(function (j) {\n      return self.nodes[j];\n    });\n  });\n\n  return projection;\n};\n\nDirectedLouvainIndex.prototype.projectOut = function () {\n  var self = this;\n\n  var projection = {};\n\n  self.nodes.slice(0, this.C).forEach(function (node, i) {\n    projection[node] = Array.from(\n      self.neighborhood.slice(self.starts[i], self.offsets[i])\n    ).map(function (j) {\n      return self.nodes[j];\n    });\n  });\n\n  return projection;\n};\n\nDirectedLouvainIndex.prototype.isolate = function (i, inDegree, outDegree) {\n  var currentCommunity = this.belongings[i];\n\n  // The node is already isolated\n  if (this.counts[currentCommunity] === 1) return currentCommunity;\n\n  var newCommunity = this.unused[--this.U];\n\n  var loops = this.loops[i];\n\n  this.totalInWeights[currentCommunity] -= inDegree + loops;\n  this.totalInWeights[newCommunity] += inDegree + loops;\n\n  this.totalOutWeights[currentCommunity] -= outDegree + loops;\n  this.totalOutWeights[newCommunity] += outDegree + loops;\n\n  this.belongings[i] = newCommunity;\n\n  this.counts[currentCommunity]--;\n  this.counts[newCommunity]++;\n\n  return newCommunity;\n};\n\nDirectedLouvainIndex.prototype.move = function (\n  i,\n  inDegree,\n  outDegree,\n  targetCommunity\n) {\n  var currentCommunity = this.belongings[i],\n    loops = this.loops[i];\n\n  this.totalInWeights[currentCommunity] -= inDegree + loops;\n  this.totalInWeights[targetCommunity] += inDegree + loops;\n\n  this.totalOutWeights[currentCommunity] -= outDegree + loops;\n  this.totalOutWeights[targetCommunity] += outDegree + loops;\n\n  this.belongings[i] = targetCommunity;\n\n  var nowEmpty = this.counts[currentCommunity]-- === 1;\n  this.counts[targetCommunity]++;\n\n  if (nowEmpty) this.unused[this.U++] = currentCommunity;\n};\n\nDirectedLouvainIndex.prototype.computeNodeInDegree = function (i) {\n  var o, l, weight;\n\n  var inDegree = 0;\n\n  for (o = this.offsets[i], l = this.starts[i + 1]; o < l; o++) {\n    weight = this.weights[o];\n\n    inDegree += weight;\n  }\n\n  return inDegree;\n};\n\nDirectedLouvainIndex.prototype.computeNodeOutDegree = function (i) {\n  var o, l, weight;\n\n  var outDegree = 0;\n\n  for (o = this.starts[i], l = this.offsets[i]; o < l; o++) {\n    weight = this.weights[o];\n\n    outDegree += weight;\n  }\n\n  return outDegree;\n};\n\nDirectedLouvainIndex.prototype.expensiveMove = function (i, ci) {\n  var inDegree = this.computeNodeInDegree(i),\n    outDegree = this.computeNodeOutDegree(i);\n\n  this.move(i, inDegree, outDegree, ci);\n};\n\nDirectedLouvainIndex.prototype.zoomOut = function () {\n  var inducedGraph = new Array(this.C - this.U),\n    newLabels = {};\n\n  var N = this.nodes.length;\n\n  var C = 0,\n    E = 0;\n\n  var i, j, l, m, n, ci, cj, data, offset, out, adj, inAdj, outAdj;\n\n  // Renumbering communities\n  for (i = 0, l = this.C; i < l; i++) {\n    ci = this.belongings[i];\n\n    if (!(ci in newLabels)) {\n      newLabels[ci] = C;\n      inducedGraph[C] = {\n        inAdj: {},\n        outAdj: {},\n        totalInWeights: this.totalInWeights[ci],\n        totalOutWeights: this.totalOutWeights[ci],\n        internalWeights: 0\n      };\n      C++;\n    }\n\n    // We do this to otpimize the number of lookups in next loop\n    this.belongings[i] = newLabels[ci];\n  }\n\n  // Actualizing dendrogram\n  var currentLevel, nextLevel;\n\n  if (this.keepDendrogram) {\n    currentLevel = this.dendrogram[this.level];\n    nextLevel = new (typed.getPointerArray(C))(N);\n\n    for (i = 0; i < N; i++) nextLevel[i] = this.belongings[currentLevel[i]];\n\n    this.dendrogram.push(nextLevel);\n  } else {\n    for (i = 0; i < N; i++) this.mapping[i] = this.belongings[this.mapping[i]];\n  }\n\n  // Building induced graph matrix\n  for (i = 0, l = this.C; i < l; i++) {\n    ci = this.belongings[i];\n    offset = this.offsets[i];\n\n    data = inducedGraph[ci];\n    inAdj = data.inAdj;\n    outAdj = data.outAdj;\n    data.internalWeights += this.loops[i];\n\n    for (j = this.starts[i], m = this.starts[i + 1]; j < m; j++) {\n      n = this.neighborhood[j];\n      cj = this.belongings[n];\n      out = j < offset;\n\n      adj = out ? outAdj : inAdj;\n\n      if (ci === cj) {\n        if (out) data.internalWeights += this.weights[j];\n\n        continue;\n      }\n\n      if (!(cj in adj)) adj[cj] = 0;\n\n      adj[cj] += this.weights[j];\n    }\n  }\n\n  // Rewriting neighborhood\n  this.C = C;\n\n  n = 0;\n\n  for (ci = 0; ci < C; ci++) {\n    data = inducedGraph[ci];\n    inAdj = data.inAdj;\n    outAdj = data.outAdj;\n\n    ci = +ci;\n\n    this.totalInWeights[ci] = data.totalInWeights;\n    this.totalOutWeights[ci] = data.totalOutWeights;\n    this.loops[ci] = data.internalWeights;\n    this.counts[ci] = 1;\n\n    this.starts[ci] = n;\n    this.belongings[ci] = ci;\n\n    for (cj in outAdj) {\n      this.neighborhood[n] = +cj;\n      this.weights[n] = outAdj[cj];\n\n      E++;\n      n++;\n    }\n\n    this.offsets[ci] = n;\n\n    for (cj in inAdj) {\n      this.neighborhood[n] = +cj;\n      this.weights[n] = inAdj[cj];\n\n      E++;\n      n++;\n    }\n  }\n\n  this.starts[C] = E;\n\n  this.E = E;\n  this.U = 0;\n  this.level++;\n\n  return newLabels;\n};\n\nDirectedLouvainIndex.prototype.modularity = function () {\n  var ci, cj, i, j, m;\n\n  var Q = 0;\n  var M = this.M;\n  var internalWeights = new Float64Array(this.C);\n\n  for (i = 0; i < this.C; i++) {\n    ci = this.belongings[i];\n    internalWeights[ci] += this.loops[i];\n\n    for (j = this.starts[i], m = this.offsets[i]; j < m; j++) {\n      cj = this.belongings[this.neighborhood[j]];\n\n      if (ci !== cj) continue;\n\n      internalWeights[ci] += this.weights[j];\n    }\n  }\n\n  for (i = 0; i < this.C; i++)\n    Q +=\n      internalWeights[i] / M -\n      ((this.totalInWeights[i] * this.totalOutWeights[i]) / Math.pow(M, 2)) *\n        this.resolution;\n\n  return Q;\n};\n\nDirectedLouvainIndex.prototype.delta = function (\n  i,\n  inDegree,\n  outDegree,\n  targetCommunityDegree,\n  targetCommunity\n) {\n  var M = this.M;\n\n  var targetCommunityTotalInWeight = this.totalInWeights[targetCommunity],\n    targetCommunityTotalOutWeight = this.totalOutWeights[targetCommunity];\n\n  var loops = this.loops[i];\n\n  inDegree += loops;\n  outDegree += loops;\n\n  return (\n    targetCommunityDegree / M -\n    ((outDegree * targetCommunityTotalInWeight +\n      inDegree * targetCommunityTotalOutWeight) *\n      this.resolution) /\n      (M * M)\n  );\n};\n\nDirectedLouvainIndex.prototype.deltaWithOwnCommunity = function (\n  i,\n  inDegree,\n  outDegree,\n  targetCommunityDegree,\n  targetCommunity\n) {\n  var M = this.M;\n\n  var targetCommunityTotalInWeight = this.totalInWeights[targetCommunity],\n    targetCommunityTotalOutWeight = this.totalOutWeights[targetCommunity];\n\n  var loops = this.loops[i];\n\n  inDegree += loops;\n  outDegree += loops;\n\n  return (\n    targetCommunityDegree / M -\n    ((outDegree * (targetCommunityTotalInWeight - inDegree) +\n      inDegree * (targetCommunityTotalOutWeight - outDegree)) *\n      this.resolution) /\n      (M * M)\n  );\n};\n\nDirectedLouvainIndex.prototype.collect =\n  UndirectedLouvainIndex.prototype.collect;\nDirectedLouvainIndex.prototype.assign = UndirectedLouvainIndex.prototype.assign;\n\nDirectedLouvainIndex.prototype[INSPECT] = function () {\n  var proxy = {};\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: DirectedLouvainIndex,\n    enumerable: false\n  });\n\n  proxy.C = this.C;\n  proxy.M = this.M;\n  proxy.E = this.E;\n  proxy.U = this.U;\n  proxy.resolution = this.resolution;\n  proxy.level = this.level;\n  proxy.nodes = this.nodes;\n  proxy.starts = this.starts.slice(0, proxy.C + 1);\n\n  var eTruncated = ['neighborhood', 'weights'];\n  var cTruncated = [\n    'counts',\n    'offsets',\n    'loops',\n    'belongings',\n    'totalInWeights',\n    'totalOutWeights'\n  ];\n\n  var self = this;\n\n  eTruncated.forEach(function (key) {\n    proxy[key] = self[key].slice(0, proxy.E);\n  });\n\n  cTruncated.forEach(function (key) {\n    proxy[key] = self[key].slice(0, proxy.C);\n  });\n\n  proxy.unused = this.unused.slice(0, this.U);\n\n  if (this.keepDendrogram) proxy.dendrogram = this.dendrogram;\n  else proxy.mapping = this.mapping;\n\n  return proxy;\n};\n\nexports.UndirectedLouvainIndex = UndirectedLouvainIndex;\nexports.DirectedLouvainIndex = DirectedLouvainIndex;\n","/**\n * Graphology Defaults\n * ====================\n *\n * Helper function used throughout the standard lib to resolve defaults.\n */\nfunction isLeaf(o) {\n  return (\n    !o ||\n    typeof o !== 'object' ||\n    typeof o === 'function' ||\n    Array.isArray(o) ||\n    o instanceof Set ||\n    o instanceof Map ||\n    o instanceof RegExp ||\n    o instanceof Date\n  );\n}\n\nfunction resolveDefaults(target, defaults) {\n  target = target || {};\n\n  var output = {};\n\n  for (var k in defaults) {\n    var existing = target[k];\n    var def = defaults[k];\n\n    // Recursion\n    if (!isLeaf(def)) {\n      output[k] = resolveDefaults(existing, def);\n\n      continue;\n    }\n\n    // Leaf\n    if (existing === undefined) {\n      output[k] = def;\n    } else {\n      output[k] = existing;\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = resolveDefaults;\n","/**\n * Mnemonist SparseMap\n * ====================\n *\n * JavaScript sparse map implemented on top of byte arrays.\n *\n * [Reference]: https://research.swtch.com/sparse\n */\nvar Iterator = require('obliterator/iterator'),\n    getPointerArray = require('./utils/typed-arrays.js').getPointerArray;\n\n/**\n * SparseMap.\n *\n * @constructor\n */\nfunction SparseMap(Values, length) {\n  if (arguments.length < 2) {\n    length = Values;\n    Values = Array;\n  }\n\n  var ByteArray = getPointerArray(length);\n\n  // Properties\n  this.size = 0;\n  this.length = length;\n  this.dense = new ByteArray(length);\n  this.sparse = new ByteArray(length);\n  this.vals = new Values(length);\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nSparseMap.prototype.clear = function() {\n  this.size = 0;\n};\n\n/**\n * Method used to check the existence of a member in the set.\n *\n * @param  {number} member - Member to test.\n * @return {SparseMap}\n */\nSparseMap.prototype.has = function(member) {\n  var index = this.sparse[member];\n\n  return (\n    index < this.size &&\n    this.dense[index] === member\n  );\n};\n\n/**\n * Method used to get the value associated to a member in the set.\n *\n * @param  {number} member - Member to test.\n * @return {any}\n */\nSparseMap.prototype.get = function(member) {\n  var index = this.sparse[member];\n\n  if (index < this.size && this.dense[index] === member)\n    return this.vals[index];\n\n  return;\n};\n\n/**\n * Method used to set a value into the map.\n *\n * @param  {number} member - Member to set.\n * @param  {any}    value  - Associated value.\n * @return {SparseMap}\n */\nSparseMap.prototype.set = function(member, value) {\n  var index = this.sparse[member];\n\n  if (index < this.size && this.dense[index] === member) {\n    this.vals[index] = value;\n    return this;\n  }\n\n  this.dense[this.size] = member;\n  this.sparse[member] = this.size;\n  this.vals[this.size] = value;\n  this.size++;\n\n  return this;\n};\n\n/**\n * Method used to remove a member from the set.\n *\n * @param  {number} member - Member to delete.\n * @return {boolean}\n */\nSparseMap.prototype.delete = function(member) {\n  var index = this.sparse[member];\n\n  if (index >= this.size || this.dense[index] !== member)\n    return false;\n\n  index = this.dense[this.size - 1];\n  this.dense[this.sparse[member]] = index;\n  this.sparse[index] = this.sparse[member];\n  this.size--;\n\n  return true;\n};\n\n/**\n * Method used to iterate over the set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nSparseMap.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  for (var i = 0; i < this.size; i++)\n    callback.call(scope, this.vals[i], this.dense[i]);\n};\n\n/**\n * Method used to create an iterator over a set's members.\n *\n * @return {Iterator}\n */\nSparseMap.prototype.keys = function() {\n  var size = this.size,\n      dense = this.dense,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i < size) {\n      var item = dense[i];\n      i++;\n\n      return {\n        value: item\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\nSparseMap.prototype.values = function() {\n  var size = this.size,\n      values = this.vals,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i < size) {\n      var item = values[i];\n      i++;\n\n      return {\n        value: item\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a set's entries.\n *\n * @return {Iterator}\n */\nSparseMap.prototype.entries = function() {\n  var size = this.size,\n      dense = this.dense,\n      values = this.vals,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i < size) {\n      var item = [dense[i], values[i]];\n      i++;\n\n      return {\n        value: item\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  SparseMap.prototype[Symbol.iterator] = SparseMap.prototype.entries;\n\n/**\n * Convenience known methods.\n */\nSparseMap.prototype.inspect = function() {\n  var proxy = new Map();\n\n  for (var i = 0; i < this.size; i++)\n    proxy.set(this.dense[i], this.vals[i]);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: SparseMap,\n    enumerable: false\n  });\n\n  proxy.length = this.length;\n\n  if (this.vals.constructor !== Array)\n    proxy.type = this.vals.constructor.name;\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  SparseMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = SparseMap.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = SparseMap;\n","/**\n * Mnemonist SparseQueueSet\n * =========================\n *\n * JavaScript sparse queue set implemented on top of byte arrays.\n *\n * [Reference]: https://research.swtch.com/sparse\n */\nvar Iterator = require('obliterator/iterator'),\n    getPointerArray = require('./utils/typed-arrays.js').getPointerArray;\n\n/**\n * SparseQueueSet.\n *\n * @constructor\n */\nfunction SparseQueueSet(capacity) {\n\n  var ByteArray = getPointerArray(capacity);\n\n  // Properties\n  this.start = 0;\n  this.size = 0;\n  this.capacity = capacity;\n  this.dense = new ByteArray(capacity);\n  this.sparse = new ByteArray(capacity);\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nSparseQueueSet.prototype.clear = function() {\n  this.start = 0;\n  this.size = 0;\n};\n\n/**\n * Method used to check the existence of a member in the queue.\n *\n * @param  {number} member - Member to test.\n * @return {SparseQueueSet}\n */\nSparseQueueSet.prototype.has = function(member) {\n  if (this.size === 0)\n    return false;\n\n  var index = this.sparse[member];\n\n  var inBounds = (\n    index < this.capacity &&\n    (\n      index >= this.start &&\n      index < this.start + this.size\n    ) ||\n    (\n      index < ((this.start + this.size) % this.capacity)\n    )\n  );\n\n  return (\n    inBounds &&\n    this.dense[index] === member\n  );\n};\n\n/**\n * Method used to add a member to the queue.\n *\n * @param  {number} member - Member to add.\n * @return {SparseQueueSet}\n */\nSparseQueueSet.prototype.enqueue = function(member) {\n  var index = this.sparse[member];\n\n  if (this.size !== 0) {\n    var inBounds = (\n      index < this.capacity &&\n      (\n        index >= this.start &&\n        index < this.start + this.size\n      ) ||\n      (\n        index < ((this.start + this.size) % this.capacity)\n      )\n    );\n\n    if (inBounds && this.dense[index] === member)\n      return this;\n  }\n\n  index = (this.start + this.size) % this.capacity;\n\n  this.dense[index] = member;\n  this.sparse[member] = index;\n  this.size++;\n\n  return this;\n};\n\n/**\n * Method used to remove the next member from the queue.\n *\n * @param  {number} member - Member to delete.\n * @return {boolean}\n */\nSparseQueueSet.prototype.dequeue = function() {\n  if (this.size === 0)\n    return;\n\n  var index = this.start;\n\n  this.size--;\n  this.start++;\n\n  if (this.start === this.capacity)\n    this.start = 0;\n\n  var member = this.dense[index];\n\n  this.sparse[member] = this.capacity;\n\n  return member;\n};\n\n/**\n * Method used to iterate over the queue's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nSparseQueueSet.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    callback.call(scope, this.dense[i], j, this);\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n  }\n};\n\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\nSparseQueueSet.prototype.values = function() {\n  var dense = this.dense,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  return new Iterator(function() {\n    if (j >= l)\n      return {\n        done: true\n      };\n\n    var value = dense[i];\n\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  SparseQueueSet.prototype[Symbol.iterator] = SparseQueueSet.prototype.values;\n\n/**\n * Convenience known methods.\n */\nSparseQueueSet.prototype.inspect = function() {\n  var proxy = [];\n\n  this.forEach(function(member) {\n    proxy.push(member);\n  });\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: SparseQueueSet,\n    enumerable: false\n  });\n\n  proxy.capacity = this.capacity;\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  SparseQueueSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = SparseQueueSet.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = SparseQueueSet;\n","/**\n * Pandemonium Random Index\n * =========================\n *\n * Random index function.\n */\n\n/**\n * Creating a function returning a random index from the given array.\n *\n * @param  {function} rng - RNG function returning uniform random.\n * @return {function}     - The created function.\n */\nfunction createRandomIndex(rng) {\n  /**\n   * Random function.\n   *\n   * @param  {array|number}  array - Target array or length of the array.\n   * @return {number}\n   */\n  return function (length) {\n    if (typeof length !== 'number') length = length.length;\n\n    return Math.floor(rng() * length);\n  };\n}\n\n/**\n * Default random index using `Math.random`.\n */\nvar randomIndex = createRandomIndex(Math.random);\n\n/**\n * Exporting.\n */\nrandomIndex.createRandomIndex = createRandomIndex;\nmodule.exports = randomIndex;\n"],"names":[],"sourceRoot":""}